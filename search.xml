<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我在信安的这两年</title>
      <link href="/2022/07/10/%E6%88%91%E5%9C%A8%E4%BF%A1%E5%AE%89%E7%9A%84%E8%BF%99%E4%B8%A4%E5%B9%B4/"/>
      <url>/2022/07/10/%E6%88%91%E5%9C%A8%E4%BF%A1%E5%AE%89%E7%9A%84%E8%BF%99%E4%B8%A4%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这些文字主要是写给我自己，总结一下过去的两年，写完好像有种自传的既视感hhh。除了给自己记录一下外，发出来的原因也有以下几点</p><ul><li><p>让大家简单介绍一下信息安全是个啥专业？</p><ul><li>因为lz的朋友们对信安的第一印象总是，他不是管院下的，就是信电的。甚至信安搬到玉泉的行李寄存处写的是信工orz。其实是计院下的，没想到吧</li></ul></li><li><p>帮助感兴趣的学弟学妹们认识一下信息安全</p></li><li><p>lz辅修ITP，发现98上没有人分享过ITP的经验，对于商科、ITP感兴趣的理工科同学们，也可以从我的经历中了解到理工科视角下的ITP，当然只是我的个人视角，顺便为新一年的招生打个广告（×</p></li><li><p>这些文字里会包括我很多复杂的经历以及反思，如果我的任何一段经历能够给大家一些启发或者共鸣，是我的荣幸</p></li></ul><p>写的有点乱，还请见谅。</p><h3 id="前言">前言</h3><p>为什么会突然想起这个标题呢？其实这个学期的总结拖了很久，前几天依上个学期样画葫芦写了一点本学期课程的总结，快要写完的时候，被辅导员拉去手写了大一一年的总结，有感而发，想多唠一点和课程无关的，加上最近发生了很多的事情，仅纪念我过去的两年。</p><p>今年的笔记和课程资源在这个链接下 <a href="https://github.com/RyanFcr/ZJU_Course">https://github.com/RyanFcr/ZJU_Course</a> ，有需求自取~</p><p>（以下内容出现在这里纯属二进制 bit 的随意组合，与本人毫无关系）</p><h3 id="大一上-梦的开始">大一上 梦的开始</h3><p>两年前的这个时候，我刚刚考完高考（高考延期），最后在南大cs/ai和浙大工信中选择了工信。作为浙江人，一开始对浙大期望比较低，反倒是这样，我觉得浙大满足了我对大学的所有幻想。</p><p>大一一进来就匆忙的分流，还记得当时学生会的学长学姐辅导我们分流面试（在此谢谢lhm、shr等诸位学长学姐）的时候，我当时也没想清楚自己要选什么专业，只知道自己想进计院的专业，因为物理太差，其他工科提不起兴趣，生医工更是不要说了，生物都没有选。定了大致的方向之后，开始去了解了计院三大专业——计科、软工和信安。其中我最喜欢的是信安，一方面是觉得他很酷，黑客啥的（但目前为止软件安全给我的体验极好，浅浅当了一把黑客），另一方面自己没有竞赛经验，计科又大佬云集，面试竞争激烈。最后信安面试体验非常好，感觉老师同学都很nice，我还给了同场面试的同学一种“班主任”的感觉（可能是因为进去面试之前我和大家说心态放平，不要紧张），就这样跌跌撞撞进了信安，分流结束之后，好像人生大事定下来一样。</p><p>有一件事是在分流前，大一上刚进来的我在信电学长分享会上认识了一位信电的学长，期初这个分享会是我们辅导员为了宣传信电学院的，但是让我意外认识了那位学长，他辅修了ITP，这次分享会改变了我的大学生涯。我也因此加入了一个创新创业类的社团，参与了我大学来的第一场面试，说起来，我面试的时候才知道无领导小组讨论是啥，hhh。后来我和社团里的朋友一起去看了ITP的线下宣讲会，发现原来浙大还有这样一群人，这样一个班的存在。</p><p>接下来，我玩的很疯，参加了很多活动，有了很多前所未有的体验。玩了3D打印，辩论赛，主持人，毅行，人生第一场livehouse，篮球比赛，健身，讲座分享团团转。好在大一上课没选上多少（24.5学分），最后期末补天没有特别极限。</p><p>期末考试周中间脑子一热（主要是受Sean的影响，感觉可以提前做点东西，科研导向的学习，而不是被课程卡死，感谢Sean），就给zbs老师发了邮件，希望能在他那边做点东西，老师非常热情（在此感谢zbs老师的收留），但是我后来忙于考试，最后还是老师直接钉钉私戳加了微信，但是碍于自己能力太差，最后暂时告一段落，打算先提升自己再说。</p><p>关于课程</p><ul><li><p>线性代数非常重要</p></li><li><p>建议大一上学分少一点，留点时间给平时，做点自己想做的事情</p><ul><li>我当时脑子一热就想为高中百年校庆献礼，就搞了一个公众号分享我们那届的学习经验；还纪念自己的2020，搞了一个视频</li></ul></li></ul><h3 id="大一下-大学2-0">大一下 大学2.0</h3><p>寒假结束之后，图灵班选拔，脑子一热，拉上好朋友sxj就一起报名了，最后来到了图灵班大家庭。报名的原因，一是给自己一个机会，开启大学的hard模式，希望可以学到很多；二是希望能够认识更多的朋友，一起进步成长。由于转专业需要补课，加上信安在大一下已经有几门workload很大的课，导致我大一下过的非常充实（累），一开始39学分，最后退课到35学分才勉强上完这一学期。整个学期给我的体验是天差地别，没想到读大学会这么累，不过这个学期看到好多信安xdxm们凌晨一两点发刷夜记录突然感觉自己当时太摆了（但是要注意身体！），但是信安真的很温暖，起码我们这届，每天水群使感情深厚（×，认识了好多朋友，感谢信安群友们的帮助，感谢wyhgg，感谢大家。但这个学期，让我感受到强烈的不适，很痛苦，毫无正反馈，让我产生了我是否适合这个专业的念头，我开始选择逃避，想试试看其他路会不会更适合我，对课程也开始摆烂了，只想赶紧过去。（可能许多信安的xdxm这个学期结束也会有这样的感受）</p><p>课程之外，当时跟着社团里的同学一起参加了一个商赛，其实自己当时只是跟风，想试试看，但是给我的体验挺差的，我自己没有想好为什么要参加这个比赛，算是不明不白的试错了，也不知道未来自己的路怎么走，好在试错成本很低。大一下课业压力很重，留给平时自己生活时间不多，印象很深的还有和云峰的家人们篮球三好杯突破了首轮，感觉这就是青春啊。</p><p>关于课程</p><ul><li><p>信安从我们这届（20级）开始改革，将计院原先的数逻、计组、体系、操作系统四门课合并成三门课，计算机系统一、二、三。信安作为小班，第一批开始试验课改，但是体验我个人感受非常的好。</p></li><li><p>信安大一下专业课特别难顶</p><ul><li>汇编语言，开给图灵和信安的专业课，会比普通通识多一些内容。小白的课，课虽然难又老，但是真的能收获很多东西，老师的讲课思维有点怪，可能和很多同学的学习方式冲突，但建议再难啃也要啃下来，多花时间，把作业好好做完，我自己后期直接摆了，导致学到东西不多，很后悔。对于图灵的xdxm们，我有个建议（但不一定要听），除了选汇编外，可以考虑旁听汇编或者选通识汇编，虽然不在培养方案里，但是学到知识才是关键，对之后计组或者计概会有很大帮助，汇编的作业甚至对整个人的锻炼都是很大的。</li><li>计算机系统一，第一届，确实一开始上来难度太大，老师也经验不足，但好在老师团队和助教团队都很好，加上我们小班制，反复迭代，加上对助教死缠烂打，学到了很多，我一开始学的云里雾里，不知道为什么要学这个，大概到后面流水线的时候，有一种顿悟的感觉，流水线的lab一定要好好做，做完了期末肯定不是问题。这门课也是我计算机真正的启蒙，给了我很大的正反馈，让我有信心继续学下去。</li><li>数理方面，我数学学的太差，因为一些原因，我还选了信安原理与数学基础（工信的课），我觉得这门课其实没必要，为啥信安不上离散+概统，反而合并起来，不过课程体验还是非常不错的，虽然最后qz老师讲high了还讲了很多随过的东西，导致我直接自闭。总之，xdxm们一定要好好学数学，物理就算了，没必要。</li><li>网安导（图灵的课），很感谢这课，机缘巧合，给了我和sxjgg一个机会跟着zbs去做点东西，最后还去打了全国大学生信息安全大赛，虽说未结果，但是学到了很多。对于图灵的xdxm们，这门课可以就当入门水一水，也可以借个机会做点想做的东西出来，大一下的编程课比较少（应该只有汇编），可以考虑平时多多自学，或者选些其他的课。</li></ul></li></ul><h3 id="大一暑假-迷茫和抉择">大一暑假 迷茫和抉择</h3><p>在过去的一年中，我慢慢感受到自己的综合能力比较突出，但是在专业能力上欠缺，自己也慢慢给自己下了套，一直给自己学不好计算机的心理暗示，加上学业上受大一下打击太大，开始选择性的逃避，比较荒废，只是整理了大一一年的东西之后没有学过新的东西，基本上都在忙其他的事情。暑假开始，我选择去做一些让我正反馈更多的事情，加入了一个ITP学长带的创业团队，目的很明确，希望为大二上的ITP选拔积累经验，后来项目因为种种原因黄了（但还是很感谢带我入门的zkb、lfx学长们，教会了我非常多），这才发现其实不应该拿经历来当做自己的挡箭牌，自己的真材实料太少，那个时候开始慢慢入门商科，看看书，看看文章，写点笔记，但更多也只是半壶水响叮当；八月心心念念的支教也因为疫情转为线上（没想到一年之后还是这样），不过很感谢支教这段经历，认识了很多新朋友，月牙湖一度是我水群的快乐源泉，也圆了我支教的梦；接着支教后，做了几期分享经验的视频，b站的号逐渐有了起色。</p><h3 id="大二上-和计算机和解">大二上 和计算机和解</h3><p>大二上学分36（包括军训的2学分），本身信安预制的课程压力就比较大（后来退了ljj的oop，实在不敢上，后来看起来是非常明智的选择），加上自己想把通识修完以及思政提前修掉马原（因为预感到大二下会非常难顶），就一下子又35+了。</p><p>在这里写点之前没有提及的，准备ITP的心路历程。ITP的报名表是一场马拉松，其中有几件事情对我帮助很大。第一件，我加入了学校的潮牌社团——不二潮，说来很有渊源，我之前是不二潮的常客，后来他们成立社团，开始纳新，我就报名了，面试的时候，和老蔡聊，他知道我正在报名ITP（不二潮是ITP孵化出来的项目，部分创始人是ITP的学长学姐），所以也聊到了ITP，他说：“大二大三是你的黄金时期，你现在是拿别人快速成长的这段时间去做一些和本专业无关的事情，要想清楚你加入不二潮以及ITP的目的。”我的回答是：“对于不二潮，我一直很想拥有属于自己的潮牌，加入不二潮可能是我唯一的一次机会，我想试试看。”但对ITP，我开始思考为什么报名ITP的原因以及我究竟想要什么，还有如何权衡好和本专业的关系？我脱口而出自己的答案，但是却没有好好想清楚。第二件，我去参加了未企和ASES的面试，结果是未企给了我一个承诺，ASES拒了我，虽然当时同行的面试者以及我自己都对我面试表现很满意，但现在看来，当时只会满嘴跑火车，这两件事情给我的影响很大，有几点启发</p><ul><li><p>你需要成为一个专家，一个极致的人，一个极客，而不是人云亦云</p></li><li><p>对于理工科同学来说，在未形成自己的技术/见解之前，加入任何这类的社团组织等，都只是浪费时间，增加一些无效的connection。（其实对金融类同学同理）</p></li></ul><p>慢慢开始我把重心重新放回到学业上，整体这个学期让我体验非常好，课程不算特别难，给予的正反馈很多，学到了很多，成长了很多，并且让我真正和计算机和解了，也是我大二上blog的标题。感兴趣的话可以看看之前的blog，在下文中会有提到。也感谢 <a href="https://csdiy.wiki/">https://csdiy.wiki/</a> ，那是自学梦的开始。</p><p>很庆幸的是在沟通技巧课上遇到了一群好朋友，很难想象，我们的群聊，到现在群消息也是时不时会炸起来，大家都是同一背景差不多的专业，在学业上也相互帮助相互督促，寒假和暑假的自学小队，每个期末的补天小队，感谢沟通技巧。</p><p>关于课程</p><ul><li>感兴趣的话可以看看之前写的blog <a href="https://ryanfcr.github.io/2022/01/15/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E5%86%AC/">https://ryanfcr.github.io/2022/01/15/大二秋冬/</a></li></ul><h3 id="大二下-最难的一段时间">大二下 最难的一段时间</h3><p>大二下有太多想讲的了，不知道从何开始讲起。</p><p>先说说学业吧，大二下学分36，加上了ITP的课程9学分。整体来说，是我进步最大，成长最快，学到最多的一个学期，但是也是我绩点最惨淡的一个学期，一方面原因是课业压力太大，自身发挥不佳，另一方面是很多门课自己不想卷了，没必要，把更多的时间花到自己想花的地方上去。尽管绩点惨淡，但是我收获了我宝贵的项目经验，miniCPU，minikernel，oopProject，minisql，华为眼镜开发等等。我觉得那是更重要的。</p><h4 id="密码学">密码学</h4><p>信安必修，我选的是张帆老师的，但不是特别推荐张帆，主要是讲课的原因，张帆老师自己都推荐我们去看看小白的课（×，但是张帆老师的助教我真的哭死，助教是真老师。我后来基本上全是看小白的智云，不过不选小白的课还没有看他智云的权限，所以还得借账号，不如直接选小白的课，四次作业自己认真写就好。这门课主要以密码学工程为主，关于密码学的原理知识不多，毕竟是计院的密码学，跨专业的同学如果对密码学感兴趣可以考虑一下数院的密码学或者国外的密码学。我在github上面上传了我的一些资料</p><ul><li><p>密码学考前复习是我考前手写的复习提纲</p></li><li><p>密码学笔记是我除去代码之后的笔记，代码是小白的，不太方便外传，整体笔记我记得有点太冗长了而且很乱，大家将就看看吧~</p></li></ul><p>这门课并不难，认真听小白课就能听懂，考试主要靠背和理解（×，考试占比60%，平时作业40%，这门课我期末考试错了一道很简单的ECC，导致绩点被拉了挺多的，有点可惜，但是这门课我还是有学到很多东西的。</p><h4 id="数据库系统">数据库系统</h4><p>信安选修，我选的是gyj老师的课，老师人挺好的，助教实在是无力吐槽。我基本上全是听sjl老师的课，能收获很多东西。对于课程，感觉就是教的东西太多太杂了，minisql的比重可以再高一点，考试比重低一点。今年期末考试改了，不再是之前的八股文，98上有回忆卷，最后期末我个人感觉非常好，结果比较差，最后绩点就比较难看。数据库的资料和笔记也整理在github了，想修这门课的xdxm们，多看看sjl老师的智云会有很大的帮助，珍惜minisql这个锻炼自己的project，好好做。以及考试会考的比较细，只是抄在cheat sheet上帮助不大，最重要的是理解。</p><h4 id="普物实验一">普物实验一</h4><p>图灵信安必修，普物实验一是我刚转进来的时候冲突没有选上的，这个学期补修。我之前已经把普物实验二和普物一二都修完了，这门课对于我来说，我希望以最快的速度达到90%即可，基本上没有花特别多的时间，最后绩点也不是特别好看，但是对于我来说是正确的取舍，没必要在这课花太多时间瞎卷。资料也相应的放在后面了~对于图灵的xdxm们，我觉得这门课就以最快的速度完成任务就好，不要花太多没必要的时间，可以趁机学一学matlab/excel。</p><p>在github上面放了一些笔记、课本、历年卷，仅供参考~</p><h4 id="计算机系统三">计算机系统三</h4><p>信安必修，系统三真的是我这个学期的意难平。系统三承接系统一和二，主要讲了体系和操作系统的后半部分，实验部分挺难的，但对我的锻炼是显而易见的，三个学期学下来，收获非常大，是改变我大学生涯的一门贯通课程，最后结课还有纪念项链，嘿嘿！</p><p>但整体来看，自己在这门课上花的时间还是太少了，一方面是自己时间太紧张了，这个学期太忙了，另一方面是自己对OS、体系并不感冒，就没有花特别多的精力。</p><p>意难平的原因是感觉没有给系统课一个完美的ending，最后期末考没来得及复习完就上了考场，考试相比于之前系统一、二，难度有增加，导致期末考太差，最后绩点没有那么好看，有点可惜。</p><h4 id="软件安全">软件安全</h4><p>信安必修，软件安全aka黑客入门课，周亚金老师和助教们我真的哭死，课程内容讲了很多，但是作业难度降下来了，主要是打pwn，没有讲heap。周老师上课讲的有一点浮，没有什么实操，我基本上全是看B站或者youtube台大的pwn课的以及看ctf-wiki和语雀笔记，对应的网站都放在github笔记上了。这门课我个人感觉学到了很多，也是这个学期给我成就感最多的一门课。PS，这门课给分非常的好，一共四次作业＋final，只要你做出来了，就是满分。</p><h4 id="面向对象程序设计">面向对象程序设计</h4><p>信安必修，但是预置是大二上ljj老师的班，我的建议是大一下学或者大二下学，原因不多说了。我的老师是翁恺，于是OOP这门课被wk老师重新命名，又称语言、地理小课堂，这是我第二门wk老师的课，wk老师讲的实在是太好了，不过课堂很多时间都在闲聊hhh，不过不得不佩服wk老师的知识面，奇奇怪怪的知识增加了。这门课难度不是特别大，课可以听听wk老师的，比较坑的就是期末考试，期末考试考纲感觉没有定，每个老师教的东西也不太一样，wk老师讲的很多比较难的，都没有考，有些考点甚至有些老师没有讲，hhh，还有期末考试有些老师出的题目，感觉真的不是在考OOP，我真的无语，给你一个程序，问会输出什么的题目，有些题就特别逆天，比如少个右括号，需要我们自己补一个，1.0cout出来是1，boolean的函数输出的是1和0，而不是true和false，然后print出来的东西一推全角和半角的空格、感叹号以及不知道是什么的组织在一起的东西，还有程序题没有打全的，搞这些就完全没必要。</p><p>不过说回来，真oop还得是数据库的minisql</p><ul><li><p>github仓库里放了笔记，课件和历年卷</p></li><li><p>这里放一些我们沟通技巧群友集体复习时候的错题合集<a href="https://k5ms77k0o1.feishu.cn/docs/doccnXA6djf8J9rFktrYIMeAKod">OOP错题合集</a></p></li></ul><h4 id="数据安全与隐私保护">数据安全与隐私保护</h4><p>信安必修。这课workload比较小，只需要一篇文献综述和pre，蛮多同学一节课都没有听，夏学期一周两次早八也比较阴间，不点名。给分莫名其妙比较差，听说之前很好。</p><h4 id="高级数据结构与算法分析">高级数据结构与算法分析</h4><p>信安必修，这门课是我第一次觉得斩杀线离我如此之近的一门课。我选的老师是yds老师，虽然一开始有被“ds，ads，yds”但传说吓到，但是yds老师真的很负责任，而且很真诚，每节课开始都会和大家鞠个躬说感谢大家来听我上课，尽管老师确实讲课没有那么清楚，但是能够感受到老师对于他自己领域的认真。我平时上课都是听yy老师的，期末最后才发现了myc老师（myc老师是第一次开ads的课，我一开始听说他给分求是就直接选择了yds，呜呜），期末补天是看myc老师的智云，加上最后死缠烂打yds和myc老师。最后补天效果非常的好，也获得了令人意外的成绩，感谢诸位老师~</p><p>推荐学习路径</p><ul><li><p>平时看myc老师的智云，可以直接选myc老师，老师是手写课件，手动推导，只要你跟着老师一步一步来，一定会非常清楚。同时我觉得手写课件非常适合智云。</p></li><li><p>project多做做，锻炼锻炼，每周按yy老师的花1.5小时看看算法书，巩固一下</p></li><li><p>期末多刷历年卷，数据结构必须要每道题都搞明白，算法遇见特别难的题目就放过，稳住基本盘。编程题也需要有准备，按照这个趋势，可能之后也会考数据结构的编程题。</p></li></ul><p>github里放了历年卷和笔记，推荐课件自己下，应该课件每年都有改动（因为一些错误，myc老师好像找了不少错误）</p><ul><li>这里放一个我们沟通技巧群友集体复习时候的错题集<a href="https://k5ms77k0o1.feishu.cn/docx/doxcnom9S5lSs27pxlQ3niuskOb">ADS期末复习</a></li></ul><h4 id="NUS-Summer-Camp">NUS Summer Camp</h4><p>图灵班的短学期，和NUS以及港城大的合作项目，主题是HCI，具体就是我们在华为提供的智能眼镜上做开发，我们这边30位代码手，线上还有十余位designer，一起合作从idea到落地做一些在智能眼镜上的应用，是我人生中的第一场hackathon，体验非常好，很享受从脑暴到落地完成的感觉。希望未来能多多参加一些hackathon。</p><h4 id="西方音乐简史">西方音乐简史</h4><p>选的是陈列老师，老师很好，选这门课也是出于对西方音乐很感兴趣，上课是一周内最放松的时候，一开始每周都会记笔记，后来老师因为疫情困在上海，体验有一点点差（有点可惜，因为有些音乐现场不能听）</p><h4 id="高尔夫球">高尔夫球</h4><p>选的是刘剑老师，老师很健谈，我摸鱼的时候就总和老师瞎扯，聊聊投资创业啥的（×</p><p>推荐选不上其他老师的可以选选刘剑老师</p><p>还有四门课就放在后面聊聊吧，接下来聊聊ITP。</p><p>这个学期开始上ITP的课程，我四门课都上了，也和不少ITP的朋友聊过这个学期的体验，整体给我的体验从及格到优秀。</p><p>先说说课程，ITP的课程压力挺大的，这个学期上四门，管理学（春夏），经济学（春夏），团队沟通与领导力（简称团沟，春），创业战略（夏），占据了周日一天。秋学期每门课压力都挺大的，管理学和团沟基本上一周一次pre，大家上课也提不起兴趣，我自己就把课当周日的放松，听听课记点有意思的点，一边做一些自己的事情。但是慢慢发现自己没有什么进步，课堂上的内容也没有自己的思考，后来转变了方式，开始认真听课+手头只能做不用动脑子的事情，脑子活跃在课堂上，感觉效果还可以，整个学期四门课，除了经济学我基本上后面没有怎么听，其他课都收获很大，也给我带来了很多思考。经济学最后期末补天的时候学到了很多。</p><p>对于ITP，我现在非常满意，抛开课程不谈，有不少值得深交的同学们，收获了很多好朋友，整个班级的氛围也是如我期待的那样，这就够了，对我来说。对于专业和ITP的平衡，ITP是给未来打基础，但是首先自己得先做出一些东西，所以自己这个学期更多的时间还是花在了自己感兴趣的领域和专业上，不少ITP的同学也和我计划的一样，蛮多真正在做事情的人，大家能力都很强，和大家交流非常开心，没有那么多没有能力没有思考只会connection只会追求title只会复制粘贴的人（请勿对号入座）。同时遇到了很多很可爱的老师和助教，感谢你们。</p><h4 id="管理学">管理学</h4><p>管理学给我的体验非常的好，但是组队需要组一个好一点的队，我们组员大家都非常靠谱，所以整体体验非常好。就是这门课workload有点太大了，不过上课形式包括工作量老师助教们也在和我们积极沟通，能够看到做出的改变，上课形式我真的很喜欢，有玩过不少剧本杀游戏，还有户外去庄园上课，注意，这不是出游！哈哈哈哈哈希望管理学越来越好！</p><h4 id="团沟">团沟</h4><p>团沟体验非常好，周帆老师很博学，课上会聊很多很多话题，对于理工科的我来说很新奇，有一种博雅通识的感觉，作业是以小组为单位，workload很大，基本上每周一次展示，我们组还只有四个人，就有点难顶，但是小而精也挺好的，难顶指本身workload大，而非团队缺人手，反而感觉四个人更方便。无期末考试，除平时的小组作业外还有最后一次个人作业。给分不错，学到了很多。</p><h4 id="创业战略">创业战略</h4><p>创业战略给我的启发特别大，无论是魏江老师还是小窦老师，不少金句都让人深思，创业战略的小组组员们也很给力，感觉我们一起完成了一次非常完美的BP，体验感非常好！</p><h4 id="经济学">经济学</h4><p>经济学内容有点太多了，期末考试需要好好复习，单单看曼昆的书就可以学到不少知识。曼昆的书写的确实好，简单易懂入门，适合我这种门外汉。郭老师讲的可能不适合大部分的同学，自学的话就只看曼昆的书够了，考试占比70%，一定要好好考试，注意答题的时候要踩点，不踩点就没有分数（都是泪）</p><p>回答一些外界对ITP的困惑</p><ul><li><p>ITP的课会不会拉绩点？我四门课，管理学4.8，团沟、创业战略4.5，经济学2.7，我个人觉得肯定会拉绩点，且占据掉你的时间，所以需要做权衡取舍（机会成本！经济学考点）</p></li><li><p>可不可以只修几门课？其实每门课都有收获，当然修不修都看你，只是不修会被退班</p></li><li><p>ITP是不是搞创赛的？还是得看人，我的视角仅提供理工科同学的一个视角，我觉得理工科同学最好用自己的东西去打创赛，或者说，最好别打创赛，不要以赛为目的，以奖为目标，建议以打磨好项目为目的，以成长为目标。我自己学期初有一次很好的机会，跟着张kj老师一起做一个项目，可惜最后我们产品没有特别好，技术也没有进一步的开展，就告一段落了，是一次不错的体验，对团队的大家有所抱歉，最后的结果并没有特别理想。</p></li></ul><p>聊聊自己的方向，故事的真正开始应该是在大二下，今年三月，我在某家校友企业公司作产品运营实习生，开始正式迈入这个crypto行业。最后包括我自己的创赛，科研的方向我也向导师申请换到和当前方向一致，我很热爱目前自己的方向，Blockchain/web3.0/crypto/nft，感谢Skywu带我入门，虽然现在自己还是一个半吊子，总是被问住，不懂的地方还有很多。这个暑假，公司还允许我这个闲人不断的换岗，尝试不同职位，很感谢公司给我不断学习的机会。</p><p>聊聊自己这个学期的变化和感悟。其实整个学期性格变化很大，也发生了很多事情。一开始大概在四月份发现自己慢慢有点不自信，少了一些拼劲，好在后来好了很多。还有就是自己慢慢变得不那么刻薄，之前的自己非常刻薄hhh，属于是宽以律己，严以待人，但现在多向内求，反求诸己，先想想自己有没有这些问题，先对自己严要求。除此之外，和上学期一样，有几点感悟（有一些是twttier上看到自己比较有感悟的）</p><ul><li><p>Learning by doing，少踌躇，多行动，别犹豫</p></li><li><p>黄金圈，多想想why</p></li><li><p>拒绝惰性，多思考，做深度的阅读和写作；拒绝别人二次加工的东西，尽可能找到新闻的源头，不要形成依赖，停止思考</p></li><li><p>学会搜索</p></li><li><p>很多人会错误的感觉，自己在什么地方看到了别人的观点，自己同意了。就认为自己就是那样的，自己知道那个观点是怎么来的，自己甚至能证明能够真正的理解它。大错特错，你只是在自我安慰你自己的焦虑</p></li><li><p>浅尝辄止，很害人。没事多问问自己真的懂了吗？不懂别瞎说，对自己的话负责，别没几句就被问住了</p></li><li><p>静下心来把自己不明白的事情看清楚，永远没有捷径</p></li><li><p>忙是无能的表现，保持闲暇</p></li><li><p>最重要的能力是一种创造的能力，他可以是编程，可以是设计</p></li></ul><p>最后聊聊为什么要起这个标题，“我在信安的这两年”，原因很简单，我的信安生涯“可能”到此结束了。虽说我选择信安的理由过于随便，但是我很喜欢这个专业，我也很感谢我当时的选择，无论是选择信安还是选择图灵，没有这些选择就没有今天的我，很感谢信安让我遇到了信安这帮人，kg，zr学姐……信安优秀的课程和老师助教们给了我很大的帮助，让我成长了很多，我也从中找到了自己感兴趣的方向和收留我的导师，永远爱信安的这帮人。</p><p>对于信安培养方案，我个人有一些拙见</p><ul><li><p>c小和c大合并为一门并在大一上全部结束</p></li><li><p>oop放到大一下来上</p></li><li><p>大一下的课程workload可以再降一些，一下子可能难度上来的太大，给大家造成不可磨灭的心理阴影，被此摧毁的人每一届都有不少</p></li><li><p>物理难度降低</p></li><li><p>离散和概统分开上</p></li></ul><p>反省过去的两年，比较遗憾的有几点吧</p><ul><li><p>自己的行动力太差了，总是想的很多，做的很少，希望未来少说多做</p></li><li><p>我的很多意识比较超前，但是都因自己没有良好的基础而丧失一些机会，希望未来自己更沉得下心来多做点自己想做的</p></li><li><p>有些课没有学好是一大遗憾，但感觉自己还是受课程的束缚有点大，希望未来减少内耗，少内卷，多做点有意思的东西出来</p></li></ul><p>说说为什么可能要转专业？</p><p>不能说是信安的问题，但也确实。说一说信安集体的问题，信安人比较少，保研名额就少，大佬也比较多，加上出国会因为方向被check（注意，不是rej），大部分同学选择出国的意愿也比较低，基本上保研可能需要4.5+的绩点，但想要达到这个均绩需要付出很多不必要的内耗，卷到最后保研了，其实自己也浪费了黄金的学习时间，个人认为不划算。图灵内部，图灵的保研之前引起了98一众的热议，信安更是比较特别，我们这届的情况比较复杂，由于每个专业按每个专业来算，信安目前只有2个人，按照保研比例，最多只能一个人。</p><p>不过我还好，毕竟是转进来，一开始也知道保研竞争的激烈，也知道我们进来其实是动了本来属于大家的保研名额，所以刚进来就开始准备出国了。现在转计科，也是希望未来出国的时候能够选择面更广一点，但是不是说信安不方便出国，据我目前了解到的信息是，安全方向申请美国会每年被check一下，但是不是rej，cs申请一些非安全的方向不会被check，大概自己列了一些利弊</p><p>CS</p><ul><li><p>Pro：申请方向更大，排名更好看，名气更大；是一个机会多尝试一些别的课，以及补一下自己之前比较差的几门课；退一步路说，保研也有机会</p></li><li><p>Con：大三cs课比较多，可能会多占据一部分的科研时间，但是差距不是特别大，因为信安培养方案完全覆盖cs，我没有什么课要补的</p></li></ul><p>IS</p><ul><li><p>Pro：大三时间充裕，可以好好做科研</p></li><li><p>Con：出国可能受阻</p></li></ul><p>不过目前还有两个月容我纠结，如果想来找我聊的同学也可以来劝劝我哈哈哈哈哈 最后就说那么多了，感谢大家能够看到这里，感谢您的时间~</p>]]></content>
      
      
      <categories>
          
          <category> 2022暑假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解计算机系统CSAPP》（二）</title>
      <link href="/2022/01/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/01/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>《深入理解计算机系统CSAPP》（二）</h1><p>  在Github上找到这样两个项目，相信对自学CSAPP的同学会有帮助</p><ul><li><p><a href="https://github.com/EugeneLiu/translationCSAPP">EugeneLiu/translationCSAPP: 为 CSAPP 视频课程提供字幕，翻译 PPT，Lab。 (github.com)</a></p></li><li><p><a href="https://github.com/Exely/CSAPP-Labs">Exely/CSAPP-Labs: Solutions and Notes for Labs of Computer Systems: A Programmer’s Perspective 3rd Editon // 《深入理解计算机系统》第三版的实验文件、解答与笔记 (github.com)</a></p></li></ul><p>  B站视频链接👇</p><p><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=1">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频_哔哩哔哩_bilibili</a></p><p>  笔记主要由书上章节分类，而非课程视频的分集。</p><p>  笔记一部分参考知乎博主<a href="https://www.zhihu.com/column/c_1212802114247979008">CSAPP+SICP - 知乎 (zhihu.com)</a>以及搬运书上原话。</p><h2 id="Lecture-03-Machine-Level-Programming📝">Lecture 03 Machine Level Programming📝</h2><h3 id="3-1-History-of-Intel-Processors-and-architectures">3.1 History of Intel Processors and architectures</h3><ul><li>使用机器语言可以获得<ul><li>PC</li><li>Register</li><li>Condition Codes</li></ul></li><li>Intel的处理器系列被称为x86，x86对于英特尔处理器来说是一个口头的称谓，原因是第一个芯片被称为8086，然后他们跳过了81，随后推出了8286、8386等等，共同点都有86，所以人们称它位x86。<ul><li>8086，8086是第一个16位微处理器，它出现在1978年。</li><li>i386</li><li>……向后兼容</li></ul></li><li>CISC 复杂指令集 vc RISC 精简指令集（ARM，Risc-v）</li><li>IA32，x86-64</li><li>竞争对手AMD<ul><li>率先突破x86-64</li></ul></li></ul><h3 id="3-2-C，assembly，machine-code">3.2 C，assembly，machine code</h3><ul><li><p>ARM：Acorn RISC Machine</p><ul><li>功耗更低，更简单</li></ul></li><li><p>一些定义的明确</p><ul><li>ISA：指令集架构，机器级程序的格式和行为，定义了处理器状态、指令的格式，以及每条指令对状态的影响。<ul><li>Intel：x86，IA32</li><li>ARM：很多手机上的</li></ul></li><li>微架构microarchitecture是ISA这个架构的实现</li></ul></li><li><p>对于机器级编译两层抽象很重要</p><ul><li>ISA</li><li>虚拟内存</li></ul></li><li><p>将C代码翻译为目标代码的过程：</p><ol><li><strong>预处理器</strong>会扩展源代码，插入所有用<code>#include</code>指令的文件，扩展所有用<code>#define</code>声明指定的宏。</li><li><strong>编译器</strong>基于编程语言的规则、目标机器的指令集和操作系统的惯例，会将源代码转换为汇编代码作为输出，给出程序的每一条指令。</li><li><strong>汇编器</strong>将汇编代码转化为二进制目标代码文件，它是机器代码的一种形式，包含了所有指令的二进制表示，但是还没有填入全局值的地址。</li><li><strong>链接器</strong>将目标代码文件和实现库函数的代码合并，产生最终可执行代码文件。</li></ol><ul><li>.c——&gt;.s——&gt;.o——&gt;p</li><li>编译器——&gt;汇编器——&gt;链接器</li><li>-og优化</li><li>汇编代码中以“.”开头的行都是指导汇编器和链接器工作的伪代码，可以忽略</li><li>变量所有名称在汇编、机器代码级别完全丢失了，变成了寄存器和内存中的某个位置。</li></ul></li><li><p><strong>编译器</strong></p></li></ul><p> <code>gcc - Og -S xx.c </code>得到<code>xx.s </code></p><ul><li><strong>汇编器</strong></li></ul><p> <code>gcc -Og -c xx.c</code>进行编译和汇编，生成二进制文件<code>xx.o</code>，可以通过反汇编器，<code>objdump -d xx.o</code> ，将可执行文件转换成汇编代码</p><p> 发现</p><ol><li>每个指令需要的字节数不同，有的两个，有的三个……</li><li>每个指令有自己对应的编码</li><li>反汇编得到的汇编代码和直接生成的有差异</li></ol><p> 同样可以使用<code>gdb</code>然后输入<code>disassemble</code>来反汇编代码</p><ul><li><strong>链接器</strong></li></ul><p> 使用链接器将目标代码文件转化为可执行代码。要求：目标代码文件中必须含有一个<code>main</code>函数，作为程序的入口。按<strong>书上</strong>的指令：<code>gcc -Og -o prog main.c mstore.c</code>，链接了main.c和mstore.c，生成可执行文件prog。</p><p> 可以发现和汇编器生成的区别有：</p><ol><li>链接器将代码移到了新的地址范围内。</li><li>链接器补充了调用函数<code>mult2</code>需要使用的地址。</li><li>多了两行<code>nop</code>，可以使得函数代码变成16字节，更好放置下一个代码。</li></ol><ul><li>数据格式<ul><li>不区分符号和无符号的存储方式</li><li>指针也是以数字的形式存储的</li><li>b 字节 8</li><li>w 字 16</li><li>l 双字 32</li><li>q 四字 64</li><li>浮点数是4字节、8字节、10字节<ul><li>浮点数以和整型数据完全不同的方式进行处理，并且使用完全不同的寄存器组。</li></ul></li><li>数据结构这些是编译器实现的</li></ul></li><li>每条指令能做的事情比较有限</li></ul><h3 id="3-3-Assembly-Basics：Registers，operands，move">3.3 Assembly Basics：Registers，operands，move</h3><ul><li>一个x86-64的CPU中包含16个存储64位值的通用目的寄存器，可以用来存储整数数据和指针。有些寄存器有<strong>特殊用途</strong>，是约定俗成的<ul><li>sp 栈指针</li><li>ecx count</li><li>e<strong>b</strong>c —— base等等 但是其实我们已经不需要知道了</li><li>%r 64位</li><li>%e 低32位</li><li>可以对1、2、4、8字节进行操作</li></ul></li></ul><h4 id="3-3-1-操作数指示符">3.3.1 操作数指示符</h4><p> 大多数指令由一个或多个操作数（Operand），指示出一个操作中要使用的元数据值，以及放置结果的目的位置。</p><p> 操作数包含三种类型：</p><ul><li>**立即数（Immediate）：**用来表示常数值，书写格式是在<code>$</code>后面跟一个标准C表示法表示的整数，比如<code>$-577</code></li><li>**寄存器（Register）：**表示某个寄存器的内容。</li><li>**内存引用：**它会根据计算出来的地址访问某个内存位置。有不同的寻址模式，最常用的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi><mi>e</mi><mi>m</mi><mo stretchy="false">[</mo><mi>R</mi><mi>e</mi><mi>g</mi><mo stretchy="false">[</mo><mi>R</mi><mi>b</mi><mo stretchy="false">]</mo><mo>+</mo><mi>S</mi><mo>∗</mo><mi>R</mi><mi>e</mi><mi>g</mi><mo stretchy="false">[</mo><mi>R</mi><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>D</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Imm(r_b,r_i,s) = Mem[Reg[Rb]+S*Reg[Ri]+D]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">]</span></span></span></span> ，其中，<strong>要求寄存器大小都是64位的</strong>，才能完整索引整个虚拟内存空间，并且不能使用<code>%rsp</code>。常用括号来简化。</li></ul><p> 源操作数是一个立即数，可以直接是一个立即数或者保存在寄存器或内存里，目标操作数是一个位置，可以是寄存器或内存</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203153547387.png" alt="image-20220203153547387"></p><h4 id="3-3-2-Mov">3.3.2 Mov</h4><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203153700360.png" alt="image-20220203153700360"></p><p> <strong>注意</strong>：</p><ul><li><p>两个操作数不能同时为<strong>内存</strong>地址。如果要在两个内存位置传输数据，必须用一个寄存器进行中转。</p></li><li><p>使用到的寄存器大小一定要和指令最后一个字符指定的大小匹配。</p></li><li><p><code>movl</code>以寄存器为目的时，会将寄存器的高位4字节置0。</p><ul><li>x86-64的惯例：任何为寄存器生成32位值的指令都会把该寄存器的高位部分置0</li></ul></li><li><p>如果用<code>movq</code>来传输立即数时，该立即数只能表示为32位补码，然后扩展到64位的值。而<code>movabsq</code>能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。</p></li><li><p>一共五种组合</p><p>a. I - R</p><p>b. I - M</p><p>c. R - R</p><p>d. R - M</p><p>e. M - R</p></li></ul><p>寄存器可以作为临时存储的工具</p><h5 id="源寄存器小于目的寄存器">源寄存器小于目的寄存器</h5><p> 在将较小的源值复制到较大的目的时，提供两个类<code>MOVZ</code>和<code>MOVS</code>。<code>MOVZ</code>是将目的中剩余的字节填充0，<code>MOVS</code>是将目的剩余的字节填充符号位的值。它们每条指令后面都有两个字符，分别表示源大小和目的大小。</p><ul><li>不存在<code>movzlq</code>，可以直接使用<code>movl</code>。因为当使用<code>movl</code>传输数据到32位目的寄存器中时， 会自动将目的寄存器的高位4字节置零。</li><li><code>cltq</code>没有操作数，总是以<code>%eax</code>作为源寄存器，以<code>%rax</code>作为目的寄存器，等价于<code>movslq %eax,%rax</code>。</li></ul><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203153833268.png" alt="image-20220203153833268"></p><h5 id="源寄存器大于目的寄存器">源寄存器大于目的寄存器</h5><ul><li>强制类型转换</li><li>先保存到寄存器中，再保存到内存</li></ul><p>综上：</p><ol><li>两个指针之间进行传输，由于是直接对内存进行操作的，所以需要先经过一个寄存器。</li><li>小的数据类型转换到大的数据类型，是根据前面的数据类型决定是<code>MOVZ</code>还是<code>MOVS</code>。</li><li>大的数据类型转换到小的数据类型时，先将其保存得到寄存器中，再将部分保存到内存中。</li></ol><h4 id="3-3-3-压入和弹出栈数据">3.3.3 压入和弹出栈数据</h4><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203154627151.png" alt="image-20220203154627151"></p><blockquote><ol><li>栈指针%rsp保存这栈顶元素的地址</li><li>我们的栈是倒过来画的，因而栈“顶”在底部</li><li>先进行算术操作再压或者读</li><li>当pop的时候，并没有抹去那个元素，只是栈指针变动，栈顶元素仍然保留在内存中</li></ol></blockquote><h3 id="3-4-Arithmetic-logical-operations">3.4 Arithmetic &amp; logical operations</h3><p> 以下列出了x86-64中的一些算数和逻辑操作，除了<code>leaq</code>以外，其他都有对不同大小数据的指令。</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220124230420590.png" alt="image-20220124230420590"></p><ul><li><p><code>leaq S D</code>是将S计算出的地址付给寄存器D。通常会被用来执行<strong>加法和有限形式的乘法</strong>。比如对于比例变址寻址$Imm(r_b,r_i,s) $  ，得到的地址会是  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><msub><mi>r</mi><mi>b</mi></msub><mo>+</mo><msub><mi>r</mi><mi>i</mi></msub><mo>∗</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">Imm+r_b+r_i*s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></p><blockquote><p>目的操作数只能是寄存器。</p></blockquote></li><li><p>一元操作符中，操作数可以是寄存器也可以是内存地址。既是源又是目的。</p></li><li><p>二元操作符中，第一个操作数可以是立即数、寄存器或内存地址；第二个操作数可以是寄存器或内存地址。</p></li><li><p>移位操作中，第一个操作数可以是立即数或放在单字节寄存器<code>%cl</code>(rcx的low八位)中，第二个操作数可以是寄存器或内存位置。</p><blockquote><p>如果我们对w位的数据进行移位，则只考虑<code>%cl</code>中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>w</mi></mrow><annotation encoding="application/x-tex">log_{2}{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span>位，保证不会将数据移出边界。 比如<code>salb</code>只会考虑寄存器低3位的值（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>8</mn></mrow><annotation encoding="application/x-tex">log_{2}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">8</span></span></span></span></span>），<code>salw</code>只会考虑寄存器低4位的值（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>16</mn></mrow><annotation encoding="application/x-tex">log_{2}{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">1</span><span class="mord">6</span></span></span></span></span>），以此类推。</p></blockquote></li><li><p>128位乘法<img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203160519869.png" alt="image-20220203160519869"></p><ul><li>将占用<code>%rax</code>的数据<code>mov</code>到别的寄存器中</li><li>将其中一个乘数<code>mov</code>到<code>%rax</code>中</li><li>如果是有符号乘法，就使用<code>imul</code>，如果是无符号乘法，就是用<code>mul</code></li><li>对结果进行保存，比如保存在<code>(%rdi)</code>中：如果是在小端机器中，则为<code>movq %rax, (%rdi)</code>，<code>movq %rdx, 8(%rdi)</code>；如果是大端机器中，则为<code>movq %rax, 8(%rdi)</code>，<code>movq %rdx, (%rdi)</code>。</li></ul></li><li><p>除法</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203160906931.png" alt="image-20220203160906931"></p><blockquote><p>书上的图有一些错误，应该为rax存储商，rdx存储余数</p></blockquote><p>其中<code>R[%rdx]:R[%rax]</code>表示将两个寄存器的值拼接起来作为一个数，其中寄存器<code>%rdx</code>是高八字节，<code>%rax</code>是低八字节。它这里只有一个操作数表示除数，而被除数保存在<code>%rax</code>和<code>%rdx</code>中。</p><p><strong>有符号数除法：</strong></p><ol><li>将占用<code>%rax</code>和<code>%rdx</code>的数据<code>mov</code>到别的寄存器中</li><li>将被除数中的64位<code>mov</code>到<code>%rax</code>中</li><li>如果被除数是64位的，则要用<code>cqto</code>根据<code>%rax</code>中的最高有效位对<code>%rdx</code>进行符号扩展；如果被除数是128位的，就将剩下的64位<code>mov</code>到<code>%rdx</code>中</li><li>使用<code>idiv</code>进行计算。</li></ol><p><strong>无符号数除法：</strong></p><ol><li>将占用<code>%rax</code>和<code>%rdx</code>的数据<code>mov</code>到别的寄存器中</li><li>将被除数中的64位<code>mov</code>到<code>%rax</code>中</li><li>如果被除数是64位的，则使用<code>xorq %rdx, %rdx</code>将高64位置零；如果被除数是128位的，就将剩下的64位<code>mov</code>到<code>%rdx</code>中</li><li>使用<code>div</code>进行计算。</li></ol></li></ul><blockquote><ol><li>以上操作除了右移以外，在无符号数和补码间都是通用的，也体现了补码的优势。</li><li>可以使用<code>xorl %edx, %edx</code>来对寄存器<code>%rdx</code>置零。</li></ol></blockquote><h3 id="3-5-Control">3.5 Control</h3><h4 id="3-5-1-Condition-codes条件码">3.5.1 Condition codes条件码</h4><p>除了寄存器，CPU还维护一些条件码寄存器</p><ul><li>CF（Carry），用于检查无符号数的溢出</li><li>ZF（Zero），判断最近的操作结果是否是0</li><li>SF（Sign），判断符号</li><li>OF（Overflow），判断有符号的溢出</li></ul><blockquote><ol><li><p>Lea不会改变任何条件码</p></li><li><p>逻辑操作的CF和OF会设置成0</p></li><li><p>移位操作CF会被设置为最后一根被移出的位，OF = 0</p></li><li><p>INC和DEC会设置OF和ZF，不会改变CF</p></li></ol></blockquote><p>x86-64提供了另外两类指令，<strong>只会设置条件码而不会改变目的寄存器</strong>：</p><ul><li><p><code>CMP S1, S2</code>：用来比较<code>S1</code>和<code>S2</code>，根据<code>S2-S1</code>的结果来设置条件码。主要用来比较两个数的大小。</p><blockquote><p>注意顺序</p></blockquote></li><li><p><code>TEST S1, S2</code>：用来测试<code>S1</code>和<code>S2</code>，根据<code>S1 &amp; S2</code>的结果来设置条件码。可以将一个操作数作为掩码，用来指示哪些位用来测试。比如<code>testq %rax, %rax</code>就可以检查<code>%rax</code>是正数、负数还是0。</p><blockquote><p>test主要是用一个操作数</p></blockquote></li></ul><p>除此之外还有一些set指令，可以改变寄存器的值</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203170737152.png" alt="image-20220203170737152"></p><p>这里的目的操作数是<strong>低位单字节寄存器</strong>，或者一个字节的内存位置。如果要得到32位或64位结果，我们可以使用<code>MOVZ</code>对其进行传输。</p><p>**注意：**这里无符号数和补码的条件码组合不同，所以需要使用不同的<code>SET</code>指令，所以可以通过<code>SET</code>指令来判断所操作的数是无符号的还是补码的。</p><p>所以常见的<strong>使用顺序</strong>为：</p><ol><li>使用<code>CMP</code>进行比较或<code>TEST</code>进行测试，来设置条件码。</li><li>根据条件码组合或者<code>SET</code>将结果保存在单字节寄存器中。</li><li>使用<code>movbl</code>将结果保存在32位寄存器中，并且会自动设置高4字节为0。</li></ol><h4 id="3-5-2-Conditional-branches">3.5.2 Conditional branches</h4><p>跳转指令根据跳转条件主要分为两种</p><ul><li>无条件跳转</li><li>条件跳转：和条件码有关</li></ul><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203211633965.png" alt="image-20220203211633965"></p><p>根据跳转目标的方式分成</p><ul><li>直接跳转：用标号</li><li>间接跳转：用寄存器或者内存，需要加个<code>*</code>，比如<code>jmp *%rax</code>就是跳转到寄存器<code>%rax</code>中保存的地址；<code>jmp *(%rax)</code>就是跳转到内存地址<code>(%rax)</code>中保存的地址。</li></ul><blockquote><p>条件跳转只能是直接跳转。</p></blockquote><p>对于直接跳转的跳转目标的编码，有<strong>两种编码方式：</strong></p><ul><li>**PC相对的（PC-relative）：**跳转目标地址减去跳转指令下一条指令的地址的差。编码长度可以为1、2或4字节。</li><li>**绝对地址：**用4字节直接给定目标地址。</li></ul><h5 id="conditional-jump">conditional jump</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">  proc1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  proc2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="conditional-move">conditional move</h5><p>条件控制可能很低效。</p><p>现代处理器运用<strong>流水线</strong>，在处理<strong>条件冒险</strong>的时候采用<strong>分支预测</strong>，当用条件控制的话，存在预测错误导致的性能下滑。（运用了一些流水线的专有名词，详细可看p146）</p><blockquote><p>分支预测处罚计算：预测错误概率为p，预测正确时代码执行时间为TOK，而预测错误的处罚为TMP。则执行代码的平均时间为TAVG§=(13-p)TOK+p(TOK+TMP)=TOK+pTMP，所以TMP=(TAVG§-TOK)/p。</p></blockquote><p>而用<strong>条件传送</strong>来实现条件分支，不会先判断跳转，而是先将两个分支的结果进行计算，将结果分别保存在两个寄存器中，然后再通过**条件传送指令<code>CMOV</code>**将正确结果传送到输出的寄存器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">  movq %rsi, %rax</span><br><span class="line">  subq %rdi, %rax  //y-x</span><br><span class="line">  movq %rdi, %rdx</span><br><span class="line">  subq %rsi, %rdx  //x-y</span><br><span class="line">  cmpq %rsi, %rdi</span><br><span class="line">  cmovge %rdx, %rax</span><br><span class="line">  ret </span><br></pre></td></tr></table></figure><p>这里会直接将两个分支的计算结果<code>x-y</code>和<code>y-x</code>分别保存在寄存器<code>%rdx</code>和<code>%rax</code>中，然后最后通过<code>cmovge</code>判断如果<code>x&gt;y</code>就将<code>x-y</code>的结果保存在<code>%rax</code>。</p><p>x86-64上提供了一些<strong>条件传送指令<code>CMOV</code></strong>，只有在满足条件时，才会将源数据传送到目的中，如下图所示，其中源值可以从寄存器也可以从内存地址获取，而目的只能是寄存器。并且这里<strong>不支持单字节</strong>。</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203214911679.png" alt="image-20220203214911679"></p><p>条件传送有局限性：</p><ol><li><p>某个分支可能会报错。比如对于指针<code>xp</code>，有个条件分支为<code>xp? *xp:0</code>，如果使用条件传送来实现，就会先运行<code>*xp</code>，如果该指针不存在，就会报错。</p></li><li><p>分支需要大量计算</p></li><li><p>分支会改变其他的值</p></li></ol><blockquote><p>只有当两个执行语句很简单时，才会使用条件传送来实现条件分支。而且当两个语句很简单时，gcc会自动优化选择条件传送。</p></blockquote><h4 id="3-5-3-Loops">3.5.3 Loops</h4><h5 id="do-while">do-while</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-<span class="function">statement</span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(test-expr)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>第一次不测试</p></blockquote><p>汇编一个jmp就可以搞定</p><h5 id="while">while</h5><p>while有两种实现</p><p>对于以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_while</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Jump-to-middle">Jump-to-middle</h6><p>类似于do-while的汇编代码，只是需要在开始就跳转到后面的判断语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fact_while:</span><br><span class="line">  movl $1, %eax</span><br><span class="line">  jmp .JUDGE</span><br><span class="line">.L1:</span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq $1, %rdi</span><br><span class="line">.JUDGE:</span><br><span class="line">  cmpq $1, %rdi</span><br><span class="line">  jg .L1</span><br><span class="line">  rep; ret</span><br></pre></td></tr></table></figure><blockquote><p>一开始就有一个无条件跳转指令。</p></blockquote><h6 id="guarded-do">guarded-do</h6><p>当使用<strong>较高</strong>优化等级时，比如<code>-O1</code>时，GCC会使用这种策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fact_while:</span><br><span class="line">  cmpq $1, %rdi</span><br><span class="line">  jle .L1</span><br><span class="line">  movl $1, %eax</span><br><span class="line">.L2:</span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq $1, %rdi</span><br><span class="line">  cmpq $1, %rdi</span><br><span class="line">  jne .L2</span><br><span class="line">  rep; ret</span><br><span class="line">.L1:</span><br><span class="line">  movl $1, %eax</span><br><span class="line">  ret </span><br></pre></td></tr></table></figure><blockquote><p>相当于do-while的外面加一个判断</p></blockquote><p>这里是直接进行判断。这个之所以更加高效，是因为一开始进入循环时，通常不会不满足循环条件，即一开始不会跳转到后面，所以会直接顺序一直执行循环体。</p><h5 id="for">for</h5><p>for循环可以转换为while循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init-<span class="function">expr</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(test-expr)</span> </span>&#123;</span><br><span class="line">    body-statement;</span><br><span class="line">    update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据优化等级，GCC会为其产生的代码是while循环的两种方法之一。</p><h4 id="3-5-4-Switch-Statements">3.5.4 Switch Statements</h4><p><code>switch</code>语句可以根据一个整数索引数值进行多重分支。通常使用<strong>跳转表（Jump Table）<strong>数据结构使得实现更加高效，它是一个数组，每个元素是对应的代码块起始地址，根据整数索引得到对应的代码地址后，就可以直接跳转到对应的代码块。相比很长的<code>if-else</code>语句的</strong>优势在于</strong>：执行<code>switch</code>语句的时间与分支数目无关。比如有很长的分支语句，如果用<code>if-else</code>实现，则可能需要经过若干个<code>if-else</code>才能跳转到目的代码块，而使用<code>switch</code>能根据跳转表直接获得代码块地址。</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203223013944.png" alt="image-20220203223013944"></p><p>如下代码：</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203223308458.png" alt="image-20220203223308458"></p><p>里面有一个跳转表数组<code>jt</code>，GCC提供了一个新的运算<code>&amp;&amp;</code>，能够创建一个指向代码位置的指针。首先在第9行中，计算输入值<code>x</code>和<code>switch</code>的最小值的差，并将其保存到无符号数中。然后将其作为跳转表的索引，直接在第16行中跳转到索引的代码位置。</p><blockquote><p>这里使用无符号数的原因在于，即使你输入比<code>switch</code>中最小值还小的值，则相减会得到负数，由于无符号数会将负数溢出到很大的正数，所以还是会跳转到<code>default</code>。所以汇编代码会使用<code>ja</code>对其使用无符号数的判断，判断是小于0还是大于最大值。</p></blockquote><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203223634800.png" alt="image-20220203223634800"></p><blockquote><p>通过第2行可以知道<code>switch</code>的最小值，第3行可以知道<code>switch</code>的最大值，第4行可以知道<code>default</code>的标号。</p><p>用ja而不是jg就是使用无符号数</p></blockquote><p>这里首先将计算结果保存在<code>%rsi</code>中，然后在第4行中<code>jmp *.L4(, %rsi, 8)</code>利用了跳转表，跳转表的内容由编译器自动生成填写，其声明如下所示</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203224113494.png" alt="image-20220203224113494"></p><p><code>.rodata</code>表示这是只读数据（Read-Only Data），<code>.align 8</code>表示将元素地址与8对齐，<code>.L4</code>就定义了一个跳转表，其枚举了从最小值到最大值的跳转目标。对于<code>*.L4(, %rsi, 8)</code>，首先根据<code>.L4</code>可以获得该跳转表的初始位置，然后因为该跳转表每个元素占8个字节，所以计算<code>(, %rsi, 8)</code>，即<code>8*%rsi</code>，就能得到对应的跳转目标。</p><p>ps：可以着重看一下老师讲case 2,3，处理fall through case</p><blockquote><p>如果有负值情况，会做偏置处理，让第一个为0</p><p>如果只有两个值，中间是空的，很稀疏，会选择优化成if-else，而不是跳转表</p><p>switch的时间复杂度是O(1)</p></blockquote><blockquote><p>你理解了条件，就理解了程序在干什么</p></blockquote><p><strong>小点：</strong></p><ul><li>大多数情况下，机器对有符号数和无符号数都使用一样的指令，因为大多数算数运算对无符号数和补码都是相同的位级行为。但是在右移、除法和乘法指令以及条件码组合中，需要区分无符号数和补码。</li><li>保存在64位寄存器中的数据类型，除了<code>long</code>和<code>unsigned long</code>以外，还可以是指针（对于64位操作系统而言）。</li><li>条件跳转只能是直接跳转。</li><li>当<code>switch</code>的分支跨度很大，并且很稀疏时，会保存很大的跳转表，可能影响性能，编译器可能会将其构建成树的结构。此时建议使用<code>if-else</code>语句。</li></ul><h3 id="3-6-Procedures">3.6 Procedures</h3><blockquote><p>ABI:Appliction binary interface</p><p>机器程序级别的接口</p><p>%rax：返回值</p><p>%rdi，%rsi，%rdx，%rcx，%r8，%r9是传参的</p><p>%r10，%r11是caller-saved temporaries</p><p>%rbx，%r12，%r13，%r14是callee-saved，要保存</p><p>%rbp是callee-saved，是frame pointer</p><p>%rsp是callee-saved</p></blockquote><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220204155259884.png" alt="image-20220204155259884"></p><p>过程是软件中一种重要的抽象，提供一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。</p><p>要提供对函数的机器级支持，必须处理许多不同的属性。我们假设函数P调用函数Q，Q执行后返回P。这个过程包括以下一个或多个机制：</p><ul><li>传递控制：在进入函数Q的时候，程序计数器要设置为Q的代码的起始位置。从函数Q返回时，要把程序计数器设置为P中调用Q后面那条指令的地址，即从P中的断点处继续执行。</li><li>传递数据：函数P必须能够向函数Q传递一个或多个参数，而函数Q必须能够向函数P返回一个值。</li><li>分配和释放内存：开始时，函数Q可能需要为局部变量分配空间，而在返回前，又要释放这些存储空间。</li></ul><h4 id="3-6-1-Stack-Structure">3.6.1 Stack Structure</h4><p>栈的特性符合过程调用和返回这整个想法的实质。</p><p>%rsp指向栈顶，每当分配额外空间，递减栈指针。上面是高地址，栈往下长。</p><ul><li>push</li><li>pop</li></ul><blockquote><p>详见3.3.3</p></blockquote><p><strong>栈帧：<strong>当函数需要的存储空间超出寄存器能够存放的大小，或者调用别的函数需要保存额外数据时，就会在栈上分配一个空间，这个空间称为函数的</strong>栈帧（Stack Frame）</strong>。相对的，当某个函数的所有局部变量都能保存在寄存器中，并且不会调用任何的函数时，就无需开辟该函数的栈帧了。当给一个函数创建栈帧时，编译器会给函数分配<strong>所需</strong>的<strong>定长</strong>的栈帧，在函数开始时就分配好后就不会改变了，所以栈顶指针<code>%rsp</code>就知道当函数返回时，需要释放多少空间。而有些函数需要变长的栈帧，这部分内容可参考书3.10.5</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203232254404.png" alt="image-20220203232254404"></p><blockquote><p>因为未返回的函数都会在内存中保存自己的栈帧，而栈的空间是有限的，所以当调用过多时，会造成栈的溢出。</p></blockquote><blockquote><p>FP：Frame Pointer</p><p>帧的位置由一个或两个指针指示，%rbp和%rsp</p></blockquote><ul><li><p><strong>当函数P调用函数Q运行时：</strong></p></li><li><ul><li>由于x86-64只提供6个寄存器来传递函数输入值，所以当函数P传递给函数Q的参数多于6个时，需要函数P在自己的<strong>栈帧</strong>中存储好这些输入参数。</li><li>会先将返回地址压入栈中，表明当函数Q返回时，要从函数P中的哪个位置继续执行，这个作为P的栈帧的一部分。</li></ul></li><li><p>**函数Q运行时：**函数Q会扩展当前栈的边界，分配函数Q的栈帧所需的空间，可以用来保存寄存器的值、分配局部变量空间，为函数Q调用其他函数设置参数。</p></li><li><p>**函数Q返回时：**释放分配给函数Q的栈帧，并且让程序计数器调用返回地址，继续从函数P的断点处继续执行。</p></li></ul><h4 id="3-6-2-栈帧的组成部分">3.6.2 栈帧的组成部分</h4><h5 id="saved-register">saved register</h5><p>寄存器是所有函数共享的资源，当函数P调用Q时，如果函数Q改变了函数P保存在寄存器的值，则当函数Q返回时，函数P就无法完全从断点继续执行，因为寄存器中的值已经被函数Q改变了。（Q在运行的时候P不在运行）</p><p>我们对除了栈指针<code>%rsp</code>外的所有寄存器分成两类（按责任分，保存寄存器的责任在x那，就是x-saved）：</p><ul><li>callee saved：<code>%rbx</code>、<code>%rbp</code>和<code>%r12</code>~<code>%r15</code>。这部分寄存是由被调用者，即Q保存的。如果Q改变了这部分寄存器的值，就需要将其保存在Q自己栈帧中的**“被保存的寄存器”**中。当Q返回时，再将这部分寄存器的值根据内存复原。所以函数P可以假设“被调用者保存寄存器”的值是始终不变的。<ul><li>被调用者在用之前保存</li><li>回到caller的时候复原寄存器的值</li><li>callee函数需要caller保存callee寄存器</li></ul></li><li>caller saved：除了上面的寄存器外，都属于被调用者保存寄存器。 任何函数都能修改这些寄存器的值，并且不会保存在“被保存的寄存器”中，所以P要自己将这部分寄存的内容保存起来。所以函数P可以假设“调用者保存寄存器”的值是变化的，需要自己保存，可以用这部分寄存器保存临时值。<ul><li>调用者在调用之前保存</li></ul></li></ul><blockquote><p>当函数P调用函数Q时，“被调用者保存寄存器”就会保存在函数Q的栈帧中，所以当函数Q返回时，这部分寄存器会被重置为函数P使用时的状态。而<strong>其他寄存器的值是需要函数P自己保存的，所以函数P需要自己开辟局部变量区域来保存其他寄存器的值</strong>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//1.函数一进来，就需要通过push指令将自己要使用的“被调用者保存寄存器”保存在自己的栈帧中</span><br><span class="line">//比如使用了%rbx和%rbp</span><br><span class="line">  pushq %rbx    //保存%rbx到栈帧中</span><br><span class="line">  pushq %rbp    //保存%rbp到栈帧中</span><br><span class="line">... //可以使用“被调用者保存寄存器”来保存值</span><br><span class="line">//2.当“被调用者保存寄存器”不够保存当前函数的值时，需要开辟局部变量空间保存其他值</span><br><span class="line">//比如保存8字节值</span><br><span class="line">  subq $8, %rsp //将栈指针下移8个字节</span><br><span class="line">  movq %rdi, (%rsp)  //将需要保存的值保存到栈上</span><br><span class="line">//3.调用别的函数</span><br><span class="line">  call func //调用函数func，则“被调用者保存寄存器”会保存在函数func的栈帧中</span><br><span class="line">... //可以继续使用“被调用者保存寄存器”，因为函数func返回时会重置这些寄存器到原始值</span><br><span class="line">//4.释放局部变量空间</span><br><span class="line">  addq $8, %rsp</span><br><span class="line">//5.重置“被调用者保存寄存器”的值，注意顺序要相反</span><br><span class="line">  popq %rbp</span><br><span class="line">  popq %rbx</span><br></pre></td></tr></table></figure><ol><li>将要使用的“callee saved register”<code>push</code>到栈中。（存储调用当前函数的函数的值）</li><li>将除了“callee saved register”的其他寄存器保存在空闲的“callee saved register”中，如果保存不下，就将其保存在内存的“局部变量”区域</li><li>调用其他函数</li><li>释放 “局部变量”区域</li><li>将“被调用者保存寄存器”的值通过<code>pop</code>从栈中恢复。注意：顺序要和<code>push</code>时相反</li></ol><blockquote><p>如果“被调用者保存寄存器”还没有使用完毕时，可以在调用别的函数之前将其他寄存器的值保存到“被调用者保存寄存器”中。</p></blockquote><h5 id="Local-Variable-局部变量">Local Variable 局部变量</h5><p>当函数需要保存的数据不多时，就会将数据保存在“被调用者保存寄存器”中。但是以下情况必须<strong>保存在内存中</strong>，该部分称为该函数的<strong>局部变量：</strong></p><ul><li>“被调用者保存寄存器”不足以保存所有的本地数据</li><li>当一个局部变量使用取地址符&amp;时，指的是返回该变量在内存中的地址，就必须将其保存在内存中</li><li>当局部变量是数组或结构时</li></ul><p>总结为以下几步：</p><ol><li>申请局部空间，通过对栈顶指针<code>%rsp</code>减掉一个值</li><li>根据数据大小，通过<code>%rsp</code>索引将数据保存在内存空间中</li><li>根据传入参数顺序，将其保存到内存和寄存器中。**注意：**参数大小要为8字节的倍数。</li><li>释放局部空间，通过对栈顶指针<code>%rsp</code> 加上<code>1.</code>中的值</li></ol><h5 id="参数构造区">参数构造区</h5><p>函数P必须能够向函数Q传递一个或多个参数，而函数Q必须能够向函数P返回一个值。</p><p>在函数间传递数据，主要<strong>通过寄存器</strong>进行，x86-64提供了6个用于传递<strong>参数</strong>的寄存器，根据参数的顺序，需要放入特定的寄存器中。x86-64将寄存器<code>%rax</code>作为函数<strong>返回值</strong>的寄存器。</p><blockquote><p>这些寄存器只能用来保存整数或指针类型。</p><p>为什么现在优先使用寄存器传参？因为寄存器更快</p></blockquote><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220204140327244.png" alt="image-20220204140327244"></p><p>如果某个函数要传递超过6个参数的话，就需要将第7个到第n个参数保存在<strong>栈</strong>中，然后通过<strong>栈顶指针<code>%rsp</code><strong>进行索引其中第7个参数在栈顶位置。所有数据大小都向8字节的倍数对齐。这部分区域称为</strong>参数构造区</strong>。</p><blockquote><p>由于栈顶还要保存一个8字节的返回地址，所以第7个参数的地址为<code>8(%rsp)</code>，如果第7个元素大小不超过8字节，则第8个元素的地址为<code>16(%rsp)</code>，以此类推。</p></blockquote><h5 id="返回地址">返回地址</h5><ul><li><p><code>call</code>：可以直接将函数名作为跳转目标，其编码的计算方式和<code>jmp</code>相同。相当于<code>push</code>和设置<code>%rip</code>的组合。</p></li><li><ul><li>将栈指针减8，留出保存返回地址的空间</li><li>将紧跟<code>call</code>指令后面那条指令的地址作为返回地址，保存到栈中。</li><li>将程序计数器设置为调用函数的地址。</li></ul></li><li><p><code>ret</code>：从当前函数返回，不需要操作数。相当于设置<code>%rip</code>和<code>pop</code>的组合。</p></li><li><ul><li>将程序计数器设置为栈顶元素。</li><li>将栈指针加8。</li></ul></li></ul><h5 id="综上所述：">综上所述：</h5><ol><li>（被保存的寄存器）函数P将要使用的“被调用者保存寄存器”通过<code>push</code>保存在函数的栈帧中。</li><li>（局部变量）如果函数P使用了“调用者保存寄存器”，就需要将其保存在栈中，才能调用函数Q。并且函数P根据需要申请空间来保存其他局部变量。</li><li>（参数构造区）函数P将参数保存在寄存器中，如果超过6个参数，就申请空间保存到内存中。</li><li>（返回地址）函数P使用<code>call</code>指令调用函数Q，会将<code>call</code>的下一行指令的地址压入栈中，并将程序计数器指向函数Q的第一条指令的地址。</li><li>当函数Q运行时会随着使用动态申请和释放局部变量，当函数Q运行完时，首先使用栈“被调用者保存寄存器”的值，然后使用<code>ret</code>指令返回将程序计数器设置为栈顶的返回地址，最后将栈顶的返回地址弹出。</li></ol><p>无论是“被保存的寄存器”还是“局部变量”以及“参数构造区”，一开始如何申请这些区域，后面使用完后还会逆向地通过<code>%rsp</code>将这些区域释放掉，这是动态的过程，使得一个函数运行完时，<code>%rsp</code>指向的就是返回地址，就能直接通过<code>ret</code>返回到调用者的断点处。</p><h4 id="3-6-3-Calling-Conventions">3.6.3 Calling Conventions</h4><h5 id="Passing-control">Passing control</h5><blockquote><p>也是压栈的机制</p></blockquote><ul><li>call</li><li>ret</li></ul><h5 id="Passing-data">Passing data</h5><p>见3.6.2的参数构造区</p><h5 id="Managing-local-data">Managing local data</h5><p>见3.6.2</p><h4 id="3-6-4-Illustration-of-Recursion">3.6.4 Illustration of Recursion</h4><ul><li>每个过程调用在栈中有自己的私有空间</li><li>多个未完成调用的局部空间不会相互影响</li><li>有时候存在相互调用，同理</li></ul><p><strong>小点：</strong></p><ul><li>不会显示地操作程序计数器寄存器<code>%rip</code>，没有指令可以对其操作，只能通过类似<code>call</code>或<code>ret</code>间接对其操作。</li><li>栈顶指针<code>%rsp</code>是随着函数运行不断变化的。</li><li>某个函数要永久使用的值，要么保存在“被调用者保存寄存器”中，要么保存在内存中。</li><li>当函数需要使用“被调用者保存寄存器”时，就直接将其<code>push</code>到栈中，使用过后再<code>pop</code>重置。</li></ul><h3 id="3-7-Array">3.7 Array</h3><blockquote><p>数组和结构是聚合数据的两种形式，但是汇编不会直接提供这样的数据结构</p></blockquote><h4 id="One-dimensional">One-dimensional</h4><p>对于数据类型<code>T</code>和整形常量<code>N</code>，声明一个数组变量<code>A</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T A[N];</span><br></pre></td></tr></table></figure><p>主要经历<strong>两个步骤：</strong></p><ol><li>根据数据类型<code>T</code>的大小<code>L</code>字节，先在内存空间中分配一个大小为<code>L*N</code>的连续空间；</li><li>将<code>A</code>作为这个连续内存空间的起始指针，即A的值<code>xA</code>就是该内存空间的起始地址。</li></ol><blockquote><p>当你声明了一个数组，你既为它分配了空间，并且创建了一个允许进行指针运算的数组名称。而当你声明一个指针时，你所分配的只有指针本身的空间，所以如果没有初始化指针，直接对其进行解引用可能会出现错误。</p></blockquote><p>如果是int的话，当数组作为指针加1时，地址加了sizeof(int)，所以当数组内为负数或者很大超过上界的数其实也是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">4</span>]    <span class="number">3</span></span><br><span class="line">A       x</span><br><span class="line">A + <span class="number">1</span>   x + <span class="number">4</span> </span><br></pre></td></tr></table></figure><blockquote><p>指针只能相减，不能相加</p></blockquote><p><strong>数组和指针的区别：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int A1[3];</span><br><span class="line">int *A2;</span><br><span class="line">int *A3[3];</span><br><span class="line">int (*A4)[3];</span><br><span class="line">int (*A5[3]);</span><br></pre></td></tr></table></figure><ul><li><code>sizeof(A1)</code>为12，返回的是数组内保存的全部元素大小； <code>sizeof(*A1)</code>为4，返回的是第一个元素的大小，即<code>int</code>的大小。而<code>sizeof(A2)</code>为8，返回的只是指针的大小；<code>sizeof(*A2)</code>为4，返回的也是<code>int</code>的大小。</li><li>如果没有对<code>A2</code>进行初始化，直接调用<code>*A2</code>可能会报错，因为它没有指向合理的对象。而<code>*A1</code>不可能出错，因为创建数组时，已经为他分配好了空间。</li><li><code>A3</code>声明了大小为3的数组，每个元素的类型为<code>int *</code>，所以<code>sizeof(A3)</code>为24，因为数组内有3个元素，每个元素都是指针，大小为8。而<code>sizeof(*A3)</code>为8，因为<code>A3</code>的第一个元素是一个指针，大小就为8。而<code>sizeof(**A3)</code>为4，它表示的是数组中第一个指针指向的<code>int</code>，所以是4。因为<code>A3</code>首先声明的是一个数组，所以它会自动分配好数组的空间，所以<code>*A3</code>不会是空指针，但是它里面保存的是指针，所以<code>**A3</code>可能会是空指针。</li><li><code>A4</code>定义了一个指向大小为3的<code>int</code>数组的指针。所以<code>sizeof(A4)</code>为8，只是一个单纯的指针的大小；<code>sizeof(*A4)</code>为12，它表示<code>A4</code>指向的数组的大小。而<code>sizeof(**A4)</code>为4，它表示<code>A4</code>指向的数组的第一个元素。 因为这里只是单纯声明了一个指针，所以<code>*A4</code>和<code>**A4</code>都可能是空指针。</li><li>A5和A3一样</li></ul><blockquote><p>当使用空括号声明的时候就像指针，当给出了数字，就真的分配了内存</p></blockquote><h4 id="Multi-dimensional（nested）">Multi-dimensional（nested）</h4><p>在内存中，这种二维数组是按照“行优先”的形式保存在内存中的</p><p><code>D[i][j]</code>的地址为<code>x+L(Ci+j)</code></p><p>e.g.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZLEN 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zip_dig[ZLEN];</span><br><span class="line">zip_dig pgh[PCOUNT] = </span><br><span class="line">  &#123;&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span> &#125;,</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span> &#125;&#125;;</span><br></pre></td></tr></table></figure><p>获得某个索引的值的C代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pgh_digit</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> dig)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pgh[index][dig];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># index in %rdi, dig in %rsi</span><br><span class="line">get_pgh_digit:</span><br><span class="line">  leaq (%rdi, %rdi, 4), %rax    #5*index，每个都有五个</span><br><span class="line">  addl %rax, %rsi               #5*index+dig</span><br><span class="line">  movl pgh(,%rsi, 4), %eax      #Mem[pgh+20*index+4*digit]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>如果是特殊的矩阵，数组保存了指向数组的指针，那需要引用内存两次。尽管c代码是一样的，但是底层的引用逻辑不一样</p><p>对应的汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#index in %rdi, digit in %rsi</span><br><span class="line">get_univ_digit:</span><br><span class="line">  salq $3, %rsi  #8*index</span><br><span class="line">  movq univ(%rsi), %rax #获得指针</span><br><span class="line">  movl (%rax, %rsi, 4), %eax  #Mem[Mem[univ+8*index]+4*digit]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>这里有两次内存引用过程。</p><h4 id="Fixed-dimensions">Fixed dimensions</h4><p>当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过<code>#define</code>声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。当优化等级设置为<code>-O1</code>时，GCC会采用很多聪明的优化，避免了索引<code>A[i][j]</code>要计算乘法<code>A+L(Ci+j)</code>的巨大损耗。</p><h4 id="Variable-dimensions">Variable dimensions</h4><p>过去C要求数组的大小要在编译时就确定，才能生成对应的汇编代码。如果需要变长数组，就需要程序员自己对数组分配存储空间。ISO-C99允许数组的维度为表达式，在数组被分配时才计算出来，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[exp1][exp2];</span><br></pre></td></tr></table></figure><p>只要求<code>exp1</code>和<code>exp2</code>定义在上面那个声明之前。</p><p>我们接下来对比下定长数组和变长数组在索引时汇编代码的区别</p><ul><li>定长数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fix_matrix[<span class="number">5</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fix_ele</span><span class="params">(fix_matrix A, <span class="keyword">long</span> i, <span class="keyword">long</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fix_ele:</span><br><span class="line">  leaq (%rsi, %rsi, 2), %rax    #compute 3i</span><br><span class="line">  leaq (%rdi, %rax, 4), %rax    #compute A+12i</span><br><span class="line">  movl (%rax, %rdx, 4), %eax    #read fomr M[A+12i+4j]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><ul><li>变长数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">var_ele</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> A[n][n], <span class="keyword">long</span> i, <span class="keyword">long</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var_ele:</span><br><span class="line">  imulq %rdx, %rdi             #compute ni</span><br><span class="line">  leaq  (%rsi, %rdi, 4), %rax  #compute A+4ni</span><br><span class="line">  movl  (%rax, %rcx, 4), %eax  #read from M[A+4ni+4j]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>看汇编代码可以发现以下区别：</p><ul><li>增加了参数n，使得寄存器的使用改变了，</li><li>用了乘法指令来计算<code>ni</code>，而不是用<code>leaq</code>来计算<code>3i</code>，乘法会导致无法避免的性能损失</li></ul><p>使用优化，GCC能够识别出步长，然后生成的代码会避免直接乘法，从而可以提高性能。</p><h3 id="3-8-Structures">3.8 Structures</h3><h4 id="Allocation-Access">Allocation/Access</h4><p>C语言中，可以用<code>struct</code>声明创建一个<strong>数据类型</strong>，具有以下特点：</p><ul><li>定义：可以将不同类型的对象聚合到一个对象中，并使用名字来引用结构中的各个组成部分。</li><li>存储：结构的所有组成部分都存放在内存中一段<strong>连续的</strong>区域内，指向结构的<strong>指针</strong>是结构第一字节的地址。</li><li>获得元素：编译器会维护关于每个结构类型的信息，了解每个字段的偏移量，由此作为内存引用指令的唯一，来对结构元素进行引用。</li></ul><h4 id="Alignment">Alignment</h4><p>数据对齐，提高效率。在x86-64上，即使数据不对齐，也不会影响任何功能，但是有些机器如果访问未对其的数据，可能会造成内存错误。（硬件问题）</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212173034219.png" alt="image-20220212173034219"></p><p><strong>对齐原则</strong>是任何K字节的基本对象的地址必须是K的倍数</p><p>为此，在<code>struct</code>中两个连续的对象，编译器可能中间会插入间隙，来满足各自对内存地址的要求。并且还有<strong>两个额外的要求：</strong></p><ul><li>要求结构的初始地址一定是结构体中最大对象大小的倍数，使得偏移量加上初始地址才是真的满足倍数关系的。</li><li>在结构体末尾填充，使其是结构体中<strong>最大对象</strong>大小的倍数，使得结构数组中下一个元素的地址也是成倍数关系的。</li></ul><blockquote><p>Tip：平时我们写结构的时候，最好按照从大到小的形式进行声明，可以减少填充的字节数目，节省该结构的空间大小</p></blockquote><h3 id="3-9-Union">3.9 Union</h3><p>C语言中，可以用<code>union</code>声明创建一个<strong>数据类型</strong>，具有以下特点：</p><ul><li>定义：允许以多种类型来引用一个对象。</li><li>存储：保存在<strong>公共的</strong>一块内存中，通过不同对象的类型来赋予这块内存不同的含义。内存大小为最大字段的大小。</li><li>语法和结构一样</li></ul><p>主要具有以下应用情况：</p><ul><li>如果我们事先知道两个不同字段是互斥的，就能将其定义在一个union中，就能节省内存空间。<ul><li>比如二叉树</li></ul></li><li>访问相同位模式下不同数据类型的值。-</li></ul><p>比如我们对一个<code>double</code>类型的对象<code>d</code>使用强制类型转换到<code>long</code>，则除了0的情况，他们的位模式会发生很大变化。如果我们想要保持位模式不变，则可以使用union</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">double2long</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">  &#125; temp;</span><br><span class="line">  temp.d = d;</span><br><span class="line">  <span class="keyword">return</span> temp.l;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>此时返回的就能保持位模式不发生变化了，因为是直接调用相同的内存空间。</p><p><strong><code>struct</code>和<code>union</code>的区别：</strong><code>struct</code>为每个对象分配了单独的内存空间，而<code>union</code>分配了共用的内存空间。</p><p>**什么时候用<code>union</code>什么时候用<code>struct</code>：**当你要信息同时存在时，就需要分配到不同的内存中，就要用<code>struct</code>，否则用<code>union</code>。</p><p><strong>计算struct和union嵌套的数据类型的内存分布：</strong></p><ul><li>如果是包裹在struct内的，就按顺序按照对象大小依次排列下来</li><li>如果是包裹在union内的，就看最大的对象大小，直接分配一块内存就行</li></ul><h3 id="3-10-Floating-Point-跳过也可">3.10 Floating Point(跳过也可)</h3><h4 id="历史">历史</h4><p>在很久之前，8086处理器上有一块8087芯片，能够提供实现完整IEEE浮点数所需的所有硬件，事实上，它是与IEEE浮点标准本身共同开发的，但是它的编程模型非常难用。</p><p>SIMD——&gt;SSE——&gt;AVX</p><p>SSE和AVX都提供了支持SIMD的指令集，使得可以在物理层面上实现同时对多个整型和浮点数进行并行运算，SSE有独立的16个128位XMM寄存器，AVX进一步扩展得到16个256位YMM寄存器，每个XMM寄存器都是对应的YMM寄存器的低128位。</p><h4 id="浮点代码">浮点代码</h4><p>处理器的浮点体系结构包含多个方面，会影响对浮点数据操作的程序如何映射到机器上，包括：</p><ul><li>如何存储和访问浮点数值</li><li>对浮点数据操作的指令</li><li>向函数传递浮点数参数和从函数返回浮点数结果的规则</li><li>函数调用过程中保存寄存器的规则</li></ul><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212191044922.png" alt="image-20220212191044922"></p><p>浮点数只有caller-saved</p><h5 id="浮点传送">浮点传送</h5><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212191920932.png" alt="image-20220212191920932"></p><p>其中，引用内存的都是标量指令，而在两个XMM寄存器之间传送数据的是SIMD指令。其中<code>a</code>表示aligned，当读写内存时，要求满足16字节对齐（因为XMM是16字节的），否则会报错，而这里直接在两个XMM寄存器之间传输，绝不会出现错误对齐的情况。 建议32位内存数据满足4字节对齐，64位数据满足8字节对齐。</p><p><strong>例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">float_mov</span><span class="params">(<span class="keyword">float</span> v1, <span class="keyword">float</span> *src, <span class="keyword">float</span> *dst)</span></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> v2 = *src;</span><br><span class="line">  *dst = v1;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#v1 in %xmm0, src in %rdi, dst in %rsi</span><br><span class="line">float_mov:</span><br><span class="line">  vmovaps %xmm1, %xmm1  #v2是返回值，要使用%xmm0，而当前v1占用了%xmm0，所以先挪一下</span><br><span class="line">  vmovss (%rdi), %xmm0</span><br><span class="line">  vmovss %xmm1, (%rsi)</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>**注意：**传入参数，如果是浮点数，就保存在XMM寄存器中，如果是指针或整型，就保存在常规寄存器中。而返回值也是如此。</p><h5 id="浮点转换操作">浮点转换操作</h5><h6 id="浮点数–-整型">浮点数–&gt;整型</h6><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192207796.png" alt="image-20220212192207796"></p><h6 id="整型–-浮点数">整型–&gt;浮点数</h6><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192231286.png" alt="image-20220212192231286"></p><p>在整型转换成浮点数时，提供了三操作数指令，这里通常可以忽略第二个操作数，因为它的值只会影响高位字节，通常使用目的寄存器。常见的使用方式为<code>vcvtsi2sdq %rax, %xmm1, %xmm1</code> 。</p><h6 id="浮点数相互转换">浮点数相互转换</h6><p>浮点数相互转换的命令比较特殊，不是提供单一指令进行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Conversion from single to double precision</span><br><span class="line">vunpcklps %xmm0, %xmm0, %xmm0  #replicate first vector element</span><br><span class="line">vcvtps2pd %xmm0, %xmm0         #convert two vector elements to double</span><br><span class="line"></span><br><span class="line"># Conversion from double to single precision</span><br><span class="line">vmovddup %xmm0, %xmm0     #replicate first vector element</span><br><span class="line">vcvtpd2psx %xmm0, %xmm0   #convert two vector elements to single</span><br></pre></td></tr></table></figure><h5 id="过程中的浮点代码">过程中的浮点代码</h5><ul><li>函数传入的浮点数，或者函数使用浮点数进行计算时，都需要使用上述寄存器。也可以使用栈来传递额外的浮点参数。</li><li>%xmm0既是函数第一个参数的寄存器，也是函数返回值的寄存器</li><li>所有寄存器都是“调用者保存寄存器”，所以函数要先将这些值保存在内存中，才去调用别的函数。</li></ul><blockquote><p>参数到寄存器的映射取决于参数的顺序和类型。如果是整型或指针，就使用通用寄存器，如果是浮点数，就使用XMM寄存器。</p></blockquote><h5 id="浮点运算操作">浮点运算操作</h5><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192452876.png" alt="image-20220212192452876"></p><p>每条指令可以有一个源操作数或两个源操作数，以及一个目的操作数。其中，第一个源操作数可以是XMM寄存器或内存位置，而第二个操作数和目的操作数只能是XMM寄存器。</p><blockquote><p>当计算中出现整型、float和double混合时，需要将整型和float都转换成double再计算。</p></blockquote><h5 id="定义和使用浮点常数">定义和使用浮点常数</h5><p>和整数运算操作不同，AVX浮点操作不能用立即数作为常数。编译器会为浮点常数分配和初始化存储空间，然后代码再从内存中读取这些值。比如以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cel2fahr</span><span class="params">(<span class="keyword">double</span> temp)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.8</span>*temp+<span class="number">32.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>1.8</code>和<code>32.0</code>是浮点常数，编译器会将其保存在内存中，而不是作为立即数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.LC2:</span><br><span class="line">  .long 3435973837</span><br><span class="line">  .long 1073532108</span><br><span class="line">.LC3:</span><br><span class="line">  .long 0</span><br><span class="line">  .long 1077936128</span><br></pre></td></tr></table></figure><p>这里分别用标号<code>.LC2</code>和<code>.LC3</code>表示<code>1.8</code>和<code>3.6</code>。这里使用两个<code>.long</code>声明和十进制表示的值来表示一个<code>double</code>常量的。我们可以推算一下这个值：首先这里使用的是小端法，数值的最低有效位保存在了较小的地址中，所以<code>3435973837</code>表示低4字节的值，而<code>1073532108</code>表示高4字节的值。而表示为十进制时，我们可以直接将其转换成十六进制的值，就能获得正确排列的字节序列（因为小端法只是表示机器怎么存储数据的，而整数值是真实字节对应的数值）。 <code>3435973837</code>的十六进制数为<code>0xcccccccd</code>，<code> 1073532108</code>的十六进制数为<code>0x3ffccccc</code>，则按顺序排列就能得到浮点数的编码<code>0x3ffccccccccccccd</code>。我们知道<code>double</code>类型的第一位为符号位，然后接下来的11位为阶码位，最后的52位为尾数位。前3个十六进制数为<code>0x3ff</code>转化为二进制数为<code>001111111111</code>，则阶码为<code>01111111111</code>，对应的无符号数为1023，偏移量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>11</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>1023</mn></mrow><annotation encoding="application/x-tex">2^{11-1}-1=1023</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">3</span></span></span></span> ，则 E = 0；而尾数部分的十六进制数为<code>0xccccccccccccd</code>，它表示的是二进制分数，则转化为十进制数为0.8，再加上1为1.8，所以最后的值为1.8。</p><p>则该段C代码对应的汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cel2fahr:</span><br><span class="line">  vmulsd .LC2(%rip), %xmm0, %xmm0</span><br><span class="line">  vaddsd .LC3(%rip), %xmm0, %xmm0</span><br><span class="line">  ret </span><br></pre></td></tr></table></figure><h5 id="浮点代码中的位级操作">浮点代码中的位级操作</h5><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192831935.png" alt="image-20220212192831935"></p><h5 id="浮点比较操作">浮点比较操作</h5><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192849339.png" alt="image-20220212192849339"></p><p>其中第二个操作数必须在XMM寄存器中，第二个操作数可以在XMM寄存器，也可以在内存中。类似于CMP指令，会设置三个条件码：零标志为ZF、进位标志位CF和奇偶标志位PF。当进行浮点比较时，如果有任何一个是NaN，则会设置PF，并且比较失败。</p><p>条件码的设置条件如下，只要有任何一个操作数为NaN，就会出现无序的情况。</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192925385.png" alt="image-20220212192925385"></p><p>当出现无序的结果，可以使用指令<code>jp</code>（jump on parity）来进行跳转，而其他结果和无符号数的比较相同。</p><h3 id="3-11-Memory-Layout">3.11 Memory Layout</h3><p>真实物理内存通过操作系统将其映射<strong>虚拟内存</strong>，从程序员的角度，内存就被抽象为一个很大的字节数组，每个元素是一个字节。在86-64机器上，64位二进制数为该数组地址进行编码，意味着64位操作系统最大能容纳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 字节的内存大小，目前市面上该大小的内存还不是很普及。现在64位机器会限制只使用47位的地址，这也能支持 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>47</mn></msup></mrow><annotation encoding="application/x-tex">2^{47}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>字节，即128T的内存大小。只使用47位编码时，最小地址为<code>0x0</code>，而最大的地址为<code>0x00007FFFFFFFFFFF</code>。</p><p>虚拟内存存储数据也是分不同区域的，如下图所示（不是按比例绘制的），地址从下到上依次递增。</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220214111257016.png" alt="image-20220214111257016"></p><ul><li><strong>Stack：<strong>在Linux中，将栈放置在整个地址空间的最顶部，用于函数调用，及</strong>局部变量</strong>的存储，这样随着函数的运行，栈顶就能向<strong>低地址</strong>不断扩展。常用系统中栈的大小是8MB，可通过命令<code>limit</code>查看，如果用栈指针访问超过8MB范围的地址，就会出现<strong>段错误（Segmentation Fault）</strong>。 相同程序的栈的分配是固定的。</li><li><strong>Shared Libraries：<strong>类似于<code>printf</code>和<code>malloc</code>的这类</strong>库函数</strong>平时是被存储在磁盘上的，当我们程序需要使用库函数时，就会在程序开始执行时，将它们加载到你的程序中，这称为<strong>动态加载（Dynamic Linking</strong>）。</li><li>**Heap：<strong>用来存放通过</strong><code>malloc</code>、<code>callc</code>或<code>new</code>**等申请的变量，这些变量在程序运行时会动态变化。当你不断通过<code>malloc</code>申请空间又没释放时，堆顶的指针就不会断向高地址增加，使得占用的内存不断变多。堆在分配时是具有随机性的。</li><li><strong>Data：<strong>该数据区用来存放程序开始时分配的数据，你声明的</strong>全局变量、静态变量或字符常量等</strong>都在这个数据段中。</li><li><strong>Text：<strong>根据可执行目标文件的内容进行初始化，是放置</strong>可执行程序</strong>的位置。放置函数。这部分区域是只读的。</li></ul><h3 id="3-12-理解指针">3.12 理解指针</h3><p>指针类型不是机器代码的一部分，而是C语言提供的关于内存地址的抽象，指针的值存储的是对象的地址，可以直接通过指针来间接对内存进行访问，避免程序员寻址错误。特殊的<code>NULL(0)</code>表示该指针不指向任何值。如果指针通过<code>&amp;</code>创建，表示取某个对象的地址，在机器代码中对应于<code>leaq</code>。如果指针通过<code>*</code>进行访问，表示访问该指针指向的对象的值，在机器代码中对应于内存引用。</p><p>我们同样可以声明<strong>函数指针</strong>，表示指向函数在机器代码中的第一条指令的内存地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T (*fp)(arg1T, arg2T,...);</span><br></pre></td></tr></table></figure><p>其中，<code>T</code>为函数的返回值类型，<code>arg1T</code>表示第一个参数的类型，以此类推。然后将函数名赋值给该函数指针，就能直接通过该函数指针调用函数了。</p><h3 id="3-13-Buffer-Overflow">3.13 Buffer Overflow</h3><p>数据栈中保存着函数的返回地址、“被调用者保存寄存器”以及局部变量等其他信息。C语言声明的数组也保存在<strong>栈</strong>的局部变量区，并且C语言不会对数组的引用进行任何<strong>边界检查</strong>，使得我们可以超出数组的边界对栈中的其他数据进行修改，比如对<strong>函数返回地址</strong>进行修改，此时程序就会出现很严重的问题，甚至有时候修改了地址，不会crash程序，错误的代码会一直运行下去，跳到不知名的地方。</p><p>这种破坏方法称为<strong>缓冲区溢出（Buffer Overflow）</strong>，通常在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。</p><p>库函数<code>gets</code>、<code>strcpy</code>、<code>strcat</code>、<code>sprintf</code>都是很危险的函数。他没有办法确地是否为保存整个字符串分配了足够的空间。</p><p>一个代码攻击方式，就是找到存储跳转地址的地方，把原本需要跳转的地址改成我注入攻击代码的地址，执行注入的代码。</p><p>Buffer overflows的历史</p><ul><li>莫里斯蠕虫</li><li>finger，远程联系，使用gets</li><li>IM War，即时通讯<ul><li>利用自身bug来监测</li></ul></li></ul><p>蠕虫和病毒的区别</p><ul><li>蠕虫可以自己运行，并繁衍</li><li>病毒，不能自己存活，他攻击一个程序并且改变他</li></ul><h4 id="避免缓冲区攻击的手段">避免缓冲区攻击的手段</h4><ul><li><p>不使用具有缓冲溢出的函数，比如使用<code>fgets</code>代替<code>gets</code>，因为<code>fgets</code>有一个用来指定程序最多可以读取多少字节的参数， 如果输入的字节超过这个数字，就会对其进行截断。同样可以使用<code>strncpy</code>代替<code>strcpy</code>。要注意不要直接使用<code>scanf</code>的<code>%s</code>来读取字符串，要么使用<code>fgets</code>代替，要么使用<code>%ns</code>来指定最多可以输入多长的字符串。</p></li><li><p>地址空间布局随机化ASLR。为了在系统中插入攻击代码，攻击者不仅要插入攻击代码，还要插入指向这段攻击代码的指针，所以需要知道代码放置的位置。对此，可以使用<strong>地址空间布局随机化（Address-Space Layout Randomization，ASLR）<strong>技术，ASLR中有一种</strong>栈随机化</strong>技术，每次程序运行时，在栈中分配一段0~n字节的随机大小空间，就能使得栈的位置在程序每次运行时都有变化。每次运行程序时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据都会加载到内存的不同区域，使得代码位置不是很好获得。对应的破解方法是使用<strong>空操作雪橇（Nop Sled）</strong>，通过在攻击代码前插入一段很长的<code>nop</code>指令，当运行到<code>nop</code>指令时，就会“滑到”最终的攻击代码位置，通过枚举不同的起始地址，然后执行这段攻击代码，就能成功，只是效率可能会有点低。</p></li><li><p>限制可执行代码区域（标记法）。注入代码的形式，使得要执行的代码跑到了栈上去，但是可执行代码应该位于Text区域。在原始的x86上，每个内存区域都有一个标记位，来表示该区域属于哪种类型，包括：<strong>可写、可读</strong>（等价于可执行）。在过去的10年左右，首先是AMD，然后是Intel，添加了第三种标志：<strong>可执行</strong>。所以我们可以简单地标记栈是不可执行的，就能防止通过修改返回地址，返回到栈上执行注入代码。</p></li><li><p>Canary（金丝雀，哨兵）栈破坏检测</p><p>缓冲区溢出攻击通常在缓冲区溢出时发生，所以当我们能够检测到什么时候发生缓冲区溢出，就能终止该程序。</p><p>GCC首先会尝试确定一个函数是否容易受到栈溢出攻击，比如函数中有局部char类型缓冲区时，就会使用一种<strong>栈保护者（Stack Protector）机制</strong>，通过在该函数栈帧中的局部变量区与栈状态（返回地址和寄存器保存区）之间存入一个随机的<strong>金丝雀值（Canary）</strong>，然后在恢复寄存器状态和返回返回地址之前，会检测该值是否发生变化，如果发生变化，则程序异常终止。</p><p>**技巧：**将缓冲区放在靠近金丝雀值的位置，防止其他局部变量被修改。</p></li></ul><h4 id="ROP攻击">ROP攻击</h4><p>针对上述的3个系统提供的防御措施：栈随机化、限制可执行代码区域以及插入金丝雀值，我们可以使用新的攻击方法**ROP攻击（Return-Oriented Programming Attacks）**来破解前两种防御措施。</p><p>ROP的<strong>策略</strong>是：即使我们不知道栈的位置在哪，但我们知道代码存在哪里，因为栈随机化并没有修改全局变量和代码本身的位置，我们就可以使用现有的可执行代码片段来拼凑出我们想要的整体代码。</p><blockquote><p>该方法无法克服金丝雀值，即只能输入缓冲区限制的字节数目。</p></blockquote><p><strong>利用x86返回语句的特殊形式</strong></p><ul><li>在现有的代码中找到我们需要的所有字节片段，并且要求以<code>ret</code>结尾（后面会说为什么） 。比如</li></ul><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220214214742152.png" alt="image-20220214214742152"></p><p>通过这段代码我们就能得到<code>%rdi</code>和<code>%rdx</code>的值，这段代码的地址为<code>0x4004d4</code></p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220214214816343.png" alt="image-20220214214816343"></p><p>通过这段代码，我们可以将<code>%rax</code>的值赋给<code>%rdi</code>，就能作为函数的参数。这段代码的地址为<code>0x400dc</code>。</p><p>我们可以通过类似上述的方法获得一系列我们需要的代码片段，来组成我们想要运行的最终程序。</p><ul><li>将上述获得的所有代码片段地址，依次输入到栈中</li></ul><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220214214946451.png" alt="image-20220214214946451"></p><ul><li>我们可以修改<code>%rbp</code>的值，使得释放栈帧时栈顶指针<code>%rsp</code>还是只想当前的栈顶，这样程序执行自己的ret指令就能开始攻击了。</li></ul><blockquote><p>利用ret的机制，不断获得下一个代码片段的地址，一次类推，最终完成所有攻击代码</p></blockquote><h3 id="3-14支持变长指针">3.14支持变长指针</h3><p>对于一些栈大小是变化的函数，就需要支持变长栈帧。</p><p>为了管理变长栈帧，x86-64代码使用<code>%rbp</code>作为<strong>帧指针（Frame Pointer）</strong>。进入函数时，先将其存入到“保存寄存器区”，然后将当前的栈指针<code>%rsp</code>的值赋予<code>%rbp</code>，则函数最后可直接通过将<code>%rbp</code>的值赋予<code>%rsp</code>就能释放变长的栈帧，并且通过“保存寄存器区”来重置<code>%rbp</code>的值。</p><p>变长栈帧的申请，会自动进行对齐操作，并且使用<code>%rbp</code>作为初始地址，在函数返回时释放存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFT：从入门到精通</title>
      <link href="/2022/01/26/NFT%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
      <url>/2022/01/26/NFT%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>NFT：从入门到精通</h1><h2 id="前言">前言</h2><p>  事先声明，标题完全是玩梗，全文仅为个人粗浅的理解，欢迎一起探讨~</p><p>  推荐阅读<a href="https://www.yuque.com/nftlabs/ibrmrq">从0到1: 精通 NFT · 语雀 (yuque.com)</a>，本篇也是学习该文档的笔记（不过不是齐全的，忽略了部分我已知的内容）</p><p>  几个月前看到一条推送，歌手林俊杰在社交平台上官宣，自己在虚拟现实平台Decentraland上买下三块虚拟土地，花费12.3万美元。在此之前，粉丝豪掷千金买下了NBA 球星勒布朗·詹姆斯标志性战斧扣篮照片转化成的NFT。也就在今天，人们熟知的奥运合作“专业户”——伊利，也为冬奥会专门推出了”数字牛奶“。这些看起来很赛博朋克的事情就发生在我们所在的世界，而这些虚拟藏品有个统一的名称——Non-fungible Token，aka NFT 。接下来就一起走进NFT的世界吧。</p><h2 id="1-初始NFT">1 初始NFT</h2><h3 id="1-1-什么是NFT？">1.1 什么是NFT？</h3><blockquote><p>NFT，全称为Non-Fungible Token，指非同质化代币，是用于表示数字资产（包括jpg和视频剪辑形式）的唯一加密货币令牌。</p></blockquote><p>在区块链世界中，NFT 代币可以保持所有权记录和真实性证明（换种方式理解，就是一个有了独一无二签名认证的数字物品，虚拟数字世界的房产证）。 NFT 大多存储在合适的数字钱包中，如 MyEtherWallet 和 Ledger Hardware 钱包，在市场上很容易进行定制和交易。</p><p>NFT 不仅存在于数字空间，它们也可以代表任何类型的物理资产，作为一种 “数字孪生”，NFT可以与现实世界中存在的任何东西相连接，并在数字市场上实现实物资产的所有权转手和交易。</p><h3 id="1-2-NFT和FT的区别">1.2 NFT和FT的区别</h3><p><strong>FT</strong></p><blockquote><p>可互换、统一性、可分性、方便性、ERC-20</p></blockquote><p>BTC、ETH 等长期以来交易的加密资产多数是同质化代币。一个比特币和另一个比特币可以交换，尽管序号不同。同质化代币使用起来十分方便，但现实生活中具有实际价值的事物是不可替代的，如一份合同、房屋产权、艺术作品、出生证明等。所以，非同质化代币应运而生。</p><p><strong>NFT</strong></p><blockquote><p>不可互换性、独特性、不可分性、防盗性、ERC-721</p></blockquote><p>与同质化物品不同，非同质化物品或代币彼此之间是不能互换的，它们具有独特的属性，即使看起来相似，但彼此之间有根本的不同。</p><h3 id="1-3-NFT的主要特点">1.3 NFT的主要特点</h3><ul><li>唯一性</li><li>可追溯性</li><li>稀缺性</li><li>不可分割性</li><li>可编程性<ul><li>eg：繁殖机制</li></ul></li><li>所有权</li><li>可转让性</li><li>标准化<ul><li>传统的数字资产并没有统一的表达方式，而通过在公链上显示非同质化资产，开发人员可以构建通用、可重用、可继承的所有非同质化代币标准。这包括基本的原语，如所有权、传输和简单的访问控制。</li></ul></li><li>流动性</li><li>互操作性<ul><li>非同质化代币标准允许 NFT 在多个生态系统之间轻松移动。当开发人员启动新的 NFT 项目时，这些 NFT 可以立即在数十个不同的钱包提供程序中查看，并且可以在市场上进行交易，以及在虚拟世界中显示，因为开放标准为读取和写入数据提供了清晰、一致、可靠和许可的 API。</li></ul></li></ul><h3 id="1-4-NFT的三大协议标准">1.4 NFT的三大协议标准</h3><blockquote><p>ERC-20 协议是以太坊区块链较早的、比较流行的代币规格协议，是同质化代币的协议标准。</p></blockquote><ul><li>ERC-721<ul><li>NFT 项目通常使用 ERC-721 标准来签发 NFT。ERC-721 与 ERC-20 具有相似的属性。两者相似之处在于数字资产信息保存在同一个区块链上，关键区别在于，ERC-721 允许跟踪资产的所有权记录，这些资产都具有独一无二的特点。</li></ul></li><li>ERC-1155<ul><li>与 ERC-20 和其他标准相比，ERC-1155 代币协议标准突出的地方在于它是如何跨链兼容的。</li><li>代币稀缺性。ERC-20 协议中，几乎不存在稀缺性。而 ERC-1155 协议下，资产的销毁可以减少流通量，改善整体的稀缺性，提供了与传统选择不一样的代币协议种类。</li></ul></li><li>ERC-998<ul><li>可合成</li><li>可拆解</li></ul></li></ul><h3 id="1-5-NFT的崛起历程">1.5 NFT的崛起历程</h3><p>从2012年彩色币的诞生，到2021年底NFT火爆全球；历经十年的发展NFT已经不需要依赖于加密市场才能生存，而是可以附身于各个领域，应用在不同场景。随着对NFT可以提供的潜力和价值的了解越来越广泛，越来越多的大品牌、主要投资者和风险投资公司正在关注并参与其中。</p><h3 id="1-6-如何快速成为NFT圈内人？（黑话）">1.6 如何快速成为NFT圈内人？（黑话）</h3><ul><li><p><strong>Reveal</strong>：在新发行的generative project中，艺术品通常不会在NFT被铸造前被真正地创造出来，因此你只有在购入后才能知道你所买的究竟是什么。换句话说，艺术只有在被购买后才会被reveal。</p></li><li><p><strong>LFG</strong></p><p>LFG（Let’s fucking go!）可被理解为“冲冲冲”，常用于表达对新项目启动、NFT新闻要事的激动之情。</p></li></ul><h3 id="1-7-总结">1.7 总结</h3><h4 id="1-7-1-如何购买-NFT？">1.7.1 如何购买 NFT？</h4><p>**这个过程根据使用的平台不同而不同，目前市面上有很多 NFT 交易市场，如 OpenSea，KnownOrigin，Rarible 等等。**比如在 Top Shot 上，你需要先注册加入一个等待名单，名单可能已有数千名 NBA 球迷。一个数字资产发售时，你会被随机选择购买。虽然 Top Shot 既接受美元，也接受加密货币支付，但有些平台只接受加密货币，比如 OpenSea。</p><p>总的来说，常见的一共有四种方法，分别是：</p><p><strong>1. 在各大交易平台上购买有潜力的 NFT 代币；</strong></p><p><strong>2. 购买及出售 NFT 资产；</strong></p><p><strong>3. 成为加密艺术家，发行自己的 NFT；</strong></p><p><strong>4. 质押 NFT 流动性挖矿。</strong></p><p>购买 NFT 概念的代币和购买 NFT 其实是两件事情。如果想要单纯投资 NFT 赛道，你可以在各大交易所上购买到比如 ENJIN, MANA, SAND 等头部 NFT 代币。</p><p>如果你想要参与 NFT 收藏品市场，或者购买出售NFT赚取差价，OpenSea 这样的通用 NFT 市场提供了购买各种 NFT 资产的渠道。此外，还有专门针对加密艺术 NFT 平台，例如 SuperRare 和 Nifty Gateway。</p><h4 id="1-7-2-NFT-主流交易平台有哪些？">1.7.2 NFT 主流交易平台有哪些？</h4><p>OpenSea 是目前全球最大的 NFT 交易平台，成立于 2018 年 1 月。**它涵盖广泛的 NFT 类别、集成了各个平台的 NFT，并以更优惠的价格出售，是目前主流 NFT 玩家使用最多的交易平台。**在交易量方面，OpenSea 排名第一。</p><p>**Rarible 创立于 2020 年，7 月 15 日发布治理代币 RARI，允许 Rarible 上最活跃的创造者和收藏家为任何平台升级投票，并参与管理和审核。**目前平台上有 6932 个收藏家，也算是主流交易平台。在交易者数量方面，Rarible 保持领先地位。</p><p>**SuperRare 专注于交易那些超级稀有的艺术品。**这是一个交易独特数字艺术作品的 NFT 市场。该平台的特点是管理先进、体验简便、付款方式灵活，具有社交档案和移动 APP，可以进行实时拍卖。</p><h2 id="2-NFT的应用场景">2 NFT的应用场景</h2><h3 id="2-1-游戏">2.1 游戏</h3><p>NFT 最早的落地尝试是游戏。基于区块链技术的 NFT 能够记录玩家在游戏内的状态和成就，保存游戏中获得的物品清单。NFT 能够确保记录不可篡改且无缝转移，保证游戏物品的所有权验证和真实性。同时，游戏物品也可以经过设计进行跨游戏使用，或使其具有一定兑换价值！</p><h3 id="2-2-艺术">2.2 艺术</h3><p>艺术家可以拥有自己艺术作品的版权，买家可以确保自己购买的艺术品真实权威，杜绝盗版造假。区块链可以解决所有权证明问题。艺术家不必再依赖第三方来获得作品保护，省去了中间人的媒介，确保艺术家能获得更多的收入。数字艺术的代币化使得创作、交易和从 NFT 获得版税变得更加容易。</p><h3 id="2-3-音乐">2.3 音乐</h3><blockquote><p>NFT 市场有望为音乐迷们打开虚拟收藏品的世界。</p></blockquote><p>**NFT 最初是静态的，但我们已经看到了其从静止图像到循环 gif 以及 mp4 （音频 NFT）的逐步演变。**音频 NFT 除了文件格式外，在技术上与其他 NFT 没有什么不同，都主要是通过融合音频片段与底层图像或视频来实现多维的呈现方式。</p><p>**作品中还包含了专辑中每首作品的以太坊交易信息，并记录了每首 NFT 曲目的铸币过程。 在 NFT 艺术界，一个常见的口号是：「任何人都可以看到它，只有一个人可以拥有它」。**这意味着任何人都可以观看和聆听，但只有一个人可以拥有这些音频 NFT 的所有权。NFT 的这种唯一性对音乐产业有着巨大的魔力。</p><p>随着数字音乐下载在 2000 年开始激增，并演变成今天许多人使用的流媒体平台。但是一旦音乐唱片在互联网上发布，艺术家几乎不可能像音乐产业的早期那样获得收入。**艺术家们正在为生计而挣扎，比以往任何时候都要挣扎。**流媒体虽然是艺术家在疫情期间的主要收入来源，但几乎没有利润可言，在 Spotify 等数字服务提供商（DSP）上，每百万次播放的版税只有几千美元。事实上，音乐收入的 80% 来自巡回演出，但这一收入来源由于疫情的影响而被迅速搁置。种种因素影响下，音乐人缺乏可靠的收入来源，而播放量只会营造新粉丝涌入的数据假象。</p><h3 id="2-4-体育">2.4 体育</h3><ul><li>买票</li><li>收藏品</li></ul><h3 id="2-5-时尚">2.5 时尚</h3><p>知识产权保护。</p><p>越来越多的工具和技术将陆续推出，让设计师和开发者们合作开发虚拟服装材料、版型和可互操的游戏和 VR 时尚资产。</p><h3 id="2-6-所有权证明">2.6 所有权证明</h3><p>NFT 的另一用例是将个人时间或技能货币化，作为对于从事任务以及付出时间的奖励，平台允许他们发行代币化的所有权证明。</p><p>盗版、侵权和抄袭是媒体和娱乐行业面临的重大挑战。NFT 可以利用区块链技术防止欺诈行为，杜绝想法和创意作品的抄袭。</p><h3 id="2-7-身份验证">2.7 身份验证</h3><h3 id="2-8-实体资产记录-保险">2.8 实体资产记录&amp;保险</h3><h3 id="2-9-借贷">2.9 借贷</h3><h3 id="2-10-DAO">2.10 DAO</h3><h2 id="3-元宇宙">3 元宇宙</h2><h3 id="3-1-初始元宇宙">3.1 初始元宇宙</h3><h3 id="3-2-元宇宙的主要特点">3.2 元宇宙的主要特点</h3><h3 id="3-3-元宇宙的驱动力与繁荣基础">3.3 元宇宙的驱动力与繁荣基础</h3>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解计算机系统CSAPP》（一）</title>
      <link href="/2022/01/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/01/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>《深入理解计算机系统CSAPP》（一）</h1><p>  在Github上找到这样两个项目，相信对自学CSAPP的同学会有帮助</p><ul><li><p><a href="https://github.com/EugeneLiu/translationCSAPP">EugeneLiu/translationCSAPP: 为 CSAPP 视频课程提供字幕，翻译 PPT，Lab。 (github.com)</a></p></li><li><p><a href="https://github.com/Exely/CSAPP-Labs">Exely/CSAPP-Labs: Solutions and Notes for Labs of Computer Systems: A Programmer’s Perspective 3rd Editon // 《深入理解计算机系统》第三版的实验文件、解答与笔记 (github.com)</a></p></li></ul><p>  B站视频链接👇</p><p><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=1">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频_哔哩哔哩_bilibili</a></p><p>  笔记主要由书上章节分类，而非课程视频的分集。</p><h2 id="Lecture-01-Course-Overview📝">Lecture 01 Course Overview📝</h2><p>第一节课主要是说明课程大纲</p><blockquote><p>Course Theme：</p><p>  Abstraction is good but don’t forget reality</p></blockquote><p>Great Reality 课程主题</p><ul><li>有限的未组合形式表示在数域中无限扩张的数<ul><li>int加法溢出</li><li>浮点数因为精度有限，不满足加法结合律</li></ul></li><li>理解汇编     intel x86-64</li><li>内存很重要<ul><li>结构的内存连在一起，<strong>内存引用错误</strong>访问到了一些奇奇怪怪的内存，导致段错误</li></ul></li><li>从程序角度提高性能</li><li>复制矩阵的两种方式</li><li>让程序通过网络彼此交谈，实现web服务器这样的服务</li></ul><p>七个lab</p><ul><li>Datalab: Manipulating bits<ul><li>Bits operations, arithmetic, assembly language programs</li></ul></li><li>Bomblab: Defusing a binary bomb<ul><li>Representation of C control and data structures</li></ul></li><li>Attacklab: The basics of code injection attacks<ul><li>Includes aspects of architecture and compilers</li></ul></li><li>Cachelab: Buliding a cache simulator and optimizing for locality<ul><li>Memory technology, memory hierarchy, caches, disks, locality</li><li>Includes aspects of architecture and OS</li></ul></li><li>Tshlab: Write your own Unix shell<ul><li>Hardware exceptions, processes, process control, Unix signals, nonlocal jumps</li><li>Includes aspects of compilers, OS, and architecture</li></ul></li><li>Malloclab: Writing your own malloc package<ul><li>Virtual memory, address translation, dynamic storage allocation</li><li>Include aspects of architecture and OS</li></ul></li><li>Proxylab: Writing your own Web proxy<ul><li>I/O,network programming</li><li>concurrency, concurrent server design, threads</li></ul></li></ul><hr><h2 id="Lecture-02-Bits，Bytes-and-Integer📝">Lecture 02 Bits，Bytes and Integer📝</h2><blockquote><p>需要一些代数的知识储备，群环域等。</p></blockquote><h3 id="信息存储">信息存储</h3><ul><li><p>二进制</p><ul><li>8个bit为Byte（字节）</li><li>计算机有32字长、64字长</li></ul></li><li><p>hex十六进制</p></li><li><p>布尔代数</p><ul><li>And    &amp;</li><li>Or    |</li><li>Not    ~</li><li>Xor    ^</li><li>进行一些位运算，实现掩码运算，比如提取最低有效字节<code>x&amp;0xFF</code>，保留除了最低有效字节以外的字节<code>x&amp;~0xFF</code></li></ul></li><li><p>逻辑运算：&amp;&amp;    ||    ！</p><ul><li><strong>注意</strong>短路 提前终止</li></ul></li><li><p>位移（移动超出位数w时，会mod）</p><ul><li>左移</li><li>右移<ul><li>逻辑右移</li><li>算术右移</li></ul></li></ul></li></ul><h3 id="整数的表示（有符号数和无符号数）">整数的表示（有符号数和无符号数）</h3><ul><li>B2U</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>T</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">B2T_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li>Two’s Complement<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span> - x</li><li>符号位赋值加权的时候是-1，其他都是1</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">Tmin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = [100……00]</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">Tmax_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = [0111……11]</li></ul></li><li>Ones‘ Complement<ul><li>[1111……1111] - x</li></ul></li></ul></li><li>补码和无符号数之间的转换<ul><li>U2T<ul><li>u   u&lt;=Tmax</li><li>u - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span>    u&gt;Tmax</li></ul></li><li>T2U<ul><li>x + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span>  x &lt; 0</li><li>x            x &gt;= 0</li></ul></li></ul></li><li>比较计算<ul><li>如果所有变量都是signed就用signed的计算方式</li><li>如果其中一个变量是unsigned，那么会强制另外一个转换成unsigned（隐式转换）加减乘除赋值都会</li></ul></li><li>经典bug：for循环，i（unsigned）–，小于0的时候跳——会一直循环<ul><li>sizeof函数往往返回unsigned的值</li></ul></li><li>扩展<ul><li>0扩展</li><li>符号扩展</li></ul></li><li>截断<ul><li>无符号数：模运算</li><li>符号数：先和无符号数一样B2U再U2T</li></ul></li></ul><h3 id="整数运算">整数运算</h3><ul><li><p>无符号加法</p><ul><li>溢出</li><li>可交换可结合</li><li>加法逆元：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span> - x</li></ul></li><li><p>补码加法（先使用无符号加法，再转换成补码）</p><ul><li>正溢出</li><li>负溢出</li><li>正常</li><li>加法逆元<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> if x = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>-x  if x &gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li></ul></li><li><p>无符号乘法</p><ul><li>截断，只关心低w位，实际上应该是2w位</li></ul></li><li><p>补码乘法</p><ul><li>截断，得到无符号数，再转换为补码</li><li>当两个比较大的正数相乘会得到负的结果：溢出</li></ul></li><li><p>乘常数</p><ul><li>2的指数幂乘法和左移等价</li><li>2的指数幂除法和右移等价（满足向0舍入）<ul><li><strong>注意</strong>算术右移：向下舍入。我们希望他向0舍入，所以引进bias=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>-1，对于负数，每次移位前先加bias</li></ul></li></ul></li><li><p>无符号数的使用场景：</p><ul><li>模运算、加密算法</li><li>bits用于表示集合而不是数字</li></ul></li></ul><h3 id="内存，指针，字符串的表示">内存，指针，字符串的表示</h3><ul><li>内存是个巨大的字节数组——虚拟内存<ul><li>实际操作是将DRAM、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的数组</li></ul></li><li>word size字长<ul><li>由硬件和编译器共同决定<ul><li>-m32</li><li>-m64</li></ul></li></ul></li><li>Byte Ordering<ul><li>小端序：最低有效字节在前<ul><li>67452301</li></ul></li><li>大端序：最高有效字节在前<ul><li>01234567</li></ul></li></ul></li><li>表示字符串</li></ul><h3 id="浮点数">浮点数</h3><ul><li><p>浮点数二进制分数的表示</p></li><li><p>移动小数点</p><ul><li>向左：更细，范围更少</li><li>向右：更粗，范围更大</li></ul></li><li><p>IEEE floating point</p><p>V = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mo>−</mo><mn>1</mn><msup><mi mathvariant="normal">）</mi><mi>s</mi></msup><mo>×</mo><mi>M</mi><mo>×</mo><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">（-1）^s × M × 2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord cjk_fallback">）</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span></p><p>S：符号</p><p>M：尾数，frac（忽略规格化的1开头）</p><p>E：阶码</p><ul><li><p>规格化的值Normalized</p><ul><li>E = e - Bias<ul><li>e∈（0,255）</li></ul></li><li>Bias = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> - 1</li><li>隐晦地以1开头</li></ul></li><li><p>非规格化的值Denormalized</p><ul><li>e全是0，E = 1 - Bias</li><li>没有隐藏的1</li><li>提供表示0的方法</li><li>存在+0和-0</li></ul></li><li><p>e全是1，frac全是0，是Infinity</p></li><li><p>e全是1，frac不全是0，是NaN。非零值</p></li></ul></li><li><p>几个现象</p><ul><li>分布不均匀，非规格化的数稠密地分布在靠近0的区域</li><li>有些数的间隔是等距的，当e不变，frac变化</li><li>越大的数间隔越大，指数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span>比较大，每次变化量大</li><li>光滑转变</li></ul></li><li><p>一些特殊的值</p><ul><li>0：全是0</li><li>最小正非规格化数：frac = [00……01]，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></li><li>最大非规格化数：frac = [011……1]，1-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></li><li>最小规格化数：e=1，frac=0，M=1</li><li>1：M=1，E=0</li><li>最大规格化数：frac=1-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，M=2-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，e = [1111……10]，E = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> - 2 - （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> - 1）=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1</li></ul></li><li><p>浮点数运算的基本思想(运算后舍入)</p><ul><li>舍入的方法<ul><li>向偶数舍入</li><li>向零舍入</li><li>向下舍入</li><li>向上舍入</li></ul></li><li>二进制的舍入（类似）</li></ul></li><li><p>浮点数的加法（类似十进制加法，如果M≥2，frac右移一位，E＋1；如果M &lt; 1 ，则frac左移1位，E - 1；如果E超出表示范围，发生溢出；如果M超出表示范围，对frac进行舍入）</p><ul><li>是封闭的</li><li>可交换</li><li>0是加法单位元</li><li>几乎所有元素都有逆元（除了Infinity和NaNs）</li><li>但是<strong>不具有结合性</strong>，缺乏最重要的群属性。会舍入，（3.14 +1e10） - 1e10 = 0 而 3.14 + （1e10 - 1e10 ） = 3.14</li><li>单调性</li></ul></li><li><p>浮点数的乘法（类似十进制乘法，如果M≥2，frac右移一位，E＋1；如果E超出表示范围，发生溢出；如果M超出表示范围，对frac进行舍入）</p><ul><li>是封闭的</li><li>可交换</li><li><strong>不可结合</strong>：可能出现溢出和不精确的舍入，比如  1e20 * （1e20 * 1e-20) = 1e20，而 (1e20 * 1e20 )* 1e-20 = INF</li><li>在加法上不具有分配率：可能会出现NaN，比如1e20 * （1e20 - 1e20） = 0 ，而1e20 * 1e20 -1e20 * 1e20 = NaN</li><li>1是乘法单位元</li><li>几乎是单调的（除了Infinity和NaN）</li><li><strong>只要a ≠ NaN，就有a*a ≥ 0</strong></li></ul></li><li><p>C中的浮点数</p><ul><li>float</li><li>double</li><li>强制类型转换<ul><li>int -&gt; float：不会溢出，但是会舍入</li><li>int/float -&gt; double：精准表示</li><li>double -&gt; float：可能会溢出和舍入</li><li>float/double -&gt; int：小数部分截断，向0舍入，<strong><code>float</code>的尾数部分为23字节，比int的32字节小</strong>，所以int可以精确表示float的整数部分，而<code>double</code>的尾数有52位，可能会出现舍入。并且当超过int的取值范围或NaN时，微处理器会指定 [10……00] （字长为w的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>） 为整数不确定值，即对应的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，所以一个很大的浮点数转化为int时，可能会出现负数。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crash Course Computer Science</title>
      <link href="/2022/01/18/Crash%20Course%20Computer%20Science/"/>
      <url>/2022/01/18/Crash%20Course%20Computer%20Science/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Crash Course Computer Science (updating)</h1><h3 id="About-Video">About Video</h3><ul><li>Computers are not magic!</li><li>面向小白的纯科普向视频<ul><li>虽说如此，但是有些知识是我大一一年才学懂的内容，不少内容甚至是之后才会了解的，很多内容理解起来还是有难度的。</li><li>对于其中的一些内容，其实是简化的，一些地方难免会有错误，请不要过度纠结。就好像小学的时候认为最小的数是0一样，只是为了方便理解。包括我的笔记，也难免会有错误，欢迎纠正~</li><li>坚持就是胜利，小姐姐语速有点快，推荐0.75倍速观看</li></ul></li><li>适合即将就读计算机类专业的准大学生or对计算机感兴趣的其他专业有一定基础的大学生</li><li>看完能对计算机专业有个较全貌的认识</li><li>计算机专业学生学英语素材（bushi）</li><li>视频地址 👇<ul><li>生肉（把字幕调成英文即可）：<a href="https://www.youtube.com/watch?v=O5nskjZ_GoI">Early Computing: Crash Course Computer Science #1 - YouTube</a></li><li>熟肉：<a href="https://www.bilibili.com/video/BV1EW411u7th?from=search&amp;seid=5864463258140356263&amp;spm_id_from=333.337.0.0">40集全/精校\ - Crash Course Computer Science_哔哩哔哩_bilibili</a></li></ul></li></ul><hr><h3 id="1E-episode-Early-Computing📝">1E(episode) Early Computing📝</h3><ul><li>计算设备的前身——算盘，进制的概念</li><li>computer曾指一种职业</li><li>步进计算器</li><li>战争，计算，查表<ul><li>差分机</li><li>分析机</li><li>第一位程序员：Ada</li></ul></li><li>美国的人口普查给计算提出了新的要求<ul><li>打孔卡片制表机</li><li>IBM的诞生</li></ul></li></ul><hr><h3 id="2E-Electronic-Computing📝">2E Electronic Computing📝</h3><ul><li>Harvard Mark Ⅰ<ul><li>机械继电器<ul><li>速度慢</li><li>磨损</li><li>“bug”</li></ul></li></ul></li><li>热电子管<ul><li>二极管</li><li>从机电到电子</li><li>巨人</li><li>ENIAC(Electronic Numerical Integrator and Calculator)</li></ul></li><li>晶体管<ul><li>半导体</li><li>硅谷</li><li>Intel</li></ul></li></ul><hr><h3 id="3E-Boolean-Logic-Logic-Gate📝">3E Boolean Logic &amp; Logic Gate📝</h3><ul><li>Binary<ul><li>两种信号</li></ul></li><li>Boolean Algebra<ul><li>NOT</li><li>AND</li><li>OR</li><li>XOR</li></ul></li><li>Logic Gate<ul><li>Logic table</li></ul></li></ul><hr><h3 id="4E-Representing-Numbers-and-Letters-with-Binary📝">4E Representing Numbers and Letters with Binary📝</h3><ul><li>二进制的原理<ul><li>二进制加法</li><li>8-bit ， byte</li></ul></li><li>表示 正负数</li><li>表示浮点数<ul><li>IEEE 754</li></ul></li><li>ASCII</li><li>UNICODE</li></ul><hr><h3 id="5E-ALU——How-Computers-Calculate📝">5E ALU——How Computers Calculate📝</h3><blockquote><p>抽象层的思维</p><p>A NEW LEVEL OF ABSTRACTION</p></blockquote><ul><li>算术单元<ul><li>负责所有的数字操作</li><li>利用Logic Gate——更high level的设计<ul><li>加法<ul><li>半加器（sum：carry）</li><li>全加器（半加器：半加器）</li><li>8-bit ripple carry adder（8位行波进位加法器）<ul><li>慢</li></ul></li><li>Carry-look-ahead（超前进位加法器）</li></ul></li><li>乘法</li></ul></li></ul></li><li>逻辑单元<ul><li>同样利用Logic Gate</li></ul></li><li>更抽象的ALU<ul><li>Input:<ul><li>A, B</li><li>4-bit operation code(alu_src控制ALU进行操作)</li></ul></li><li>Output：<ul><li>Flags：<ul><li>Overflow</li><li>Zero</li><li>Negative</li></ul></li></ul></li></ul></li></ul><hr><h3 id="6E-Registers-and-RAM📝">6E Registers and RAM📝</h3><ul><li>Gated Latch锁存器<ul><li>存一位</li><li>And-OR Latch</li></ul></li><li>Register<ul><li>存8,16,32,64位</li></ul></li><li>16X16矩阵存储256位锁存器<ul><li>2个数据选择器Multiplexer解码8位地址</li><li>4位代表行，4位代表列</li></ul></li><li>8个256位内存共用一个地址，组成DATA，8-Bits</li><li>RAM随机存取存储器<ul><li>8个模块，每个模块有32个内存方块，每个小方块有4个小块，每个小块是128位×64位</li><li>1MB</li><li>就像人类的短期记忆</li></ul></li><li>SRAM——Static</li><li>DRAM——Dynamic</li><li>Flash memory闪存</li><li>NVRAM</li></ul><hr><h3 id="7E-The-Central-Processing-Unit-（CPU）📝">7E The Central Processing Unit （CPU）📝</h3><ul><li>RAM+Register+ALU</li><li>理解IF-ID-EX-MEM-WB（取指令-译码-执行）这个过程</li><li>时钟<ul><li>clock speed</li><li>赫兹</li></ul></li><li>超频<ul><li>提升性能</li></ul></li><li>降频<ul><li>省电</li></ul></li></ul><hr><h3 id="8E-Instruction-Programs📝">8E Instruction &amp; Programs📝</h3><ul><li>指令集——programmable<ul><li>扩充指令集的概念<ul><li>Jump<ul><li>无条件跳转</li><li>有条件跳转</li></ul></li><li>Sub</li><li>Halt</li></ul></li></ul></li><li>现代CPU<ul><li>定长指令集，但是更长</li><li>变长指令集</li></ul></li></ul><hr><h3 id="9E-Advanced-CPU-Designs📝">9E Advanced CPU Designs📝</h3><ul><li>早期加快晶体管切换速度来提升CPU速度</li><li>复杂度 vs 速度<ul><li>上一期除法用软件实现——现在直接在硬件中实现=&gt;使ALU更复杂</li><li>专门电路处理处理器</li></ul></li><li>如何快速传递数据？<ul><li>RAM ——&gt; 快速缓存Cache<ul><li>但是存在Cache和RAM存储内容不一致的问题=&gt;诞生了dirty bit</li></ul></li></ul></li><li>加速CPU：流水线（overlap，把一条指令分成几个阶段stage，每一个clock执行一个阶段，同时每个clock相较于非流水线之前的clock变小了）<ul><li>并行处理<ul><li>会出现一些冒险冲突（hazard）</li><li>乱序执行</li></ul></li><li>跳转冒险<ul><li>推测执行</li><li>分支预测</li></ul></li><li>Superscalar超标量</li></ul></li><li>多核CPU</li><li>多个独立CPU</li><li>超级计算机，神威太湖之光</li></ul><hr><h3 id="10E-Early-Programming📝">10E Early Programming📝</h3><blockquote><p>It’s not magic, it’s computer science !</p></blockquote><p>程序如何进入计算机？</p><ul><li>穿孔纸卡，织布机</li><li>插线板</li><li>冯诺依曼架构<ul><li>穿孔纸卡</li><li>纸带</li></ul></li><li>面板编程</li></ul><hr><h3 id="11E-The-First-Programming-Languages📝">11E The First Programming Languages📝</h3><ul><li><p>Machine code</p></li><li><p>Pseudo-Code</p><ul><li>转换成二进制的机器语言</li></ul></li><li><p>助记符=&gt;汇编器，汇编语言</p><ul><li>隐去不必要的细节，而去做更复杂的事</li></ul></li><li><p>编译器</p></li><li><p>变量</p></li><li><p>早期语言</p><ul><li>FORTRAN</li><li>COBOL</li></ul></li><li><p>新的语言</p></li></ul><hr><h3 id="12E-Programming-Basics-Statements-Functions📝">12E Programming Basics - Statements&amp;Functions📝</h3><ul><li>语句Statements<ul><li>赋值语句</li><li>游戏初始化</li><li>If判断，条件语句</li><li>while循环</li><li>for循环</li><li>函数（power of abstraction）</li><li>库</li></ul></li></ul><hr><h3 id="13E-Intro-to-Algorithms📝">13E Intro to Algorithms📝</h3><ul><li>算法</li><li>Sorting排序算法<ul><li>选择排序</li><li>归并排序</li></ul></li><li>表示算法的快慢<ul><li>Big O Notation</li></ul></li><li>Graph Search<ul><li>Dijkstra算法</li></ul></li></ul><hr><h3 id="14E-Data-Structures📝">14E Data Structures📝</h3><ul><li>Array<ul><li>index</li><li>String<ul><li>null character</li><li>strcat</li></ul></li><li>Matrix</li></ul></li><li>Struct</li><li>Node</li><li>Pointer指针</li><li>Linked List，利用指针不断指向下一个node</li><li>Queue<ul><li>FIFO</li><li>enqueue</li><li>dequeue</li><li>注意：视频中用链表实现，但是也可以用其他方法实现，比如数组</li></ul></li><li>Stack<ul><li>LILO</li><li>push</li><li>pop</li></ul></li><li>Tree</li><li>Binary Tree</li><li>Graph</li></ul><hr><h3 id="15E-Alan-Turing📝">15E Alan Turing📝</h3><ul><li>可判定性问题</li><li>Lambda算子</li><li>图灵机<ul><li>纸带</li></ul></li><li>图灵完备</li><li>停机问题<ul><li>不是所有的问题都可以通过计算解决</li></ul></li><li>可计算理论——丘奇-图灵论题</li><li>破解德军英格玛加密机</li><li>图灵测试</li></ul><hr><h3 id="16E-Software-Engineering📝">16E Software Engineering📝</h3><ul><li>在函数的基础上再一层抽象——打包成objects（对象）<ul><li>封装组件，隐藏复杂度</li></ul></li><li>OOP面向对象编程 Object Oriented Programming</li><li>API Application Programming Interface<ul><li>public</li><li>private</li></ul></li><li>IDE——Integrated Development Environments集成开发环境</li><li>debug调试<ul><li>用双倍写代码的智商去debug</li></ul></li><li>Readme，comment</li><li>版本控制<ul><li>Code Repository</li></ul></li><li>Alpha、Beta</li></ul><hr><h3 id="17E-Integrated-Circuits-Moore’s-Law📝">17E Integrated Circuits &amp; Moore’s Law📝</h3><ul><li><p>回到电子计算机的诞生年代</p><ul><li>分立元件Discrete components</li><li>数字暴政Tyranny of Numbers<ul><li>如果想继续加强电脑性能，会需要更多部件，导致线路更复杂，难做</li><li>将组件集成起来成为新的组件，Integrated Circuits集成电路</li><li>PCB印刷电路板<ul><li>无需焊接或者连线，采用蚀刻金属线的方式连接</li></ul></li><li>光刻法Photolithography<ul><li>晶圆 Wafer</li><li>光刻胶 PhotoResist</li><li>光掩膜 Photomask</li><li>掺杂 Doping</li></ul></li></ul></li></ul></li><li><p>摩尔定律</p></li><li><p>晶体管数量指数级上升</p><ul><li>VLSI超大规模集成用来生成芯片设计</li></ul></li><li><p>摩尔定律即将失效，有2个问题</p><ul><li>光波长到达极限</li><li>量子隧穿效应</li></ul></li></ul><hr><h3 id="18E-Operating-Systems📝">18E Operating Systems📝</h3><ul><li>操作系统的诞生原因</li><li>batch processing批处理</li><li>操作系统负责抽象硬件<ul><li>Device drivers设备驱动程序，和I/O交互</li></ul></li><li>计算机被I/O阻塞——&gt;多任务处理，调度<ul><li>给每个程序分配内存块</li><li>虚拟内存，抽象实际物理位置</li><li>动态分配内存</li><li>实现了内存保护</li></ul></li><li>Time-sharing</li><li>Multics<ul><li>安全</li><li>过于复杂</li><li>失败了，但是影响力巨大</li></ul></li><li>Unix<ul><li>kernel<ul><li>kernal panic</li></ul></li></ul></li><li>MS-Dos</li></ul><hr><h3 id="19E-Memory-Storage📝">19E  Memory &amp; Storage📝</h3><ul><li>memory 易失性</li><li>storage 非易失性</li><li>早起的存储技术<ul><li>纸卡</li><li>延迟线存储器<ul><li>麦克风 传送</li></ul></li><li>磁芯</li><li>磁带<ul><li>寻址很麻烦</li></ul></li><li>磁鼓存储器<ul><li>转</li></ul></li><li>磁盘</li><li>内存层次结构<ul><li>registers &gt; Cache &gt; RAM &gt; Flash,USB memory &gt; Hard Drives &gt; Tape Backup</li></ul></li><li>软盘<ul><li>只是磁盘是软的，其他基本一样</li></ul></li><li>激光盘</li><li>光盘CD<ul><li>表面是坑，导致反光，表示0和1</li></ul></li><li>固态硬盘SSD</li></ul></li></ul><hr><h3 id="20E-Files-File-Systems📝">20E Files &amp; File Systems📝</h3><ul><li>文件格式（底层都是一大堆二进制）<ul><li>TXT<ul><li>ASCII</li></ul></li><li>WAV<ul><li>metadata：关于数据的数据，通常存在文件开头Header</li><li>存储振幅</li></ul></li><li>BMP<ul><li>位图</li><li>像素：红绿蓝RGB</li><li>开头也是metadata，比如颜色深度，图片大小</li></ul></li></ul></li><li>怎么存文件？<ul><li>文件系统</li><li>目录文件：解决多文件问题，存储其他文件的信息</li><li>平面文件系统</li></ul></li><li>文件紧密的排序会造成重叠的问题，解决方法：<ul><li>把空间划分成一块块</li><li>文件拆分存在多个块里。对应的目录文件也会存储。</li></ul></li><li>删除文件<ul><li>没有擦除数据，只是把记录删了，之后会被覆盖，但是在此之前，数据还在原处</li></ul></li><li>文件的增删改查不可避免地造成文件散落——&gt;碎片整理</li><li>数据爆炸——&gt;分层文件系统<ul><li>文件夹</li><li>目录文件还需要指向目录</li><li>需要额外元数据区分文件和目录</li><li>有一个最大的目录文件叫做根目录（root）</li></ul></li></ul><hr><h3 id="21E-Compressing📝">21E Compressing📝</h3><ul><li>压缩的好处：存更多文件传输也更快</li><li>游程编码Run-Length Encoding</li><li>无损压缩Lossless Compressing<ul><li>解压缩后，数据不变</li><li>消除冗余</li></ul></li><li>霍夫曼树，霍夫曼编码<ul><li>最常见的用最简易的表示：按频率排序</li><li>将树用字典编码</li></ul></li><li>”消除冗余“和“用更紧凑的表示方法”这两种方法通常会组合使用<ul><li>几乎所有的无损压缩都用到了他们</li></ul></li><li>感知编码<ul><li>有损音频压缩</li><li>JPEG</li><li>时间冗余：视频，只需要存变化的部分</li><li>MPEG-4：用补丁的移动和旋转来更新画面</li></ul></li></ul><hr><h3 id="22E-Keyboards-Command-Line-Interfaces📝">22E Keyboards &amp; Command Line Interfaces📝</h3><ul><li><p><strong>人机交互</strong>的过程</p><ul><li><p>早期输出是打印在纸上，输入是用纸卡/纸带一次性把程序和数据传入</p></li><li><p>交互式计算机，time-sharing systems</p></li><li><p>现代打字机QWERTY</p><ul><li>转换成本</li><li>十指盲打</li></ul></li><li><p>电传打字机</p></li><li><p>命令行界面</p><ul><li>ls</li><li>cat</li><li>cd</li></ul></li><li><p>screen</p></li><li><p>terminal</p></li><li><p>Zork</p></li><li><p>MUD</p><ul><li>MMORPG</li></ul></li></ul></li></ul><hr><h3 id="23E-Screens-2D-Graphics📝">23E Screens &amp; 2D Graphics📝</h3><ul><li>早期图形计算机：PDP-1计算机，键盘和显示器分开<ul><li>跟踪程序的运行情况，比如寄存器的值</li></ul></li><li>CRT阴极射线管<ul><li>矢量扫描，引导电子束描绘出形状</li><li>光栅扫描，按固定路径，一行行来</li></ul></li><li>液晶显示器<ul><li>也利用光栅扫描</li><li>早期内存不足无法存储像素，转而存”符号“</li></ul></li><li>字符生成器<ul><li>ROM存着点阵图案</li><li>Screen buffer屏幕缓冲区</li><li>但是没有办法绘制任意图形</li></ul></li><li>CRT的矢量模式<ul><li>为了画任意图形，但是又不吃内存</li><li>所有东西由线表示</li><li>早期电子游戏之一——Space-war</li></ul></li><li>Sketchpad，光笔<ul><li>CAD（Computer Aided Design）：计算机辅助设计</li></ul></li><li>位图显示bitmapped displays</li><li>画矩阵函数</li></ul><hr><h3 id="24E-The-Cold-War-and-Consumerism📝">24E The Cold War and Consumerism📝</h3><ul><li>冷战导致美国往计算机领域投入大量资源</li><li>布什预见了计算机的潜力，提出假象机器Memex，帮助建立基金会</li><li>1950年消费者开始买收音机，日本搭上顺风车</li><li>太空竞赛，Nasa预算增加，用集成电路制作登月计算机</li><li>军事应用推动集成电路发展</li><li>美国制造强大计算机也进一步推动了集成电路</li><li>美国半导体行业忽略消费者市场，开始衰败</li><li>消费者购买商用产品继续推动产品发展<ul><li>家用计算机，游戏机</li></ul></li><li>发展由两股力量推动<ul><li>政府</li><li>消费者</li></ul></li></ul><hr><h3 id="25E-The-Personal-Computer-Revolution📝">25E The Personal Computer Revolution📝</h3><ul><li>1970年代初成本下降，个人计算机可行<ul><li>单周期CPU</li><li>磁带和硬盘</li></ul></li><li>Altair 8800</li><li>比尔盖茨和保罗艾伦写Basic解释器</li><li>Apple-I</li><li>三款开箱即用计算机<ul><li>Apple - II</li><li>TRS-80 Model I</li><li>Commodore PET 2001</li></ul></li><li>IBM意识到个人计算机市场，推出IBM PC，IBM 兼容</li><li>苹果选择了封闭架构，一切都自己来，只有苹果在非“IBM兼容”下保持了足够的市场份额</li></ul><hr><h3 id="26E-Graphical-User-Interfaces📝">26E Graphical User Interfaces📝</h3><ul><li>图形界面先驱：道格拉斯·恩格尔巴特</li><li>1970年成立 帕洛阿尔托研究中心</li><li>1973年完成Xerox Alto 计算机</li><li>窗口的隐喻</li><li>一个简单的GUI系统例子<ul><li>创建一个窗口</li><li>事件驱动编程</li></ul></li><li>1981年 施乐之星系统</li><li>复制、剪切、粘贴的隐喻</li><li>所见即所得 WYSIWYG</li><li>乔布斯参观施乐</li><li>1983年推出Apple Lisa</li><li>1984年推出Macintosh，爆卖</li><li>Windows，微软站稳GUI脚跟<ul><li>Micorsoft Bob失败了</li></ul></li><li>现在的GUI界面都是WIMP的变化版，自然选择的结果</li></ul><hr><h3 id="27E-3D-Graphics📝">27E 3D Graphics📝</h3><ul><li><p>3D 投影</p><ul><li>线性渲染</li></ul></li><li><p>正交投影</p></li><li><p>透视投射</p></li><li><p>简单图像直线即可，复杂多边形用三角形（也被称作多边形）</p><ul><li>网格：一堆多边形的集合</li><li>越密越多细节，但是也需要更多计算量<ul><li>需要有个平衡</li></ul></li><li>三角形够简单，能够定义唯一的平面</li></ul></li><li><p>扫描线渲染</p><ul><li>效果比较粗糙</li><li>减轻锯齿的方法：抗锯齿。就像边缘羽化</li></ul></li><li><p>遮挡问题</p><ul><li><p>画家算法，排序算法</p></li><li><p>深度缓冲，速度更快，选择最小值</p></li><li><p>Z Fighting 错误，两个颜色同概率</p></li></ul></li><li><p>背后剔除</p></li><li><p>明暗处理</p><ul><li>表面法线</li><li>平面着色</li><li>其他上色方法</li></ul></li><li><p>纹理映射</p></li><li><p>GPU</p><ul><li>有专用的RAM</li><li>提供并行处理</li></ul></li></ul><hr><h3 id="28E-Computer-Networks📝">28E Computer Networks📝</h3><ul><li>早期的网络<ul><li>早期的计算机和网络并不是绑定的</li><li>球鞋网络</li></ul></li><li>局域网LAN<ul><li>以太网<ul><li>每台计算机需要有唯一的媒体访问控制地址：MAC地址</li></ul></li><li>载波侦听多路访问CSMA：多台电脑共享一个传输媒介<ul><li>C：Carrier载体</li><li>带宽：载体传输数据的速度</li><li>弊端：冲突<ul><li>解决方法：在重新传送之前等待一小段时间（1s+随机时间）（如果再冲突，变成2s，4s，8s）——&gt;指数退避</li><li>减少冲突域，拆分成更小的冲突域。包括互联网也是这样搭建的。</li></ul></li></ul></li></ul></li><li>路由<ul><li>电路交换</li><li>报文交换<ul><li>报文可能很大会堵塞网络</li><li>记录跳数判断是否出问题——跳数限制</li></ul></li><li>分组交换，再拆分，数据包，格式由IP定义<ul><li>IP地址，以点分隔的4组数字，每台联网的电脑需要</li><li>阻塞控制：路由器会平衡与其他路由器之间的负载，确保传输可以快速可靠</li><li>TCP/IP解决数据包到达乱序问题</li></ul></li></ul></li><li>物联网</li></ul><hr><h3 id="29E-The-Internet📝">29E The Internet📝</h3><ul><li>WAN广域网<ul><li>不断地连到更大的区域，到达互联网主干</li><li>Traceroute</li></ul></li><li>IP-互联网协议<ul><li>metadata</li><li>比较低级</li></ul></li><li>UDP-用户数据报协议<ul><li>有header，header里面包括端口号，checksum检测数据是否正确</li><li>如果checksum不一样，数据可能传输中出现了问题，但是UDP不提供数据修复或数据重发的机制</li></ul></li><li>IP负责把数据包送到正确的计算机，UDP负责把数据包送到正确的程序</li><li>TCP-传输控制协议——&gt;TCP/IP<ul><li>保证所有数据必须到达（区别于UDP）</li><li>也有端口和checksum</li><li>有序号</li><li>收到之后需要发一个确认码，表示收到了（ACK）</li><li>确认码的成功率和来回时间可以推测网络的拥堵程度<ul><li>可以调整，也可以解决乱序问题</li></ul></li><li>最大的问题是：确认码数据包把处理的数量翻了一倍</li></ul></li><li>DNS-域名系统<ul><li>把域名和IP地址端口连接起来</li><li>树状结构</li><li>.com,.gov</li></ul></li><li>OSI-开放式系统互联通信参考模型<ul><li>应用程序层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul></li></ul><hr><h3 id="30E-The-World-Wide-Web📝">30E The World Wide Web📝</h3><ul><li><p>万维网是另一层抽象，不同与互联网</p></li><li><p>万维网的基本单位是单个页面</p></li><li><p>超链接</p></li><li><p>为了让网页相互连接，每个网页需要有个专属的地址，叫URL-统一资源定位器</p></li><li><p>HTTP-超文本传输协议</p></li><li><p>HTML-超文本标记语言</p><ul><li>为了区分什么是链接，什么不是链接</li></ul></li><li><p>网页的标记语言</p><ul><li>HTML</li><li>CSS</li><li>JavaScript</li></ul></li><li><p>搜索引擎</p><ul><li>Yahoo</li><li>人工维护的目录不便利</li><li>JumpStation-最早的搜索引擎<ul><li>爬虫</li><li>不断扩张的索引</li><li>查询索引的搜索算法</li></ul></li></ul></li><li><p>网络中立性</p></li></ul><hr><h3 id="31E-Cybersecurity📝">31E Cybersecurity📝</h3><ul><li><p>保密性：只有有权限的人才能读取计算机系统和数据</p></li><li><p>完整性：只有有权限的人才能使用和修改系统和数据</p></li><li><p>可用性：有权限的人应该随时可以访问系统和数据</p></li><li><p>威胁模型分析</p><ul><li>攻击矢量</li></ul></li><li><p>很多安全问题可以总结成两个问题</p><ul><li>who are you？</li><li>what should you have access to？</li></ul></li><li><p>身份认证的三种方式-让计算机知道使用者是谁</p><ul><li>what you know<ul><li>密码<ul><li>暴力攻击</li></ul></li></ul></li><li>what you have<ul><li>基于用户有特定物体</li></ul></li><li>what you are<ul><li>基于你</li><li>生物识别验证器</li></ul></li><li>多因素认证</li></ul></li><li><p>访问控制Access Control</p><ul><li>ACL（List）</li><li>读</li><li>写</li><li>运行</li></ul></li><li><p>Bell LaPadula model 不能向上读取，不能向下写入</p></li><li><p>软硬件必须可信</p><ul><li>我们怎么确定安全程序没有给攻击者留后门？不能确定</li><li>尽管理论是安全，但是仍可能存在bug</li></ul></li><li><p>安全内核Security kernel/可信计算基础：尽可能少的操作，安全性是可以保证的</p><ul><li>最小化代码数量</li><li>验证代码安全性：独立安全检查和质量验证</li></ul></li><li><p>DEF CON安全大会</p></li><li><p>Isolation隔离：当程序被攻破之后尽可能地减少损失</p><ul><li>SandBox</li><li>虚拟机</li></ul></li></ul><hr><h3 id="32E-Hackers-Cyber-Attacks📝">32E Hackers &amp; Cyber Attacks📝</h3><ul><li>社会工程学——通过欺骗他人<ul><li>钓鱼</li><li>假托Pretexting</li><li>木马<ul><li>勒索软件</li></ul></li><li>NAND镜像</li><li>漏洞利用<ul><li>缓冲区溢出：绕过登录，修改内存<ul><li>边界检查：解决缓冲区溢出问题</li></ul></li><li>代码注入：攻击用数据库的网站<ul><li>SQL：sequel，Structured Query Language，一种流行的数据库API</li><li>SQL注入</li><li>有相应的防御措施</li></ul></li><li>零日漏洞</li><li>蠕虫</li><li>僵尸网络</li><li>DDoS</li></ul></li></ul></li></ul><hr><h3 id="33E-Cryptography📝">33E Cryptography📝</h3><ul><li>多层防御</li><li>加密-Encryption</li><li>解密-Decryption</li><li>加密算法-cipher</li><li>凯撒加密</li><li>替换加密<ul><li>把每个字母替换成另外一个字母<ul><li>E的出现频率最高</li></ul></li></ul></li><li>移位加密<ul><li>列移位加密</li></ul></li><li>德国Enigma加密机<ul><li>多个替换加密</li><li>还是一一映射，不过映射会随每次按键而改变</li></ul></li><li>加密慢慢从硬件转为软件</li><li>1977年数据加密标准DES<ul><li>随着算力的提升，逐渐被淘汰</li></ul></li><li>2001年高级加密标准AES<ul><li>使用更长的密钥</li></ul></li><li>密钥交换<ul><li>加密算法需要知道密钥，但是发送密钥存在安全风险，于是就有了密钥交换这个算法</li><li>不发送密钥但是依然让两台计算机在密钥上达成共识的算法</li><li>单向函数，逆过程很难</li></ul></li><li>Diffie-Hellman密钥加密<ul><li>双方用一用的密钥加密和解密信息，叫对称加密</li></ul></li><li>非对称加密<ul><li>有两个不同的密钥，公钥，私钥</li><li>用公钥加密，只有私钥的人才能解密；公钥只能加密而不能解密</li><li>反过来也可以，用私钥加密，用公钥解密<ul><li>数字签名</li></ul></li><li>非对称加密算法RSA</li></ul></li></ul><hr><h3 id="34E-Machine-Learning-Artificial-Intelligence📝">34E Machine Learning &amp; Artificial Intelligence📝</h3><ul><li>机器学习的本质<ul><li>根据数据做决定</li><li>从数据中学习，自行做出预测和决定</li></ul></li><li>分类<ul><li>分类器：做分类的算法</li></ul></li><li>特征，帮助分类</li><li>标记数据<ul><li>散点图数据可视化</li><li>找出最佳区分——机器学习</li></ul></li><li>决策边界</li><li>混淆矩阵</li><li>两个目标<ul><li>最大化正确，最小化错误</li></ul></li><li>未标签数据</li><li>决策树<ul><li>选择用什么样的数据去区分</li><li>随机森林</li></ul></li><li>支持向量机<ul><li>找到最好的线区分特征</li></ul></li><li>人工神经网络<ul><li>神经元</li><li>激活函数<ul><li>tanh</li><li>Relu</li></ul></li></ul></li><li>深度学习<ul><li>人脸识别</li><li>开车</li><li>翻译</li><li>诊断医疗状况</li></ul></li><li>弱AI：只能做特定任务</li><li>强AI</li><li>强化学习</li></ul><hr><h3 id="35E-Computer-Vision📝">35E Computer Vision📝</h3><ul><li>RGB<ul><li>颜色追踪算法</li><li>需要环境严格</li></ul></li><li>检测垂直边缘的算法<ul><li>灰度图减少计算量</li><li>核/过滤器</li><li>卷积</li><li>垂直边缘的像素值很高<ul><li>使水平边缘和垂直边缘像素增强的核叫Prewitt算子</li></ul></li></ul></li><li>维奥拉·琼斯 人脸检测</li><li>卷积神经网络CNN</li><li>进一步用其他算法定位面部标志 情感识别算法</li><li>生物识别</li><li>跟踪全身的标记点，识别动作</li></ul><hr><h3 id="36E-Natural-Language-Processing📝">36E Natural Language Processing📝</h3><ul><li><p>让计算机拥有和人类一样的能力</p><ul><li>NLP</li></ul></li><li><p>怎么把一句话拆分成几块</p></li><li><p>词性</p></li><li><p>短语结构规则——来代表语法</p></li><li><p>分析树</p></li><li><p>知识图谱</p></li><li><p>人工智能客服</p></li><li><p>语音识别</p><ul><li><p>波形</p></li><li><p>谱图</p></li><li><p>快速傅里叶变化FFT——波形到频率的转换</p></li><li><p>音素</p></li></ul></li><li><p>语音合成</p><ul><li>让计算机输出声音</li></ul></li></ul><hr><h3 id="37E-Robots📝">37E Robots📝</h3><ul><li>机器人是由计算机控制，可以自动执行一系列动作的机器<ul><li>外表不重要</li></ul></li><li>CNC机器，数控机器</li><li>Unimate，第一个商业贩卖的可编程工业机器人</li><li>简单控制回路</li><li>负反馈回路<ul><li>感应器</li></ul></li><li>PID控制器：比例-积分-微分控制器<ul><li>根据实际速度和理想速度，算出三个值<ul><li>比例值：实际值和理想值相差</li><li>积分值：一段时间内误差的总和，帮助弥补误差</li><li>导数值：期望值和实际值之间的变化率<ul><li>预期控制</li></ul></li></ul></li></ul></li><li>无人驾驶</li><li>类人机器人</li><li>军事机器人</li><li>机器人三定律，阿西莫夫三定律</li></ul><hr><h3 id="38E-Psychology-of-Computing📝">38E Psychology of Computing📝</h3><ul><li>我们需要了解人类心理学，做出更好的计算机</li><li>易用性</li><li>颜色强度排序 和 颜色排序<ul><li>人类擅长颜色强度排序但是不擅长颜色排序</li></ul></li><li>人类分组更好记</li><li>直观功能（认出与回想）<ul><li>用人类的直接感受去设计</li><li>用感觉来出发记忆会容易很多，比如用图标代表功能</li></ul></li><li>让机器人有情商，根据用户的状态做出合适的反应</li><li>以计算机为媒介的沟通——CMC<ul><li>同步在线沟通</li></ul></li><li>凝视<ul><li>增强凝视，让视频通话看起来像盯着对方，而不是盯着下方</li></ul></li><li>人机交互HRI/HCI（Human-Robot/Computer Interaction）</li><li>恐怖谷效应</li></ul><hr><h3 id="39E-Educational-Technology📝">39E Educational Technology📝</h3><ul><li>计算机对教育的影响</li><li>通过调速、暂停等技巧，加强学习效率</li><li>Mooc大型开放式在线课程-Massive Open Online Courses</li><li>智能辅导系统<ul><li>机器打分</li><li>个性化推荐</li></ul></li><li>判断规则</li><li>域模型：判断规则+选择算法<ul><li>不记录进程</li></ul></li><li>贝叶斯知识追踪<ul><li>学生已经学会的概率</li><li>瞎猜的概率</li><li>失误的概率</li><li>做题过程中学会的概率</li></ul></li><li>自适应式程序</li><li>教育数据挖掘</li><li>未来的教育<ul><li>AR/VR</li><li>AI</li></ul></li></ul><hr><h3 id="40E-The-Singularity-，Skynet-，and-the-Future-of-Computing📝">40E The Singularity ，Skynet ，and the Future of Computing📝</h3><ul><li><p>普适计算——万物互联，计算机融入生活</p></li><li><p>人工智能在未来会有重大进步，但不是所有都要AI</p><ul><li>人工智能是否会超过人类呢？</li><li>还有很长的路要走</li><li>目前衡量只能是用“处理能力”来比较</li><li>人工智能自己改造自己</li></ul></li><li><p>智能科技的失控性发展叫“奇点”</p></li><li><p>自动化——&gt;技术性失业</p></li><li><p>工作四象限，按手工/思维，重复/非重复性，创造性的来分。自动化带来的影响</p><ul><li>重复性手工被替代了</li><li>非重复性手工和重复性思维正在被部分替代</li></ul></li><li><p>改造人</p></li><li><p>脑机接口</p></li><li><p>数字永生——数字人</p></li><li><p>机器人的存在时间会长于人类，可以长时间探索宇宙</p></li><li><p>VR和AR，无人驾驶车，无人机，可穿戴计算机</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么开始写博客？</title>
      <link href="/2022/01/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/01/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="为什么开始写博客？">为什么开始写博客？</h2><p>  很简单的一句话回答就是，<strong>我总是试着输出一些什么</strong>。无论是blog、视频、代码都好。因为只是埋头看课只是自我欺骗，听课是最廉价的一种学习手段，打开电脑，就在那放着，你可以什么都不做，好像自己学到了很多，但其实不然。而写blog的一个初心便是给自己一块自留地，让自己尝试输出一些东西。还有一方面是，希望能在这里记录自己的技术成长路线以及留下些或许可以帮助到大家的记录，造福一下后人。有一些朋友听说我在搭博客的时候，一点不意外，说这就是我会做的事情，想来也确实，我就是这样的人，搭博客好像没有什么理由，是理所当然的一件事情。</p><p>  这个寒假的自学打算</p><ul><li>因为学籍异动的原因，我下学期需要补上线性代数Ⅱ（H），正好人工智能基础让我彻底觉得大一的线代上的跟没上没什么区别，寒假就打算看吴志祥老师的智云补补课<a href="https://classroom.zju.edu.cn/livingroom?course_id=30014&amp;sub_id=436725&amp;tenant_code=112&amp;room_id=315&amp;sub_public=1">线性代数Ⅰ（H）2021-09-15第1-2节 (zju.edu.cn)</a></li><li>大二秋冬一直有在看<em>MIT 6.S081: Operating System Engineering</em>,这个寒假有继续看下去的打算，不过会看实际情况调整</li><li>想把《深入理解计算机系统》（CSAPP）这本书好好看一下</li><li>把一直想看的<em>MIT-Missing-Semester</em>追完</li><li>看实际情况调整，可能会看一下<em>CS50: This is CS50x</em>或者<em>CS61A: Structure and Interpretation of Computer Programs</em></li><li>对crypto、NFT、web3.0进行更深入的研究</li></ul><p>  自学的记录我也会在博客同步更新的，就像我说的那样，输出一些什么。</p><hr><p>  我只喜欢一类人，他们生活狂放不羁，说起话来热情洋溢，对生活十分苛刻，希望拥有一切，他们对平凡的事不屑一顾，但他们渴望燃烧，像神话中巨型的黄色罗马蜡烛那样燃烧，渴望爆炸，像行星抨击那样在爆炸声中发出蓝色的光，令人惊叹不已。</p><p>                            ——杰克·凯鲁亚克《在路上》</p>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二秋冬：计算机和解</title>
      <link href="/2022/01/15/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E5%86%AC/"/>
      <url>/2022/01/15/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E5%86%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>前言</h1><p>  写总结这事的起因还得说到这个学期的一门课，翁恺老师的《面向信息技术的沟通技巧》。刚好这个学期想聊的东西还挺多的，就打算督促督促自己，进行一个总结的写。以下的每个课程都会分为课程简介、关于期末（资料汇总点这👉<a href="https://gitee.com/RyanFcr/is_-course-resource/tree/master">RyanFcr/IS_CourseResource - 码云 - 开源中国 (gitee.com)</a>）</p><p>  话不多说，开启正文！</p><p>（以下内容出现在这里纯属二进制 bit 的随意组合，与本人毫无关系咳咳 👀）</p><hr><h1>专业课</h1><h2 id="面向信息技术的沟通技巧">面向信息技术的沟通技巧</h2><h3 id="课程简介">课程简介</h3><ul><li>先修要求：C 程（<strong>划重点</strong>），<s><em>大腿的识别与接近</em></s></li><li>编程语言：C</li><li>课程难度：🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>主要内容分为</p><ul><li>个人观点表达</li><li>团队有效沟通</li><li>文献检索与有效阅读</li><li>技术文档写作</li><li>如何”卷“好一次展示</li></ul><p>  沟通技巧是我上的翁恺老师的第一门课，第一节课上完之后直呼不愧是网红老师（bushi）。不过不仅仅是因为老师，更是因为这门课本身。沟通技巧是我认为每一位计院学子必上的一门课，而且越早上走的弯路越少。对于我来说，真的学到不少东西，尤其是在文献阅读这一块，让我发现我之前的科研简直是 🤮。但是相应的，投入时间也是比较多的，当然投入越多，收获越大。相信对于这门课的评价一定是两极分化的，不喜欢的同学会觉得耗费时间太多，非常痛苦。</p><p>  沟通技巧是一门有小组作业的课，所以你懂得，需要精准掌握大腿的识别与接近技巧（bushi），不过无论如何，提前找好靠谱的朋友一起组队真的会无限倍提高该门课的体验！平时成绩比较重要，会有小测和课上讨论，而且需要当场提交，上课时间战线很长。</p><h3 id="关于期末">关于期末</h3><p>  期末主要分成选择题和主观题，考前可以刷一下历年卷。我们当时主观题的考察内容</p><ul><li>评价毕业设计论文</li><li>根据英文论文写中文概要</li><li>给大一的小朋友写技术文档，我们写的是 gcd（需要 C 的基础）<ul><li>原理</li><li>源码</li><li>代码如何实现等</li></ul></li></ul><p>  主观题有一个很大的问题是机房的电脑，输入法没有搜狗的，和我们平时用的不一样，打字很费力，费时，考试时间没有我们想象的那么充裕。</p><hr><h2 id="概率论-H">概率论 H</h2><h3 id="课程简介-2">课程简介</h3><ul><li>先修要求：数分 Ⅰ，数分 Ⅱ</li><li>编程语言：无</li><li>课程难度：🌟🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟</li></ul><p>  不同与概统，概率论 H 主要开给统计、图灵班和公管英才班的同学，而内容也主要针对<strong>概率论</strong>，但是相较于概统，概率论的内容讲的更深更难，没有数理统计的内容。而图灵班的同学之后并无数理统计的课程，我觉得培养方案的设计还是有待商榷的，尽管概率论的学习内容更深，但是缺少了数理统计的知识导致我们在“人工智能基础”这门课需要重新自学数理统计的知识，扯回来。</p><p>  我当时的老师是庞天晓老师，教学水平和老师的人品都有目共睹。没有点名。唯一的缺点是每次上课刚开始可以短暂的复习一下之前学过的内容，直接进入正题会出现学生跟不上的情况（没错就是我）。</p><p>  一些感悟，学概率论的时候发现自己大一数学的功底打的太差了，总是需要不断地去复习之前学的内容，是自己之前没有用心学导致的（面壁思过）。呜呜呜呜这个学期还是很认真学了概率论，可惜考试寄了，两位老师都比较求是，所以很看重考试，大家考试一定要加油捏。</p><hr><p>  成绩出来没想到概率论竟是这学期最低寄点，也是这么多数学课的最低寄点 ww</p><h3 id="关于期末-2">关于期末</h3><p>  期末是标准的四个单元，每个单元各出两题，更偏计算，证明不多，我们当时计算量直接裂开，<strong>记得带计算器！</strong></p><hr><h2 id="数据结构基础">数据结构基础</h2><h3 id="课程简介-3">课程简介</h3><ul><li>先修要求：C 小程、C 大程（或者程算）</li><li>编程语言：C</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟</li></ul><p>  这门课是计院学生最重要的专业课之一。也是我这个学期收获最多的几门课之一。我是找计院老师补的陈越姥姥的课，真的可以说姥姥 yyds！姥姥是唯一一位全英文授课 DS 的老师，但是课程内容丝毫不含糊，而且简单易懂。如果上课没听懂的同学，也可以选择直接看姥姥的 mooc 或者知乎、CSDN 查一下知识点。</p><p>  值得一提的是姥姥严格的<strong>查重制度</strong>和 DS 的<strong>互评机制</strong>，一旦被发现，直接取消考试资格。这也间接性地督促我自己独立思考，尽管每次码代码和 debug 的过程异常痛苦，但是能够感受到自己在不断变强，也在自己羸弱的代码基础巩固巩固；互评，个人认为是一个很好的学习他人经验的方式，并且让我们在学校就能接触到最严格的审稿制度。</p><p>  平时上课会有三次随机小测，一般老师都会提前说，在开课前十分钟测，所以千万不要迟到，占平时分比重挺大的！小测抄别人是没有用的，因为大家题目不一样，但是原理是一样的，只是变动数据，所以最重要的当然是自己要理解，做错没事，关键是得学会知识。</p><p>  一些感悟，DS 真的是我这学期最波折的一门课，回想上学期末选课的时候，尽管姥姥是所有 ds 里面唯一的全英教学班，尽管陈越姥姥的查老师风评有很大的争议，但还是听了学长学姐的建议之后，毅然决然地直接从何钦铭班润到了陈越班。开学初的 hard 考试直接没去，因为知道自己就算去了，也只能干坐着。开学后的每一节课，尽管理解有难度，但是每节课都在快速成长，ds 也成了我这个学期唯一一门从未缺席任何一节课的课。Project 一波三折，第一次 Project 忘记 ddl，最后一小时才发现，最后交了个代码；第三次 Project 写完，但是互评没有交上去，直接原地裂开。一大半的平时分就无了，但是这也警醒了自己不要总是对自己掌握时间的能力太过自信，尤其是不要拖 ddl。我也因此立下了 flag，好好学 DS，最终功夫不负有心人，取得了意想不到的成绩。</p><h3 id="关于期末-3">关于期末</h3><p>  尽管在期末之前刷了很多的历年卷，但是考试了之后发现，难度完全不是一个量级，主要体现在判断和选择，填空和函数其实还好。</p><p>  DS 的知识点比较散，考之前很建议近几年的历年卷都刷一遍，进行一个面向历年卷的复习，查漏补缺。</p><p>  做历年卷的时候一个意外发现：每个人期末卷子是不完全一样的，一些题目会修改一点点</p><p>比如</p><ul><li>at most 和 at least</li><li>mul 和 add</li></ul><p>  为了公平，会尽量难度相似，所以会在一些可以出两个的地方出题，这也需要我们更细心地看题目</p><p>比如</p><ul><li>kruskal‘s Algorithm</li><li>prim‘s Algorithm</li></ul><p>  当然也可能一个题目，里面的数据不一样，但是原理是一样的，比如 minheap 转 maxheap 等等</p><hr><h2 id="计算机系统-Ⅱ">计算机系统 Ⅱ</h2><h3 id="课程简介-4">课程简介</h3><ul><li>先修要求：计算机系统 Ⅰ</li><li>编程语言：C,risc-v 指令集</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>  先向对不熟悉这门课的同学介绍一下这门课吧，计算机系统 Ⅰ、Ⅱ、Ⅲ 是计院课改之后将原有的数字逻辑设计、计算机组成、计算机体系结构、操作系统四门课合并之后的系列课程。主要小范围面向信安专业的同学开设，从大一春夏开始上系统 Ⅰ，三学期上完计算机系统。</p><p>  系统 Ⅱ 主要是分为两方面，期中之前接着系统 Ⅰ 的单周期 CPU 继续做了多周期的流水线以及冲突，简单拓展了一些其他技术，比如多发射、超标量、超长指令字等。期中之后，就开启了操作系统的学习，主要分为三块，简单了解操作系统、进程和线程的概念以及调度、同步死锁问题。除此之外，在实验中学习并熟悉了包括 wsl、docker、qemu、gdb、Cli 在内的工具，不断强化自己的武器库。</p><p>  这个学期的感受完全和上学期不一样，系统 Ⅰ 是什么都不知道，完全跟着 TA 做实验，不知道原理，不知道我们要做什么，甚至是实验课才把理论学会；这个学期是自己有了一定的理解，在理论课的基础上，进行实验课的设计，自己有目的性的做实验，同时不再只是盲目的尝试试错，而是有自己的理论设计，再由实验结果来反推，debug 的过程也不再像之前那样毫无头绪，减少了很多痛苦。我也慢慢地理解了老师说的计算机设计平衡的意思。</p><blockquote><p>计算机总有一种方法，是最简单和最理想方式的妥协</p></blockquote><p>  整个学期的体验都非常棒，无论是从理论课还是实验课。这个学期的实验课直接用 Mkdocs 生成了静态网站，已经有点国外 MIT 课的味道了，逼格一下子上来了。本学期的任课老师卢老师和申老师水平确实很高，zyTA 和 zbTA 是全世界最好的 TA，期待下学期的系统 Ⅲ。</p><h3 id="关于期末-4">关于期末</h3><p>  期末和上学期一样，可以带一张 cheeting sheet，但其实内容不多，也没什么好抄在上面的。期末题型不变，题目较简单，大多是课上提到的内容拿出来考考，只要这个学期不摆烂，实验认真做了，基本上没什么问题。</p><blockquote><p>申老师经典语录：“我们都很 nice 的。”</p></blockquote><p>  结果班上有同学五十分钟就做完走人了 🤣</p><hr><h2 id="人工智能基础">人工智能基础</h2><h3 id="课程简介-5">课程简介</h3><ul><li>先修要求：无</li><li>编程语言：python</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>  人工智能基础这门课是专门开给图灵班的，课程难度非常大，先修要求虽然无，但是很多理论推导设计到了大量高深的线性代数和数理统计内容，尤其是数理统计我们还没学。课程内容很多，包含了</p><ul><li>逻辑与推理（知识图谱、因果推理）</li><li>搜索（A*启发式搜索、最小最大搜索、Alpha-Beta 剪枝、蒙特卡洛树搜索）</li><li>机器监督学习（回归分析、决策树、Ada Boosting、支持向量机、生成学习）</li><li>无监督学习（聚类算法、主成分分析、特征人脸识别、EM 算法）</li><li>深度学习（前馈神经网络、CNN、RNN 包括 LSTM，GPU、深度生成学习 GAN）</li><li>强化学习（马尔科夫决策、基于价值的强化学习、时序差分、动态规划）</li><li>人工智能博弈</li></ul><p>  课程基本上把人工智能都介绍了一遍，不过个人感觉还挺好的，充分让我们了解了一下现在人工智能的几个大方向，如果有兴趣的同学可以自行进行深入研究。不过平时学的东西，老师讲的很累，我们听得也比较累，主要还是内容太多太难，不过好在老师和我们彼此反馈，不断地在调整。实验课的lab比较多，总共是7+1bonus，虽然多，但大多数的框架都已经给出，实验的目的也是帮助我们理解课程内容，对于实验，个人的收获提升的还是很多的。当然，会有人说“AI一个project几百行代码大部分都是助教帮你写好的，最后垃圾识别分类和机器人走迷宫不就是调调参数，能学到什么？”。此言差矣，作为一个刚刚接触Python、AI的小白来说，这样完善的代码结构既可以让我们快速上手，理解课堂中的核心知识点，又给了我们“才几周就可以做出来这么棒的东西”很大的成就感，尽管更多的是理解Ta写的代码，但是能够阅读别人高质量的代码，又何尝不是一种提升呢？</p><h3 id="关于期末-5">关于期末</h3><p>  虽然学的内容多，不过好在考的范围和难度都比较和善，但是考试比较细节，较基础。我是黄正行老师和况琨老师班上的，黄正行老师我真的哭死，太好了，他真的太懂我们了，最后一节课直接进行了一个大纲的划，这四十分钟救了全班的命。Btw，最后一节课老师还和我们扯了他读书时候因为看演唱会而挂科的故事 🤣，他以前读书都是平时不用功，考试周每天熬夜，他只希望我们在他这门课上能够不熬夜，还说如果考完觉得不对劲，赶紧联系他进行一个分的调。考完还带着隔壁班进行一个调分，调成了均分 89 的正态分布。他太懂我们了，我真的哭死。</p><hr><h1>类专业课</h1><h2 id="普通物理学-Ⅱ（H）">普通物理学 Ⅱ（H）</h2><h3 id="课程简介-6">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>  之前对于普物的评价是，普物浪费了我一年的时间。选择这个专业也有部分原因是工科中最不用学物理的专业就是计算机类，而我自己对物理简直是深恶痛绝。普物 Ⅰ 和 Ⅱ 都是只有一个目标：不挂。</p><p>  但是很幸运的遇到了我普物 Ⅰ 和普物 Ⅱ 的老师，普物 Ⅰ 的老师潘正权的普物就是高中物理的升级版，他的考试不像物理竞赛，不会和你拐弯抹角，考什么很奇怪的点。而是简简单单的考察知识点，而且全是考 PPT 原题，只要你上课真的认真听了，作业是自己做的，不会太差。整个学期我也没有上的很痛苦。普物 Ⅱ 的老师是万歆老师和 llk 老师，普物 Ⅰ 还是中英双语，到了普物 Ⅱ，就真的是全英文，不过我意外的很喜欢万歆老师的风格，他的作业和考试也不会去扯那些怪题难题，讲课很有逻辑，慢慢地带我们去揭开物理现象背后的本质以及联系，包括万歆老师最喜欢的量子力学，我从没想过自己居然会对物理感兴趣，甚至想选万歆老师下学期的量子力学课，最终还是放弃了这个危险的想法。尽管是全英文，但是老师上课讲的都不是很难，你只要上课花时间听讲，作业认真做，完完全全是可以跟上的。</p><p>  普物完全不需要看书（书又臭又长还是全英），只要看 PPT 就行，仅针对潘正权老师的普物 Ⅰ 和万歆老师、llk 老师的普物 Ⅱ。</p><p>  我觉得潘正权老师和万歆老师非常适合初学者，无论你是只想水水过物理还是对物理感兴趣但是基础差。pzq、wx，我的超人！</p><h3 id="关于期末-6">关于期末</h3><p>  万歆老师和 llk 老师班上的期中和期末都是五道探究题，按老师自己的说法是，五个故事，我们根据五个故事来作答，每道题差不多都有几道小题，小题严格遵循先易后难原则，原则上你只要做出最简单的题目，就可以拿到三分之二的分数，考出来的成绩也如老师预期一样自然成正态分布。所以想水水过的同学只需要掌握最基础的即可。</p><p>  同时我的普物 Ⅰ 和普物 Ⅱ（其他班不一定如此，尤其是普物 Ⅱ，三个老师单独出卷），期末考试的范围都不包含期中考试考查的内容，非常适合补天人。</p><p>  万歆老师尤爱量子力学，期末题型三道量子力学两道光学。其他班基本上不考察量子力学。</p><hr><h2 id="普通物理学实验-Ⅱ">普通物理学实验 Ⅱ</h2><ul><li>先修要求：普物实验 Ⅰ</li><li>编程语言：无/有些项目也要求掌握 python、matlab 等</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟</li></ul><p>普物实验 Ⅱ 有三种选择</p><ul><li>做 14 周小实验</li><li>做 7 周小实验+7 周科创实验</li><li>做 14 周科创实验</li></ul><p>  普物实验 Ⅱ 第一步就是要选实验，选实验的好坏直接决定了这个学期的痛苦程度。选实验这个，大家都懂了，纯靠手速，而且物理实验那个网站非常差，经常奔溃。所以大家要有所准备，我当时提前五分钟进入网站，在倒计时 30s 的时候刷新，结果就卡了一分钟，不过还算好，进去之后只有陈水桥老师的科创实验被选光了，我眼疾手快，选择了郑远老师的”真空实验的设计与研究“。说实话，我一开始对普物实验 Ⅱ 的定位就是，这门课对我帮助不大，赶紧进行一个大腿的识别和靠近，水过去就完事了，况且自己这物理水平，实在是不敢恭维。好在老师和队友们都太靠谱了，就让我这门课的体验非常好，在课程结束之后，还跟着郑远老师一起在做“真空实验+深度学习识别”有关的课题，体验非常好。</p><hr><h2 id="军事理论">军事理论</h2><h3 id="课程简介-7">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟🌟</li><li>花费时间：🌟</li></ul><p>  我是预置的吕强老师，吕强老师上课幽默风趣，不过我上课基本上都在干自己的事情，最后也只是水水过了。不过对于军事感兴趣的同学，大可以享受到和老师交流碰撞的乐趣，上课的内容除了中间军事技术的三节课，其他基本上和考试关系不大，更多的是历史、故事，感兴趣的同学也不妨听听。Btw，之后的军理课好像改版了，这里的建议仅供参考。</p><h3 id="关于期末-7">关于期末</h3><ul><li><p>准备资料：</p><p>目录、领导人强军资料、精简版军事技术部分 PPT、书即可。</p></li></ul><p>  个人的建议是首先把题目区分成和领导人有关的和书有关的内容，先把有关领导人强军思想的题目给做完。而对于其他题，对于开卷考，需要考虑的是速度和准确度的平衡。我的方法是先进行定位，然后找目录，对于军事技术部分先参考 PPT，找不到再统一找书。</p><hr><h2 id="马克思主义基本原理概论（H）">马克思主义基本原理概论（H）</h2><h3 id="课程简介-8">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟🌟</li><li>花费时间：🌟🌟</li></ul><p>  我上的是吴旭平老师的马原 H，上这么课之前，阅读过 yay 学长的文章<a href="https://www.cc98.org/topic/5137370">一个计院学生的大二春夏：数学、计算机及其他 - CC98 论坛</a>（需要校网），本来自己在上马原之前对马克思主义完全是不了解的状态，自己也希望通过这门课来构建自己对马克思主义的简单了解以及搭建自己的哲学框架。 我就降低了自己的期待值。一个学期上下来，老师上课很有趣，延伸的内容还挺有意思的，虽然和考试无关，但是我记了近半个学期的笔记，现在拿出来看看，有一些观点还是很有启发的。（别问为什么半个学期，后面半个学期都在补其他课的天）。网课期间，老师也秀了自己的猫猫“康德”，看得出来老师也很喜欢我们班。总体上课体验挺好，唯一有点难受的是老师不允许打开电脑，让我有点难受，本来是电脑记笔记的，被强行改成了手写笔记。</p><h3 id="关于期末-8">关于期末</h3><p>  平时分只有辩论输了还没有发言的同学才不会满（比如我），无正态。吴旭平老师的平时分有很多加分项，只要你想满，卷一卷还是很容易就拿满的。不过马原期末有斩杀线，所以还是有点慌的。考试周一开始就先进行了一个面向历年卷的拟合，不过后来发现很多都是无效训练，在对内容知识不了解的情况下的训练，最终训练出来的我，十道题能错五六道。只得重新认真看书，一边看书，一边做题拟合，选择题都考的比较细，可以先粗粗的过一遍所有知识点，再根据题目进行翻书复习。</p><blockquote><p>出分之前，平时分都没满，摆了摆了，不挂就行</p><p>出分之后，呜呜，老师给分太好了！</p></blockquote><hr><h2 id="新制度经济学">新制度经济学</h2><h3 id="课程简介-9">课程简介</h3><ul><li>先修要求：无严格要求，但修过经济学课程更好</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟</li></ul><p>  新制度经济学是我严格意义来说的第一门和经济有关的课，尽管我对经济学很感兴趣，但是在此之前，从未系统的对经济学有过深入详细的了解，只是感兴趣。很感谢新制度经济学这节课给我这个机会去了解经济学，最大的收获是思维上的提升，无论是课上的内容还是讨论课的延伸，很多生活上的问题，我逐渐学会从经济学的角度去思考问题，经济学也并没有我想象的那么功利，那么无聊。</p><p>  个人经过一个学期上下来，感觉内容确实过多，较充实，不过也存在着总是老师讲，比较枯燥无聊的问题，可以考虑适当删减内容，以放缓节奏；同时在理论课不再是单纯的讲解，加入互动，互动回答好的实行奖励政策，如一道苹果计算题等，让同学们更融会贯通。</p><p>  我之前没有上过通核，也没有讨论课。整体来说，这个学期的讨论课可以说是我的一个避难所，上了一天的课比较累，来讨论课聊聊天，一个讨论教室里同学们的观点都很有意思，讨论的话题也比较新颖有趣。</p><p>  这个学期的期末考取消了，改成大论文，听说这门课要课改，期末参考意义不大。</p><hr><h2 id="职业生涯规划-B">职业生涯规划 B</h2><h3 id="课程简介-10">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>  我觉得职规是每位大学同学都必须要上的一门课，而且强烈建议大一大二上。我是因为学籍异动选上的蔡云老师。嘿嘿，蔡云老师就不用说了，职规体验直接拉满了。虽然每节课后的讨论会花相当长的一部分时间，但是我觉得都是对我成长很有帮助的，也在帮我不断认清自己的道路以及成长方向。最后我其实想说职规这门课关键的是他带给了你什么，这些东西已经远超绩点了，包括其实并非只有蔡云老师好，其实很多老师可能给分差或者评分不高，但是都是很优秀的老师，相信他们的职规课一样可以带给你足够的成长。</p><hr><h2 id="农事劳动实践">农事劳动实践</h2><h3 id="课程简介-11">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟</li><li>花费时间：🌟🌟🌟</li></ul><p>  这门课是我秋学期补选上的，同时满足劳育和博雅技艺，可以说是非常抢手的一门课。抛开这些不说，每周的农事劳动实践的内容都很充实，不仅施肥种树种花，还抓虫搞园艺，虽然体力消耗非常大，不过每一周都值得发一条朋友圈！不过这门课很难区分开来，就导致给分比较差，主要评分为理论课上的点名、小测签到和最后的大论文，记得每周都记录一下写一下小日记，这样最后大论文会很方便。</p><hr><h1>最后一点碎碎念</h1><p>  整体对大二秋冬很满意，相较于上个学期学分突然猛增的不适宜，这个学期更多的是从容。（上个学期 39 学分后来退课至 35，本学期 36 学分）有两点特别值得一说。</p><p>  第一点是，我越来越崇尚ROI（投入产出比）、优先级的思维和成长思维来解决问题，对于一件事情，不再是绩点驱动、退院驱动，反而更看重的是这件事情对我自身的成长帮助有多大，他的性价比有多高，优先级是多少，”越做越爽“思维；而对于低优先级的事情，想办法围绕着提升自己做文章，提升优先级，并且多做“顺风车”。这个学期没有比上个学期少事情，但是我主动舍弃了很多ROI低的事情或者对自己无帮助无意义的琐事，当选择在面前时，自然而然地选择性价比更高的，而不是全都要。而当我在做一件性价比很高并且能够给我带来很大成长的事情时，我会获得更大的正反馈，不断地刺激分泌多巴胺让我去做这件事情，直到我对这件事情上瘾，不断地循环，形成正向反馈，越做越爽，越爽越做，进入心流。对于“顺风车”，我举个例子，沟通技巧布置了一个写文献综述的作业，那我就“顺便”研究一下自己感兴趣的领域，这样既完成了作业，又给自己一个机会研究感兴趣的领域；新制度经济学要交论文，我刚好觉得自己感兴趣的Defi（去中心化金融），GameFi很适合这个论文，刚好趁这个机会再深究一下，军理交一篇论文，刚好可以研究一下自己完全未涉猎的阿富汗战争，而不是以前的水一篇论文就完事；做DS的作业的时候在考虑用简单熟练的邻接矩阵表示图好还是用不太熟练的邻接表好，当时想的是，这正是一个很好的机会复习一下不太熟练的邻接表，尽管花了更多的时间，但是比起用邻接矩阵我成长的更多；再比如朋友找我打Kic(毕马威商赛)，当时想的是毕马威是商赛中的创赛，刚好能够再锻炼一下自己的创新思维，而且毕马威很看技术，而且需要用到AI的内容，刚好能把所学的知识运用一下。</p><p>  当你用这样的思维思考的时候，你会发现你在越来越擅长你自己的领域，浅显的说可以从我这个学期绩点体现出来，主修均绩大幅上升，并且这个学期满绩的数量超过了大一总和，与此同时绩点下 4 的数量也是历史新高。很多课比如普物、普物实验、军理、马原等，可能对我未来成长帮助不大，他的优先级就会降低，运用 OS（操作系统）里的概念，这样就会发生 Starvation（饥荒），导致这些虽然对我帮助不大的事情没有被做完，这样的影响也非常大，所以需要进行优先级的升级，就用到顺风车思维或者靠 ddl 提升优先级，这样足以支撑我完成这门课的学习，而且不会花太多的时间做无意义的边际收益很低的事情。</p><p>  第二点是，我越来越爱上我的专业，可以说，我和计算机和解。这个学期和朋友聊起大家为什么选择这个专业的时候，我回想了一下，高中的我甚至都没有摸过计算机，也就选了技术和计算机沾点边。高中其实完全对专业不了解，当时自己也只是对几个专业完全不喜欢，其他专业都差不多，这也是为什么我还去了强基计划，当时觉得读基础学科也无所谓，打心底更看重学校罢了，结果高考分卡在了一个很尴尬的位置，在南大人工智能和浙大工信里毅然决然的选择了工信，因为留在浙江，认识的人多。进入工信之后，第一件大事就是选专业，我当时也是觉得什么专业都好，对信息安全比较感兴趣，虽然我是电脑小白一个，但是好歹也是知道黑客是什么，当时觉得黑客很酷，加上自己擅长数学、英语，最不喜欢物理，就选了信息安全，也顺利通过了面试。大一上读了一年，其实对专业也完全没有清晰的认识，直到大一下。</p><p>  大一下的专业课让我觉得自己对信息安全的认识和他本身有强烈的偏差，学业的压力和同学的 peer pressure 给我造成了很大的打击，让我产生了我是否适合学习计算机的念头。一个学期下来，痛苦。我发现我不喜欢我的课，我没有那么收获，更多时候我只是想应付过去，我开始另寻出路，对区块链感兴趣的我联系了导师想做相关的项目，在导师的帮助下，我们先做了安全加密方面的研究，发现自己对这方面有点感兴趣，密码学也很有意思；对创新创业感兴趣的我开始积极探索，我感受到了成长、收获的快乐，当我无法从 A 获得成就以及成长而能从 B 获得的时候，自然而然，我就慢慢开始抵触 A，一有时间我就会花在 B 上，因为我能够获得的正反馈更多，不断地恶性循环，我开始用其他方面的优势来伪装自己，但其实脆弱不堪，我也知道这不是长久之计。</p><p>  时间回到大一下的暑假，我用了很长的时间和计算机和解。我试着不那么抵触他，我重新看完了本是图灵大一上学习的程算课，我逐渐发现计算机是很有意思的一门学科，不再是之前的死记硬背；同时，我开始学会如何高效的使用电脑，如何用电脑记笔记，一些快捷键如何使用，一些好用的软件、插件，这些都是能够给我带来即时正反馈的事情，并且让我持续不断地获得成长和快乐并且持续做下去。我带着这样的思维开始了大二上的学习，慢慢地，我能理解我们专业正在做什么，这些课正在做什么，同时我对区块链、NFT 感兴趣，而他们也正好是我们专业（信息安全）下面的研究领域，兴趣促使着我去学习，学习获得成长，又反促进兴趣，这样不断正反馈循环，不断进入心流。这个学期给我思维上带来最大改变的两门课是计算机系统 Ⅱ 和人工智能基础，计算机系统这个学期更多的是我们自己去设计一些东西，无论是流水线的设计还是操作系统的设计，设计这件事情给我带来了很大的快乐。我高中受美术老师的影响，就一直很喜欢艺术，很喜欢创造，也因此开始喜欢文学，所以当我把计算机创造这件事和艺术创造联系起来的那一刻，我觉得他们太像了，计算机本来就是人创造出来的，计算机语言为什么也被称作<code>language</code>是有原因的，计算机的代码就和写诗一样，那一刻我真的疯狂的爱上了计算机，我发现我创造出来的东西居然还不赖，我也可以设计出来很有意思的东西，包括现在写的 blog，我也可以通过计算机写一个主页，可以上传我写的东西，这本身就是一件很酷的事情。</p><p>  说说人工智能基础，人工智能基础这门课让我对学习有了更深的认识。重新塑造了我自己的学习观，我慢慢地把自己的大脑当成一种算法，当成机器，无数的 input 输入，将我自己训练成一个合适的模型，成功输出。因此，我在不断改善自己的学习方法，改正学习的坏习惯，以机器学习的视角看待自己的学习，这里我强烈推荐 B 站 up 主<code>YJango</code>的学习观系列视频（<a href="https://space.bilibili.com/344849038?from=search&amp;seid=12975206688607334651&amp;spm_id_from=333.337.0.0">YJango的个人空间_哔哩哔哩_bilibili</a>）。</p><p>  总结一下这个学期，整体来说可以说非常满意了，因为我每一天都在知道，我正在变得更好，我已经在路上。</p>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
