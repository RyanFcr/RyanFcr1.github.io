<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《深入理解计算机系统CSAPP》（二）</title>
      <link href="/2022/01/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/01/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>《深入理解计算机系统CSAPP》（二）</h1><p>  在Github上找到这样两个项目，相信对自学CSAPP的同学会有帮助</p><ul><li><p><a href="https://github.com/EugeneLiu/translationCSAPP">EugeneLiu/translationCSAPP: 为 CSAPP 视频课程提供字幕，翻译 PPT，Lab。 (github.com)</a></p></li><li><p><a href="https://github.com/Exely/CSAPP-Labs">Exely/CSAPP-Labs: Solutions and Notes for Labs of Computer Systems: A Programmer’s Perspective 3rd Editon // 《深入理解计算机系统》第三版的实验文件、解答与笔记 (github.com)</a></p></li></ul><p>  B站视频链接👇</p><p><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=1">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频_哔哩哔哩_bilibili</a></p><p>  笔记主要由书上章节分类，而非课程视频的分集。</p><h2 id="Lecture-03-Machine-Level-Programming📝">Lecture 03 Machine Level Programming📝</h2><h3 id="History-of-Intel-Processors-and-architectures">History of Intel Processors and architectures</h3><ul><li>使用机器语言可以获得<ul><li>PC</li><li>Register</li><li>Condition Codes</li></ul></li><li>Intel的处理器系列被称为x86，x86对于英特尔处理器来说是一个口头的称谓，原因是第一个芯片被称为8086，然后他们跳过了81，随后推出了8286、8386等等，共同点都有86，所以人们称它位x86。<ul><li>8086，8086是第一个16位微处理器，它出现在1978年。</li><li>i386</li><li>……向后兼容</li></ul></li><li>CISC 复杂指令集 vc RISC 精简指令集（ARM，Risc-v）</li><li>IA32，x86-64</li><li>竞争对手AMD<ul><li>率先突破x86-64</li></ul></li></ul><h3 id="C，assembly，machine-code">C，assembly，machine code</h3><ul><li><p>ARM：Acorn RISC Machine</p><ul><li>功耗更低，更简单</li></ul></li><li><p>一些定义的明确</p><ul><li>ISA：指令集架构，机器级程序的格式和行为，定义了处理器状态、指令的格式，以及每条指令对状态的影响。<ul><li>Intel：x86，IA32</li><li>ARM：很多手机上的</li></ul></li><li>微架构microarchitecture是ISA这个架构的实现</li></ul></li><li><p>对于机器级编译两层抽象很重要</p><ul><li>ISA</li><li>虚拟内存</li></ul></li><li><p>将C代码翻译为目标代码的过程：</p><ol><li><strong>预处理器</strong>会扩展源代码，插入所有用<code>#include</code>指令的文件，扩展所有用<code>#define</code>声明指定的宏。</li><li><strong>编译器</strong>基于编程语言的规则、目标机器的指令集和操作系统的惯例，会将源代码转换为汇编代码作为输出，给出程序的每一条指令。</li><li><strong>汇编器</strong>将汇编代码转化为二进制目标代码文件，它是机器代码的一种形式，包含了所有指令的二进制表示，但是还没有填入全局值的地址。</li><li><strong>链接器</strong>将目标代码文件和实现库函数的代码合并，产生最终可执行代码文件。</li></ol><ul><li>.c——&gt;.s——&gt;.o——&gt;p</li><li>编译器——&gt;汇编器——&gt;链接器</li><li>-og优化</li><li>汇编代码中以“.”开头的行都是指导汇编器和链接器工作的伪代码，可以忽略</li><li>变量所有名称在汇编、机器代码级别完全丢失了，变成了寄存器和内存中的某个位置。</li></ul></li><li><p><strong>编译器</strong></p></li></ul><p> <code>gcc - Og -S xx.c </code>得到<code>xx.s </code></p><ul><li><strong>汇编器</strong></li></ul><p> <code>gcc -Og -c xx.c</code>进行编译和汇编，生成二进制文件<code>xx.o</code>，可以通过反汇编器，<code>objdump -d xx.o</code> ，将可执行文件转换成汇编代码</p><p> 发现</p><ol><li>每个指令需要的字节数不同，有的两个，有的三个……</li><li>每个指令有自己对应的编码</li><li>反汇编得到的汇编代码和直接生成的有差异</li></ol><p> 同样可以使用<code>gdb</code>然后输入<code>disassemble</code>来反汇编代码</p><ul><li><strong>链接器</strong></li></ul><p> 使用链接器将目标代码文件转化为可执行代码。要求：目标代码文件中必须含有一个<code>main</code>函数，作为程序的入口。按<strong>书上</strong>的指令：<code>gcc -Og -o prog main.c mstore.c</code>，链接了main.c和mstore.c，生成可执行文件prog。</p><p> 可以发现和汇编器生成的区别有：</p><ol><li>链接器将代码移到了新的地址范围内。</li><li>链接器补充了调用函数<code>mult2</code>需要使用的地址。</li><li>多了两行<code>nop</code>，可以使得函数代码变成16字节，更好放置下一个代码。</li></ol><ul><li>数据格式<ul><li>不区分符号和无符号的存储方式</li><li>指针也是以数字的形式存储的</li><li>b 字节 8</li><li>w 字 16</li><li>l 双字 32</li><li>q 四字 64</li><li>浮点数是4字节、8字节、10字节<ul><li>浮点数以和整型数据完全不同的方式进行处理，并且使用完全不同的寄存器组。</li></ul></li><li>数据结构这些是编译器实现的</li></ul></li><li>每条指令能做的事情比较有限</li></ul><h3 id="Assembly-Basics：Registers，operands，move">Assembly Basics：Registers，operands，move</h3><ul><li>一个x86-64的CPU中包含16个存储64位值的通用目的寄存器，可以用来存储整数数据和指针。有些寄存器有<strong>特殊用途</strong>，是约定俗成的<ul><li>sp 栈指针</li><li>ecx count</li><li>e<strong>b</strong>c —— base等等 但是其实我们已经不需要知道了</li><li>%r 64位</li><li>%e 低32位</li><li>可以对低的1、2、4、8字节进行操作</li></ul></li></ul><h4 id="操作数指示符（Mov类）">操作数指示符（Mov类）</h4><p> 大多数指令由一个或多个操作数（Operand），指示出一个操作中要使用的元数据值，以及放置结果的目的位置。</p><p> 操作数包含三种类型：</p><ul><li>**立即数（Immediate）：**用来表示常数值，书写格式是在<code>$</code>后面跟一个标准C表示法表示的整数，比如<code>$-577</code></li><li>**寄存器（Register）：**表示某个寄存器的内容。</li><li>**内存引用：**它会根据计算出来的地址访问某个内存位置。有不同的寻址模式，最常用的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi><mi>e</mi><mi>m</mi><mo stretchy="false">[</mo><mi>R</mi><mi>e</mi><mi>g</mi><mo stretchy="false">[</mo><mi>R</mi><mi>b</mi><mo stretchy="false">]</mo><mo>+</mo><mi>S</mi><mo>∗</mo><mi>R</mi><mi>e</mi><mi>g</mi><mo stretchy="false">[</mo><mi>R</mi><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>D</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Imm(r_b,r_i,s) = Mem[Reg[Rb]+S*Reg[Ri]+D]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">]</span></span></span></span> ，其中，<strong>要求寄存器大小都是64位的</strong>，才能完整索引整个虚拟内存空间，并且不能使用<code>%rsp</code>。常用括号来简化。</li></ul><p> 源操作数是一个立即数，可以直接是一个立即数或者保存在寄存器或内存里，目标操作数是一个位置，可以是寄存器或内存</p><p> <strong>注意</strong>：</p><ul><li>两个操作数不能同时为<strong>内存</strong>地址。如果要在两个内存位置传输数据，必须用一个寄存器进行中转。</li><li>使用到的寄存器大小一定要和指令最后一个字符指定的大小匹配。</li><li><code>movl</code>以寄存器为目的时，会将寄存器的高位4字节置0。<ul><li>x86-64的惯例：任何为寄存器生成32位值的指令都会把该寄存器的高位部分置0</li></ul></li><li>如果用<code>movq</code>来传输立即数时，该立即数只能表示为32位补码，然后扩展到64位的值。而<code>movabsq</code>能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。</li></ul><p>寄存器可以作为临时存储的工具</p><p> 在将较小的源值复制到较大的目的时，提供两个类<code>MOVZ</code>和<code>MOVS</code>。<code>MOVZ</code>是将目的中剩余的字节填充0，<code>MOVS</code>是将目的剩余的字节填充符号位的值。它们每条指令后面都有两个字符，分别表示源大小和目的大小。</p><ul><li>不存在<code>movzlq</code>，可以直接使用<code>movl</code>。因为当使用<code>movl</code>传输数据到32位目的寄存器中时， 会自动将目的寄存器的高位4字节置零。</li><li><code>cltq</code>没有操作数，总是以<code>%eax</code>作为源寄存器，以<code>%rax</code>作为目的寄存器，等价于<code>movslq %eax,%rax</code>。</li></ul><p>综上：</p><ol><li>两个指针之间进行传输，由于是直接对内存进行操作的，所以需要先经过一个寄存器。</li><li>小的数据类型转换到大的数据类型，是根据前面的数据类型决定是<code>MOVZ</code>还是<code>MOVS</code>。</li><li>大的数据类型转换到小的数据类型时，先将其保存得到寄存器中，再将部分保存到内存中。</li></ol><h3 id="Arithmetic-logical-operations">Arithmetic &amp; logical operations</h3><p> 以下列出了x86-64中的一些算数和逻辑操作，除了<code>leaq</code>以外，其他都有对不同大小数据的指令。</p><p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220124230420590.png" alt="image-20220124230420590"></p><ul><li><code>leaq S D</code>是将S计算出的地址付给寄存器D。通常会被用来执行加法和有限形式的乘法。比如对于比例变址寻址$Imm(r_b,r_i,s) $  ，得到的地址会是  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><msub><mi>r</mi><mi>b</mi></msub><mo>+</mo><msub><mi>r</mi><mi>i</mi></msub><mo>∗</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">Imm+r_b+r_i*s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> ，所以<code>leaq Imm(%rax, %rbx, s), %rcx</code>就是将 Imm+%rax+s*%rbx 保存到 %rcx 。<ul><li>**注意：**目的操作数只能是寄存器。</li></ul></li><li>一元操作符中，操作数可以是寄存器也可以是内存地址。</li><li>二元操作符中，第一个操作数可以是立即数、寄存器或内存地址；第二个操作数可以是寄存器或内存地址。</li><li>移位操作中，第一个操作数可以是立即数或放在<strong>寄存器<code>%cl</code></strong>(rcx的low八位)中，第二个操作数可以是寄存器或内存位置。<ul><li>**注意：**如果我们对w位的数据进行移位，则只考虑<code>%cl</code>中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>w</mi></mrow><annotation encoding="application/x-tex">log_{2}{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span>位，保证不会将数据移出边界。 比如<code>salb</code>只会考虑低3位的值，<code>salw</code>只会考虑低4位的值，以此类推。</li></ul></li></ul><p><strong>注意：</strong></p><ul><li>以上操作除了右移以外，在无符号数和补码间都是通用的，也体现了补码的优势。</li><li>可以使用<code>xorl %edx, %edx</code>来对寄存器<code>%rdx</code>置零。</li></ul><p>Lecture06 机器级编程(控制) 观看记录📝<br>04:00 处理器的状态（关于当前运行程序的信息，rax,rsp,rip）<br>05:51 条件码<br>07:55 比较指令(cmp,test)<br>11:46 读状态码(setx,)<br>20:14 状态分支<br>20:36 跳转指令(这里还提及了+=的来源)<br>26:54 C中goto语句(尽量还是不要用，不清晰)<br>29:05 通用条件表达的转换(使用分支)<br>31:41 条件移动<br>35:48 条件移动的例子<br>36:49 条件移动不适合的情况<br>38:27 循环<br>(总的来说就是把各种形式的循环归并成一种形式)<br>38:29 &quot;Do while&quot;的例子(C语言)<br>40:44 &quot;Do while&quot;的例子(编译结果)<br>41:05 通用的&quot;Do while&quot;的Goto版本<br>41:21 通用的&quot;While&quot;的Goto版本(1)<br>44:07 &quot;While&quot;的例子<br>45:34 通用的&quot;While&quot;的Goto版本(2)<br>46:26 &quot;For Loop&quot;的形式<br>47:38 “For” -&gt; &quot;While Loop&quot;的转换<br>50:10 Switch语句<br>51:01 Switch语句的例子<br>53:44 Switch的解释(不是if-else的组合！！！超酷的)<br>1:12:31 总结</p><p>Lecture07 机器级编程(过程) 观看记录📝<br>Procedures</p><p>Stack Structure<br>Calling Conventions<br>Passing control<br>Passing data<br>Managing local data<br>Illustration of Recursion<br>2:45 ABI</p><p>3:50 Procedures的机制<br>7:34 X86-64Stack<br>ABI中调用的约定</p><p>14:38 过程中的控制<br>15:32 过程中的控制(例子)<br>21:43 过程中的数据(参数传递)<br>23:06 过程中的数据(例子)<br>26:19 过程中的局部变量管理<br>26:22 栈帧<br>31:15 一个具体的例子<br>34:42 X86-64/Linux栈帧的结构<br>39:06 Calling incr的例子<br>过程调用中寄存器的使用<br>46:29 Register保存的约定<br>49:38 不同寄存器的用途<br>51:17 被调用者保存寄存器的使用示例及其工作原理<br>递归部分的解释<br>54:31 递归的例子<br>1:03:40 递归部分的总结</p><p>Lecture08 机器级编程(数据) 观看记录📝<br>数组<br>04:16 数组声明<br>05:14 数组访问<br>14:38 数组的例子<br>21:49 数组和指针的不同(C语言部分，可看书)<br>39:47 嵌套数组<br>45:32 嵌套数组的访问<br>51:04 多层数组的元素访问<br>54:58 N<em>N的矩阵<br>56:41 16</em>16数组访问的例子<br>结构<br>59:24 结构体的表示<br>1:00:16 指向结构体成员的指针<br>1:05:34 结构体和对齐的概念<br>1:07:03 对齐的原则<br>1:11:15 节省内存<br>浮点数<br>1:13:00 浮点数的历史<br>1:14:44 SSE3编程<br>1:16:01 Scalar和SIMD(真的好感动，实习时用过)<br>1:17:13 FP运算的知识<br>其实这里应该提及多个浮点数一起运算的加速效果</p><p>Lecture09 机器级编程(高级专题) 观看记录📝<br>内存布局<br>2:14 最大寻址大小的解释(47位)（limit）<br>10:30 内存布局的解释(stack,heap,data,text/shared lib)<br>12:07 内存分配的例子<br>缓冲区溢出<br>17:54 缓冲区问题介绍<br>19:39 String库的缓冲区例子-gets,strcpy,strcat<br>23:26 缓冲区问题例子<br>32:15 缓冲区问题(缓存区溢出攻击例子)<br>33:31 代码注入攻击解释(很有意思)<br>36:47 当你替换代码是，如何确定注入的代码提供了准确的地址<br>38:09 Buffer overflows的历史<br>42:30 蠕虫和病毒的区别<br>43:09 避免缓冲区攻击的手段<br>43:24 避免程序中的缓冲区溢出<br>45:28 系统级别的防御:ASLR,权限，canary(啊啊啊啊啊,canary我遇到过)<br>1:03:51 关于这三种手段的老师的评价<br>1:10:59 attack lab讲解<br>1:12:59 联合体<br>1:13:40 联合体内存分布<br>1:15:40 字节顺序的问题</p><p>Lecture10 程序优化 观看记录📝<br>01:10 整体的程序优化手段介绍<br>03:08 性能的两条人间真实:常数因子也很重要;必须了解系统知识才能优化性能<br>04:32 关于Compiler(编译器)的一些介绍<br>06:32 代码移动(Code Move)，先计算需要计算的值，然后在之后一直使用这个值<br>08:45 计算量减少(Reduction in Strength),将乘法转化为加法<br>10:07 共享通用表达(Share Common SubExpressions),通过抽取子表达式，将其提前转化为共享变量的方式减少计算量<br>13:00 优化中的障碍<br>13:10 障碍1，过程调用<br>18:08 为什么编译器无法优化这种过程调用错误,变量在变化，无法确定函数体内容<br>21:02 障碍2，内存别名导致，重复对内存地址进行读取的问题;<br>22:57 障碍2是由于内存别名的存在，导致程序无法确定两个内存是否完全无关，所以需要重复读取;<br>32:11 无序执行(乱序执行)，利用指令级别的并行<br>32:32 程序加速的例子<br>35:13 CPE指标的引入<br>38:30 程序加速，改进例子的极少<br>40:35 指令级并行的基本思想<br>44:26 超标量计算机简介<br>45:03 流水线技术，及其如何将计算分解为一系列不同的阶段<br>48:40 HasWell，不同阶段对应的时钟周期<br>51:00 计算机中，顺序依赖概念的解释<br>51:30 循环展开，对性能提高的效果展示<br>52:50 循环展开对于不同运算的性能提高效果<br>53:29 运算顺序改变，对于不同运算的性能提升效果<br>61:20 Avx2指令加速<br>66:46 条件预测，提前加载指令进行加速<br>72:30 获得高性能程序的一些关键点</p><p>Lecture12 Cache Memory 观看记录📝<br>01:09 内存的层级结构<br>01:54 Cache的概念<br>04:42 Cache的组织结构<br>07:30 Cache读<br>07:30 Cache的寻址方式<br>10:38 Direct Mapped Cache(E = 1)<br>20:58 E-way Set Associative Cache(E = 2)<br>35:38 Cache写<br>write hit<br>36:11 wrtie through and write back(脏位)<br>write miss<br>37:47 write-allocate and No-write-allocate<br>39:40 英特尔i7的cache架构<br>42:42 Cache性能的度量:MIss Rate, Hit Time, Miss Penalty<br>44:53 关于Cache数量度量的例子<br>46:58 写出缓存友好的代码<br>50:57 Memory Mountain<br>53:48 Memory Mountain Test代码<br>56:30 Memory Mountain可视化代码<br>59:14 Ridges of temporal locality时间局部性的山脊<br>1:03:53 重新排列循环<br>1:04:01 Matrix Multiplication例子<br>1:05:13 Miss Rate分析<br>1:08:05 Matrix Multiplication的总结<br>1:10:31 分块技术<br>1:14:41 分块技术的Cache Miss分析<br>1:16:14 Blocking的效果分析</p><p>Lecture13 链接观看记录📝<br>01:51 静态链接的过程<br>03:40 为什么要用链接：模块化，效率(编译)<br>05:20 连接器的作用<br>05:25 符号解析<br>07:20 重定位<br>09:20 三种目标文件的分类<br>09:25 .o可重定位目标模块<br>09:50 .out可执行文件<br>10:15 ,so共享目标文件<br>10:32 目标模块ELF标准<br>10:58 目标文件的格式:header,segment header table, .text section, .rodata section,.data section,.bss section, .symtab section, .rel .txt section,.rel .data section,.debug section, section header<br>15:13 链接器的符号分类，global symbols, external symbols, local symbols<br>19:30 局部非静态变量 vs 局部静态变量<br>21:30 链接器如何解决重复符号定义问题？强符号，弱符号;<br>32:04 避免全局变量的原因<br>36:00 重定位入口<br>44:15 加载可执行的目标文件<br>48:30 打包常用的函数<br>51:06 静态链接库<br>55:51 静态库链接的过程<br>56:13 使用静态库的过程<br>60:02 共享链接库<br>62:52 动态链接的加载过程<br>67:17 运行时的动态链接</p><p>杂项<br>53:13 常用库</p><p>示例<br>24:12 链接错误示例<br>sum<br>01:04 C程序示例<br>18:34 符号解析的过程<br>32:49 重定位的过程<br>41:26 重定位后的text部分<br>案例学习<br>70:24 库打桩</p><p># Lecture14 异常控制流 异常和进程</p><p>02:41 异常控制流会在什么地方存在<br>05:04 异常的定义，三种情况<br>07:15 异常表<br>07:46 异常的分类方法，同步异步。异步异常，中断。<br>10:20 同步异常，陷阱和系统调用<br>10:54 故障，页缺失，保护故障<br>13:03 终止<br>13:33 Linux/x86-64 常用的系统调用<br>14:01 syscall，open<br>15:54 故障的例子，页缺失，从磁盘到内存<br>16:58 故障的例子，无效内存引用<br>18:22 进程的定义<br>19:14 进程的两个抽象。第一个，独占cpu和寄存器。第二个，拥有自己的地址空间<br>21:02 top指令看进程<br>21:27 多进程管理共享，上下文切换是地址空间和寄存器的变化<br>23:40 逻辑控制流<br>24:50 并发<br>26:34 上下文切换的过程，用户模式和内核模式<br>28:19 系统调用错误处理<br>30:55 错误报告功能，unix_error<br>31:38 错误处理包装函数，Fork<br>32:43 进程控制函数，getpid，getppid<br>33:11 进程的三种状态，运行，停止，终止<br>34:18 终止进程，exit<br>35:33 fork创建子进程，返回两次<br>37:30 fork的例子<br>40:03 进程图，捕捉调用fork时发生的情况。顶点是语句的执行，边对应变量<br>41:30 进程图例子<br>44:10 多个连续fork例子<br>48:15 回收子进程<br>49:00 僵尸进程<br>49:35 系统安排init进程回收孤儿进程<br>51:00 一个僵尸现象的例子<br>52:41 另一个例子，父进程结束子进程没结束<br>54:14 wait用来与子进程同步并回收它们<br>55:18 wait工作原理的简单示例<br>57:35 复杂的例子，waitpid函数<br>59:59 execve运行不同的程序<br>1:03:10 新程序开始时的栈帧结构<br>1:05:56 execve的例子，用途<br>1:10:37 总结。异常，进程，fork，exit，wait，waitpid，execve</p><p>Lecture15 信号和非本地跳转</p><p>00:52 linux进程体系，init创建守护进程Daemon，login shell<br>02:40 shell，bash<br>03:16 一个简单shell的main例程<br>04:17 eval求值<br>08:45 简单shell例程的问题，内存泄漏<br>08:55 异常控制流解决问题<br>09:29 信号的定义，Linux常见信号<br>13:20 信号的概念：发送信号<br>15:08 信号的概念：接受信号。三种反应<br>17:20 信号的概念：挂起和阻塞的信号<br>20:10 发送信号，进程组<br>21:44 kill的例子，kill -9,id前加横杠的意思<br>24:12 键盘发送信号，ctrl+c发送sigint，默认行为终止进程，ctrl+z发送sigtstp，默认行为挂起进程<br>24:55 ctrl+c和ctrl+z例子，ps命令，fg命令<br>26:10 系统调用kill发送信号<br>27:20 进程接受信号<br>28:33 pnb<br>30:02 信号的默认行为<br>30:24 使用signal函数的系统调用修改默认行为<br>32:25 安装处理程序的例子<br>33:59 信号处理程序看作并发流<br>38:00 信号处理程序被其它信号处理程序中断<br>39:01 阻塞和接触阻塞信号<br>40:10 用sigprocmasks函数阻塞和解除阻塞信号<br>42:13 安全的信号处理程序<br>44:32 编写安全程序的经验参考，6条经验<br>49:28 异步信号安全，Linux安全的系统级函数<br>53:08 作者开发的安全的I/O包<br>54:15 例子fork14<br>59:38 可移植信号处理，书上P541<br>63:10 作业列表的例子同步错误 书上P542<br>67:30 消除竞争的一种方法，书上P543<br>70:18 显式地等待信号<br>76:05 sigsuspend</p><p># Lecture18 虚拟内存系统</p><p>00:19 简单的内存系统的例子，和书上P574一样<br>10:54 另一个例子<br>17:41 虚拟内存在Core i7/Linux下如何工作<br>24:58 Core i7端到端的地址翻译<br>28:48 Intel系统页表条目的结构，第一二三级<br>31:38 第四级页表条目格式<br>33:25 Core i7页表翻译<br>36:11 加速访问L1高速缓存<br>38:36 Liunx虚拟内存系统。内核产生的也是虚拟地址<br>44:12 Linux虚拟内存区域<br>46:38 缺页异常处理<br>50:53 内存映射<br>53:40 再看共享对象<br>56:22 私有写时复制对象<br>60:49 fork函数，内核只拷贝所有内核数据结构，mm_struct, area_struct和页表。将两个进程的每个页面都标记为只读，每个区域结构都标记为私有写时复制<br>65:13 execve系统调用。删除当前进程的所有area_struct和页表，为新区域创建新的<br>71:34 mmap函数用户级内存映射<br>75:34 mmap的例子</p><p># Lecture19 动态内存分配 基础概念</p><p>00:48 本周内容主题：储存器分配，其工作原理，如何使用它们管理虚拟内存<br>01:05 动态内存分配器，堆<br>01:56 块被分配和释放，显式分配器malloc和free，隐式分配器使用垃圾回收（Java等）<br>03:37 malloc，free，calloc初始化分配块为0,realloc调整之前malloc块的大小，sbrk增长和缩小堆<br>05:40 malloc例子<br>07:17 今天实现malloc和free等功能，简化假设，内存地址不按字节，按word，假设word是4个字节（int的大小）<br>08:38 malloc，free分配释放块的例子<br>10:02 分配器的要求和目标各种约束<br>12:24 速度和内存效率指标，吞吐量。在malloc和free序列最大化吞吐量和使内存利用率尽可能高<br>14:01 使内存利用率尽可能高，衡量使用堆的效率。有效载荷/堆的大小<br>17:24 碎片。内部碎片。<br>18:58 外部碎片。堆中有足够内存但没有足够大的空闲块<br>21:36 实现问题。free怎么知道块的大小？怎样追踪空闲块？如何处理剩余空间？如何选择空闲块？如何处理刚刚被释放的块？<br>23:09 知道要释放多少。块头部编码了块大小<br>24:15 追踪空闲块。隐式空闲列表，空闲块通过头部的隐含字段连接，分配器可以遍历。<br>29:00 构建隐式空闲列表。<br>31:51 需要块的大小和分配状态，不需要两个word，利用块需要边界对齐，用一个word<br>33:52 隐式空闲列表的细节。结束块已分配大小为0<br>36:46 找到空闲块。第一次找代码。之后找从离开的地方找。找最佳匹配，扫描所有，速度较慢，但提高了效率。<br>39:30 分割空闲块</p><p>42:34 如何释放一个块。清除已分配的标志就可以，不过会造成外部碎片，得到两个连续的空闲块。<br>43:57 合并空闲块，释放的时候检查前后是否也是空闲块。找前面的块要重头遍历，搜索时间太长<br>46:13 解决方法：Knuth提出的边界标记技术，把块的头部复制到脚部，找上一个的脚部就能根据大小找到头部<br>49:55 合并时的4种情况<br>52:41 边界标记的缺点，它们是内部碎片。优化方法：已分配的块不需要脚部，怎样知道前面块是已分配的？把编码的 已分配/空闲 位放在当前块多出来的低位里。妙啊！<br>59:38 总结关键策略。放置策略，不错的适配接近最佳适配。分割策略，处理剩下的部分。合并策略，每次free合并还是扫描合并<br>64:37 隐式列表总结。简单的分配器，各种属性。做shell lab</p><p># Lecture 22 网络编程 第2部分</p><p>01:30 <code>hostinfo</code>程序<br>04:35 回顾上次的概述图，单个连接的服务器，<code>getaddrinfo</code><br>07:56 <code>sockaddr</code>，<code>sockaddr_in</code>结构<br>10:03 <code>getaddrinfo</code>，<code>freeaddrinfo</code>，<code>gai_strerror</code><br>12:54 <code>getaddrinfo</code>返回的<code>addrinfo</code>数据结构<br>13:58 <code>getnameinfo</code>功能<br>15:12 <code>hostinfo</code>程序<br>20:32 回到概述图，<code>socket</code>是本地调用，为此连接分配一些数据结构。<code>connect</code>就像拨打电话<br>21:58 辅助函数，<code>open_clientfd</code>，<br>28:36 <code>open_listenfd</code><br>35:45 例子echo，一个客户端<br>40:17 实现，客户端代码<br>42:19 服务端代码<br>46:43 telnet<br>48:21 http<br>50:56 静态内容html 动态内容<br>51:58 URL<br>52:57 HTTP请求<br>53:31 HTTP回应<br>54:06 演示<br>57:38 书上tiny代码建议看下<br>59:40 serve_static<br>63:55 动态内容<br>67:35 fork/exec<br>68:33 CGI，通用网关接口<br>69:44 创建环境变量，查询字符串<br>70:54 动态内容GET<br>72:39 对两个整数求和的CGI程序</p>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFT：从入门到精通</title>
      <link href="/2022/01/26/NFT%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
      <url>/2022/01/26/NFT%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>NFT：从入门到精通</h1><h2 id="前言">前言</h2><p>  事先声明，标题完全是玩梗，全文仅为个人粗浅的理解，欢迎一起探讨~</p><p>  几个月前看到一条推送，歌手林俊杰在社交平台上官宣，自己在虚拟现实平台Decentraland上买下三块虚拟土地，花费12.3万美元。在此之前，粉丝豪掷千金买下了NBA 球星勒布朗·詹姆斯标志性战斧扣篮照片转化成的NFT。也就在今天，人们熟知的奥运合作“专业户”——伊利，也为冬奥会专门推出了”数字牛奶“。这些看起来很赛博朋克的事情就发生在我们所在的世界，而这些虚拟藏品有个统一的名称——Non-fungible Token，aka NFT .</p>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解计算机系统CSAPP》（一）</title>
      <link href="/2022/01/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/01/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>《深入理解计算机系统CSAPP》（一）</h1><p>  在Github上找到这样两个项目，相信对自学CSAPP的同学会有帮助</p><ul><li><p><a href="https://github.com/EugeneLiu/translationCSAPP">EugeneLiu/translationCSAPP: 为 CSAPP 视频课程提供字幕，翻译 PPT，Lab。 (github.com)</a></p></li><li><p><a href="https://github.com/Exely/CSAPP-Labs">Exely/CSAPP-Labs: Solutions and Notes for Labs of Computer Systems: A Programmer’s Perspective 3rd Editon // 《深入理解计算机系统》第三版的实验文件、解答与笔记 (github.com)</a></p></li></ul><p>  B站视频链接👇</p><p><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=1">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频_哔哩哔哩_bilibili</a></p><p>  笔记主要由书上章节分类，而非课程视频的分集。</p><h2 id="Lecture-01-Course-Overview📝">Lecture 01 Course Overview📝</h2><p>第一节课主要是说明课程大纲</p><blockquote><p>Course Theme：</p><p>  Abstraction is good but don’t forget reality</p></blockquote><p>Great Reality 课程主题</p><ul><li>有限的未组合形式表示在数域中无限扩张的数<ul><li>int加法溢出</li><li>浮点数因为精度有限，不满足加法结合律</li></ul></li><li>理解汇编     intel x86-64</li><li>内存很重要<ul><li>结构的内存连在一起，<strong>内存引用错误</strong>访问到了一些奇奇怪怪的内存，导致段错误</li></ul></li><li>从程序角度提高性能</li><li>复制矩阵的两种方式</li><li>让程序通过网络彼此交谈，实现web服务器这样的服务</li></ul><p>七个lab</p><ul><li>Datalab: Manipulating bits<ul><li>Bits operations, arithmetic, assembly language programs</li></ul></li><li>Bomblab: Defusing a binary bomb<ul><li>Representation of C control and data structures</li></ul></li><li>Attacklab: The basics of code injection attacks<ul><li>Includes aspects of architecture and compilers</li></ul></li><li>Cachelab: Buliding a cache simulator and optimizing for locality<ul><li>Memory technology, memory hierarchy, caches, disks, locality</li><li>Includes aspects of architecture and OS</li></ul></li><li>Tshlab: Write your own Unix shell<ul><li>Hardware exceptions, processes, process control, Unix signals, nonlocal jumps</li><li>Includes aspects of compilers, OS, and architecture</li></ul></li><li>Malloclab: Writing your own malloc package<ul><li>Virtual memory, address translation, dynamic storage allocation</li><li>Include aspects of architecture and OS</li></ul></li><li>Proxylab: Writing your own Web proxy<ul><li>I/O,network programming</li><li>concurrency, concurrent server design, threads</li></ul></li></ul><hr><h2 id="Lecture-02-Bits，Bytes-and-Integer📝">Lecture 02 Bits，Bytes and Integer📝</h2><blockquote><p>需要一些代数的知识储备，群环域等。</p></blockquote><h3 id="信息存储">信息存储</h3><ul><li><p>二进制</p><ul><li>8个bit为Byte（字节）</li><li>计算机有32字长、64字长</li></ul></li><li><p>hex十六进制</p></li><li><p>布尔代数</p><ul><li>And    &amp;</li><li>Or    |</li><li>Not    ~</li><li>Xor    ^</li><li>进行一些位运算，实现掩码运算，比如提取最低有效字节<code>x&amp;0xFF</code>，保留除了最低有效字节以外的字节<code>x&amp;~0xFF</code></li></ul></li><li><p>逻辑运算：&amp;&amp;    ||    ！</p><ul><li><strong>注意</strong>短路 提前终止</li></ul></li><li><p>位移（移动超出位数w时，会mod）</p><ul><li>左移</li><li>右移<ul><li>逻辑右移</li><li>算术右移</li></ul></li></ul></li></ul><h3 id="整数的表示（有符号数和无符号数）">整数的表示（有符号数和无符号数）</h3><ul><li>B2U</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mn>2</mn><msub><mi>T</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">B2T_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">2</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><ul><li>Two’s Complement<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span> - x</li><li>符号位赋值加权的时候是-1，其他都是1</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">Tmin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = [100……00]</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">Tmax_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = [0111……11]</li></ul></li><li>Ones‘ Complement<ul><li>[1111……1111] - x</li></ul></li></ul></li><li>补码和无符号数之间的转换<ul><li>U2T<ul><li>u   u&lt;=Tmax</li><li>u - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span>    u&gt;Tmax</li></ul></li><li>T2U<ul><li>x + <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span>  x &lt; 0</li><li>x            x &gt;= 0</li></ul></li></ul></li><li>比较计算<ul><li>如果所有变量都是signed就用signed的计算方式</li><li>如果其中一个变量是unsigned，那么会强制另外一个转换成unsigned（隐式转换）加减乘除赋值都会</li></ul></li><li>经典bug：for循环，i（unsigned）–，小于0的时候跳——会一直循环<ul><li>sizeof函数往往返回unsigned的值</li></ul></li><li>扩展<ul><li>0扩展</li><li>符号扩展</li></ul></li><li>截断<ul><li>无符号数：模运算</li><li>符号数：先和无符号数一样B2U再U2T</li></ul></li></ul><h3 id="整数运算">整数运算</h3><ul><li><p>无符号加法</p><ul><li>溢出</li><li>可交换可结合</li><li>加法逆元：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>w</mi></msup></mrow><annotation encoding="application/x-tex">2^w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span> - x</li></ul></li><li><p>补码加法（先使用无符号加法，再转换成补码）</p><ul><li>正溢出</li><li>负溢出</li><li>正常</li><li>加法逆元<ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> if x = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>-x  if x &gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li></ul></li><li><p>无符号乘法</p><ul><li>截断，只关心低w位，实际上应该是2w位</li></ul></li><li><p>补码乘法</p><ul><li>截断，得到无符号数，再转换为补码</li><li>当两个比较大的正数相乘会得到负的结果：溢出</li></ul></li><li><p>乘常数</p><ul><li>2的指数幂乘法和左移等价</li><li>2的指数幂除法和右移等价（满足向0舍入）<ul><li><strong>注意</strong>算术右移：向下舍入。我们希望他向0舍入，所以引进bias=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>-1，对于负数，每次移位前先加bias</li></ul></li></ul></li><li><p>无符号数的使用场景：</p><ul><li>模运算、加密算法</li><li>bits用于表示集合而不是数字</li></ul></li></ul><h3 id="内存，指针，字符串的表示">内存，指针，字符串的表示</h3><ul><li>内存是个巨大的字节数组——虚拟内存<ul><li>实际操作是将DRAM、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的数组</li></ul></li><li>word size字长<ul><li>由硬件和编译器共同决定<ul><li>-m32</li><li>-m64</li></ul></li></ul></li><li>Byte Ordering<ul><li>小端序：最低有效字节在前<ul><li>67452301</li></ul></li><li>大端序：最高有效字节在前<ul><li>01234567</li></ul></li></ul></li><li>表示字符串</li></ul><h3 id="浮点数">浮点数</h3><ul><li><p>浮点数二进制分数的表示</p></li><li><p>移动小数点</p><ul><li>向左：更细，范围更少</li><li>向右：更粗，范围更大</li></ul></li><li><p>IEEE floating point</p><p>V = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mo>−</mo><mn>1</mn><msup><mi mathvariant="normal">）</mi><mi>s</mi></msup><mo>×</mo><mi>M</mi><mo>×</mo><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">（-1）^s × M × 2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord cjk_fallback">）</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span></p><p>S：符号</p><p>M：尾数，frac（忽略规格化的1开头）</p><p>E：阶码</p><ul><li><p>规格化的值Normalized</p><ul><li>E = e - Bias<ul><li>e∈（0,255）</li></ul></li><li>Bias = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> - 1</li><li>隐晦地以1开头</li></ul></li><li><p>非规格化的值Denormalized</p><ul><li>e全是0，E = 1 - Bias</li><li>没有隐藏的1</li><li>提供表示0的方法</li><li>存在+0和-0</li></ul></li><li><p>e全是1，frac全是0，是Infinity</p></li><li><p>e全是1，frac不全是0，是NaN。非零值</p></li></ul></li><li><p>几个现象</p><ul><li>分布不均匀，非规格化的数稠密地分布在靠近0的区域</li><li>有些数的间隔是等距的，当e不变，frac变化</li><li>越大的数间隔越大，指数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span>比较大，每次变化量大</li><li>光滑转变</li></ul></li><li><p>一些特殊的值</p><ul><li>0：全是0</li><li>最小正非规格化数：frac = [00……01]，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></li><li>最大非规格化数：frac = [011……1]，1-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></li><li>最小规格化数：e=1，frac=0，M=1</li><li>1：M=1，E=0</li><li>最大规格化数：frac=1-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，M=2-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，e = [1111……10]，E = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> - 2 - （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> - 1）=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1</li></ul></li><li><p>浮点数运算的基本思想(运算后舍入)</p><ul><li>舍入的方法<ul><li>向偶数舍入</li><li>向零舍入</li><li>向下舍入</li><li>向上舍入</li></ul></li><li>二进制的舍入（类似）</li></ul></li><li><p>浮点数的加法（类似十进制加法，如果M≥2，frac右移一位，E＋1；如果M &lt; 1 ，则frac左移1位，E - 1；如果E超出表示范围，发生溢出；如果M超出表示范围，对frac进行舍入）</p><ul><li>是封闭的</li><li>可交换</li><li>0是加法单位元</li><li>几乎所有元素都有逆元（除了Infinity和NaNs）</li><li>但是<strong>不具有结合性</strong>，缺乏最重要的群属性。会舍入，（3.14 +1e10） - 1e10 = 0 而 3.14 + （1e10 - 1e10 ） = 3.14</li><li>单调性</li></ul></li><li><p>浮点数的乘法（类似十进制乘法，如果M≥2，frac右移一位，E＋1；如果E超出表示范围，发生溢出；如果M超出表示范围，对frac进行舍入）</p><ul><li>是封闭的</li><li>可交换</li><li><strong>不可结合</strong>：可能出现溢出和不精确的舍入，比如  1e20 * （1e20 * 1e-20) = 1e20，而 (1e20 * 1e20 )* 1e-20 = INF</li><li>在加法上不具有分配率：可能会出现NaN，比如1e20 * （1e20 - 1e20） = 0 ，而1e20 * 1e20 -1e20 * 1e20 = NaN</li><li>1是乘法单位元</li><li>几乎是单调的（除了Infinity和NaN）</li><li><strong>只要a ≠ NaN，就有a*a ≥ 0</strong></li></ul></li><li><p>C中的浮点数</p><ul><li>float</li><li>double</li><li>强制类型转换<ul><li>int -&gt; float：不会溢出，但是会舍入</li><li>int/float -&gt; double：精准表示</li><li>double -&gt; float：可能会溢出和舍入</li><li>float/double -&gt; int：小数部分截断，向0舍入，<strong><code>float</code>的尾数部分为23字节，比int的32字节小</strong>，所以int可以精确表示float的整数部分，而<code>double</code>的尾数有52位，可能会出现舍入。并且当超过int的取值范围或NaN时，微处理器会指定 [10……00] （字长为w的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>） 为整数不确定值，即对应的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>M</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">TMin_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，所以一个很大的浮点数转化为int时，可能会出现负数。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crash Course Computer Science</title>
      <link href="/2022/01/18/Crash%20Course%20Computer%20Science/"/>
      <url>/2022/01/18/Crash%20Course%20Computer%20Science/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>Crash Course Computer Science (updating)</h1><h3 id="About-Video">About Video</h3><ul><li><p>面向小白的纯科普向视频</p><ul><li>虽说如此，但是不少知识是我大一一年才学懂的内容，不少内容还是有难度的。</li><li>对于其中的一些内容，其实是简化的，一些地方难免会有错误，请不要过度纠结。就好像小学的时候认为最小的数是0一样，只是为了方便理解。包括我的笔记，也难免会有错误，欢迎纠正~</li><li>坚持就是胜利</li></ul></li><li><p>适合对即将就读计算机类专业的准大学生</p></li><li><p>看完能对计算机专业有个较全貌的认识</p></li><li><p>计算机专业学生学英语素材（bushi）</p></li><li><p>视频地址 👇</p><ul><li>生肉（把字幕调成英文即可）：<a href="https://www.youtube.com/watch?v=O5nskjZ_GoI">Early Computing: Crash Course Computer Science #1 - YouTube</a></li><li>熟肉：<a href="https://www.bilibili.com/video/BV1EW411u7th?from=search&amp;seid=5864463258140356263&amp;spm_id_from=333.337.0.0">40集全/精校\ - Crash Course Computer Science_哔哩哔哩_bilibili</a></li></ul></li></ul><hr><h3 id="1E-episode-Early-Computing📝">1E(episode) Early Computing📝</h3><ul><li>计算设备的前身——算盘，进制的概念</li><li>computer曾指一种职业</li><li>步进计算器</li><li>战争，计算，查表<ul><li>差分机</li><li>分析机</li><li>第一位程序员：Ada</li></ul></li><li>美国的人口普查给计算提出了新的要求<ul><li>打孔卡片制表机</li><li>IBM的诞生</li></ul></li></ul><hr><h3 id="2E-Electronic-Computing📝">2E Electronic Computing📝</h3><ul><li>Harvard Mark Ⅰ<ul><li>机械继电器<ul><li>速度慢</li><li>磨损</li><li>“bug”</li></ul></li></ul></li><li>热电子管<ul><li>二极管</li><li>从机电到电子</li><li>巨人</li><li>ENIAC(Electronic Numerical Integrator and Calculator)</li></ul></li><li>晶体管<ul><li>半导体</li><li>硅谷</li><li>Intel</li></ul></li></ul><hr><h3 id="3E-Boolean-Logic-Logic-Gate📝">3E Boolean Logic &amp; Logic Gate📝</h3><ul><li>Binary<ul><li>两种信号</li></ul></li><li>Boolean Algebra<ul><li>NOT</li><li>AND</li><li>OR</li><li>XOR</li></ul></li><li>Logic Gate<ul><li>Logic table</li></ul></li></ul><hr><h3 id="4E-Representing-Numbers-and-Letters-with-Binary📝">4E Representing Numbers and Letters with Binary📝</h3><ul><li>二进制的原理<ul><li>二进制加法</li><li>8-bit ， byte</li></ul></li><li>表示 正负数</li><li>表示浮点数<ul><li>IEEE 754</li></ul></li><li>ASCII</li><li>UNICODE</li></ul><hr><h3 id="5E-ALU——How-Computers-Calculate📝">5E ALU——How Computers Calculate📝</h3><blockquote><p>抽象层的思维</p><p>A NEW LEVEL OF ABSTRACTION</p></blockquote><ul><li>算术单元<ul><li>负责所有的数字操作</li><li>利用Logic Gate——更high level的设计<ul><li>加法<ul><li>半加器（sum：carry）</li><li>全加器（半加器：半加器）</li><li>8-bit ripple carry adder（8位行波进位加法器）<ul><li>慢</li></ul></li><li>Carry-look-ahead（超前进位加法器）</li></ul></li><li>乘法</li></ul></li></ul></li><li>逻辑单元<ul><li>同样利用Logic Gate</li></ul></li><li>更抽象的ALU<ul><li>Input:<ul><li>A, B</li><li>4-bit operation code(alu_src控制ALU进行操作)</li></ul></li><li>Output：<ul><li>Flags：<ul><li>Overflow</li><li>Zero</li><li>Negative</li></ul></li></ul></li></ul></li></ul><hr><h3 id="6E-Registers-and-RAM📝">6E Registers and RAM📝</h3><ul><li>Gated Latch锁存器<ul><li>存一位</li><li>And-OR Latch</li></ul></li><li>Register<ul><li>存8,16,32,64位</li></ul></li><li>16X16矩阵存储256位锁存器<ul><li>2个数据选择器Multiplexer解码8位地址</li><li>4位代表行，4位代表列</li></ul></li><li>8个256位内存共用一个地址，组成DATA，8-Bits</li><li>RAM随机存取存储器<ul><li>8个模块，每个模块有32个内存方块，每个小方块有4个小块，每个小块是128位×64位</li><li>1MB</li><li>就像人类的短期记忆</li></ul></li><li>SRAM——Static</li><li>DRAM——Dynamic</li><li>Flash memory闪存</li><li>NVRAM</li></ul><hr><h3 id="7E-The-Central-Processing-Unit-（CPU）📝">7E The Central Processing Unit （CPU）📝</h3><ul><li>RAM+Register+ALU</li><li>理解IF-ID-EX-MEM-WB（取指令-译码-执行）这个过程</li><li>时钟<ul><li>clock speed</li><li>赫兹</li></ul></li><li>超频<ul><li>提升性能</li></ul></li><li>降频<ul><li>省电</li></ul></li></ul><hr><h3 id="8E-Instruction-Programs📝">8E Instruction &amp; Programs📝</h3><ul><li>指令集——programmable<ul><li>扩充指令集的概念<ul><li>Jump<ul><li>无条件跳转</li><li>有条件跳转</li></ul></li><li>Sub</li><li>Halt</li></ul></li></ul></li><li>现代CPU<ul><li>定长指令集，但是更长</li><li>变长指令集</li></ul></li></ul><hr><h3 id="9E-Advanced-CPU-Designs📝">9E Advanced CPU Designs📝</h3><ul><li>早期加快晶体管切换速度来提升CPU速度</li><li>复杂度 vs 速度<ul><li>上一期除法用软件实现——现在直接在硬件中实现=&gt;使ALU更复杂</li><li>专门电路处理处理器</li></ul></li><li>如何快速传递数据？<ul><li>RAM ——&gt; 快速缓存Cache<ul><li>但是存在Cache和RAM存储内容不一致的问题=&gt;诞生了dirty bit</li></ul></li></ul></li><li>加速CPU：流水线（overlap，把一条指令分成几个阶段stage，每一个clock执行一个阶段，同时每个clock相较于非流水线之前的clock变小了）<ul><li>并行处理<ul><li>会出现一些冒险冲突（hazard）</li><li>乱序执行</li></ul></li><li>跳转冒险<ul><li>推测执行</li><li>分支预测</li></ul></li><li>Superscalar超标量</li></ul></li><li>多核CPU</li><li>多个独立CPU</li><li>超级计算机，神威太湖之光</li></ul><hr><h3 id="10E-Early-Programming📝">10E Early Programming📝</h3><blockquote><p>It’s not magic, it’s computer science !</p></blockquote><p>程序如何进入计算机？</p><ul><li>穿孔纸卡，织布机</li><li>插线板</li><li>冯诺依曼架构<ul><li>穿孔纸卡</li><li>纸带</li></ul></li><li>面板编程</li></ul><hr><h3 id="11E-The-First-Programming-Languages📝">11E The First Programming Languages📝</h3><ul><li><p>Machine code</p></li><li><p>Pseudo-Code</p><ul><li>转换成二进制的机器语言</li></ul></li><li><p>助记符=&gt;汇编器，汇编语言</p><ul><li>隐去不必要的细节，而去做更复杂的事</li></ul></li><li><p>编译器</p></li><li><p>变量</p></li><li><p>早期语言</p><ul><li>FORTRAN</li><li>COBOL</li></ul></li><li><p>新的语言</p></li></ul><hr><h3 id="12E-Programming-Basics-Statements-Functions📝">12E Programming Basics - Statements&amp;Functions📝</h3><ul><li>语句Statements<ul><li>赋值语句</li><li>游戏初始化</li><li>If判断，条件语句</li><li>while循环</li><li>for循环</li><li>函数（power of abstraction）</li><li>库</li></ul></li></ul><hr><h3 id="13E-Intro-to-Algorithms📝">13E Intro to Algorithms📝</h3><ul><li>算法</li><li>Sorting排序算法<ul><li>选择排序</li><li>归并排序</li></ul></li><li>表示算法的快慢<ul><li>Big O Notation</li></ul></li><li>Graph Search<ul><li>Dijkstra算法</li></ul></li></ul><hr><h3 id="14E-Data-Structures📝">14E Data Structures📝</h3><ul><li>Array<ul><li>index</li><li>String<ul><li>null character</li><li>strcat</li></ul></li><li>Matrix</li></ul></li><li>Struct</li><li>Node</li><li>Pointer指针</li><li>Linked List，利用指针不断指向下一个node</li><li>Queue<ul><li>FIFO</li><li>enqueue</li><li>dequeue</li><li>注意：视频中用链表实现，但是也可以用其他方法实现，比如数组</li></ul></li><li>Stack<ul><li>LILO</li><li>push</li><li>pop</li></ul></li><li>Tree</li><li>Binary Tree</li><li>Graph</li></ul><hr><h3 id="15E-Alan-Turing📝">15E Alan Turing📝</h3><ul><li>可判定性问题</li><li>Lambda算子</li><li>图灵机<ul><li>纸带</li></ul></li><li>图灵完备</li><li>停机问题<ul><li>不是所有的问题都可以通过计算解决</li></ul></li><li>可计算理论——丘奇-图灵论题</li><li>破解德军英格玛加密机</li><li>图灵测试</li></ul><hr><h3 id="16E-Software-Engineering📝">16E Software Engineering📝</h3><ul><li>在函数的基础上再一层抽象——打包成objects（对象）<ul><li>封装组件，隐藏复杂度</li></ul></li><li>OOP面向对象编程 Object Oriented Programming</li><li>API Application Programming Interface<ul><li>public</li><li>private</li></ul></li><li>IDE——Integrated Development Environments集成开发环境</li><li>debug调试<ul><li>用双倍写代码的智商去debug</li></ul></li><li>Readme，comment</li><li>版本控制<ul><li>Code Repository</li></ul></li><li>Alpha、Beta</li></ul><hr><h3 id="17E-Integrated-Circuits-Moore’s-Law📝">17E Integrated Circuits &amp; Moore’s Law📝</h3><ul><li><p>回到电子计算机的诞生年代</p><ul><li>分立元件Discrete components</li><li>数字暴政Tyranny of Numbers<ul><li>如果想继续加强电脑性能，会需要更多部件，导致线路更复杂，难做</li><li>将组件集成起来成为新的组件，Integrated Circuits集成电路</li><li>PCB印刷电路板<ul><li>无需焊接或者连线，采用蚀刻金属线的方式连接</li></ul></li><li>光刻法Photolithography<ul><li>晶圆 Wafer</li><li>光刻胶 PhotoResist</li><li>光掩膜 Photomask</li><li>掺杂 Doping</li></ul></li></ul></li></ul></li><li><p>摩尔定律</p></li><li><p>晶体管数量指数级上升</p><ul><li>VLSI超大规模集成用来生成芯片设计</li></ul></li><li><p>摩尔定律即将失效，有2个问题</p><ul><li>光波长到达极限</li><li>量子隧穿效应</li></ul></li></ul><hr><h3 id="18E-Operating-Systems📝">18E Operating Systems📝</h3><ul><li>操作系统的诞生原因</li><li>batch processing批处理</li><li>操作系统负责抽象硬件<ul><li>Device drivers设备驱动程序，和I/O交互</li></ul></li><li>计算机被I/O阻塞——&gt;多任务处理，调度<ul><li>给每个程序分配内存块</li><li>虚拟内存，抽象实际物理位置</li><li>动态分配内存</li><li>实现了内存保护</li></ul></li><li>Time-sharing</li><li>Multics<ul><li>安全</li><li>过于复杂</li><li>失败了，但是影响力巨大</li></ul></li><li>Unix<ul><li>kernel<ul><li>kernal panic</li></ul></li></ul></li><li>MS-Dos</li></ul><hr><h3 id="19E-Memory-Storage📝">19E  Memory &amp; Storage📝</h3><ul><li>memory 易失性</li><li>storage 非易失性</li><li>早起的存储技术<ul><li>纸卡</li><li>延迟线存储器<ul><li>麦克风 传送</li></ul></li><li>磁芯</li><li>磁带<ul><li>寻址很麻烦</li></ul></li><li>磁鼓存储器<ul><li>转</li></ul></li><li>磁盘</li><li>内存层次结构<ul><li>registers &gt; Cache &gt; RAM &gt; Flash,USB memory &gt; Hard Drives &gt; Tape Backup</li></ul></li><li>软盘<ul><li>只是磁盘是软的，其他基本一样</li></ul></li><li>激光盘</li><li>光盘CD<ul><li>表面是坑，导致反光，表示0和1</li></ul></li><li>固态硬盘SSD</li></ul></li></ul><hr><h3 id="20E-Files-File-Systems📝">20E Files &amp; File Systems📝</h3><ul><li>文件格式（底层都是一大堆二进制）<ul><li>TXT<ul><li>ASCII</li></ul></li><li>WAV<ul><li>metadata：关于数据的数据，通常存在文件开头Header</li><li>存储振幅</li></ul></li><li>BMP<ul><li>位图</li><li>像素：红绿蓝RGB</li><li>开头也是metadata，比如颜色深度，图片大小</li></ul></li></ul></li><li>怎么存文件？<ul><li>文件系统</li><li>目录文件：解决多文件问题，存储其他文件的信息</li><li>平面文件系统</li></ul></li><li>文件紧密的排序会造成重叠的问题，解决方法：<ul><li>把空间划分成一块块</li><li>文件拆分存在多个块里。对应的目录文件也会存储。</li></ul></li><li>删除文件<ul><li>没有擦除数据，只是把记录删了，之后会被覆盖，但是在此之前，数据还在原处</li></ul></li><li>文件的增删改查不可避免地造成文件散落——&gt;碎片整理</li><li>数据爆炸——&gt;分层文件系统<ul><li>文件夹</li><li>目录文件还需要指向目录</li><li>需要额外元数据区分文件和目录</li><li>有一个最大的目录文件叫做根目录（root）</li></ul></li></ul><hr><h3 id="21E-Compressing📝">21E Compressing📝</h3><ul><li>压缩的好处：存更多文件传输也更快</li><li>游程编码Run-Length Encoding</li><li>无损压缩Lossless Compressing<ul><li>解压缩后，数据不变</li><li>消除冗余</li></ul></li><li>霍夫曼树，霍夫曼编码<ul><li>最常见的用最简易的表示：按频率排序</li><li>将树用字典编码</li></ul></li><li>”消除冗余“和“用更紧凑的表示方法”这两种方法通常会组合使用<ul><li>几乎所有的无损压缩都用到了他们</li></ul></li><li>感知编码<ul><li>有损音频压缩</li><li>JPEG</li><li>时间冗余：视频，只需要存变化的部分</li><li>MPEG-4：用补丁的移动和旋转来更新画面</li></ul></li></ul><hr><h3 id="22E-Keyboards-Command-Line-Interfaces📝">22E Keyboards &amp; Command Line Interfaces📝</h3><ul><li><p><strong>人机交互</strong>的过程</p><ul><li><p>早期输出是打印在纸上，输入是用纸卡/纸带一次性把程序和数据传入</p></li><li><p>交互式计算机，time-sharing systems</p></li><li><p>现代打字机QWERTY</p><ul><li>转换成本</li><li>十指盲打</li></ul></li><li><p>电传打字机</p></li><li><p>命令行界面</p><ul><li>ls</li><li>cat</li><li>cd</li></ul></li><li><p>screen</p></li><li><p>terminal</p></li><li><p>Zork</p></li><li><p>MUD</p><ul><li>MMORPG</li></ul></li></ul></li></ul><hr><h3 id="23E-Screens-2D-Graphics📝">23E Screens &amp; 2D Graphics📝</h3><ul><li>早期图形计算机：PDP-1计算机，键盘和显示器分开<ul><li>跟踪程序的运行情况，比如寄存器的值</li></ul></li><li>CRT阴极射线管<ul><li>矢量扫描，引导电子束描绘出形状</li><li>光栅扫描，按固定路径，一行行来</li></ul></li><li>液晶显示器<ul><li>也利用光栅扫描</li><li>早期内存不足无法存储像素，转而存”符号“</li></ul></li><li>字符生成器<ul><li>ROM存着点阵图案</li><li>Screen buffer屏幕缓冲区</li><li>但是没有办法绘制任意图形</li></ul></li><li>CRT的矢量模式<ul><li>为了画任意图形，但是又不吃内存</li><li>所有东西由线表示</li><li>早期电子游戏之一——Space-war</li></ul></li><li>Sketchpad，光笔<ul><li>CAD（Computer Aided Design）：计算机辅助设计</li></ul></li><li>位图显示bitmapped displays</li><li>画矩阵函数</li></ul><hr><h3 id="24E-The-Cold-War-and-Consumerism📝">24E The Cold War and Consumerism📝</h3><ul><li>冷战导致美国往计算机领域投入大量资源</li><li>布什预见了计算机的潜力，提出假象机器Memex，帮助建立基金会</li><li>1950年消费者开始买收音机，日本搭上顺风车</li><li>太空竞赛，Nasa预算增加，用集成电路制作登月计算机</li><li>军事应用推动集成电路发展</li><li>美国制造强大计算机也进一步推动了集成电路</li><li>美国半导体行业忽略消费者市场，开始衰败</li><li>消费者购买商用产品继续推动产品发展<ul><li>家用计算机，游戏机</li></ul></li><li>发展由两股力量推动<ul><li>政府</li><li>消费者</li></ul></li></ul><hr><h3 id="25E-The-Personal-Computer-Revolution📝">25E The Personal Computer Revolution📝</h3><ul><li>1970年代初成本下降，个人计算机可行<ul><li>单周期CPU</li><li>磁带和硬盘</li></ul></li><li>Altair 8800</li><li>比尔盖茨和保罗艾伦写Basic解释器</li><li>Apple-I</li><li>三款开箱即用计算机<ul><li>Apple - II</li><li>TRS-80 Model I</li><li>Commodore PET 2001</li></ul></li><li>IBM意识到个人计算机市场，推出IBM PC，IBM 兼容</li><li>苹果选择了封闭架构，一切都自己来，只有苹果在非“IBM兼容”下保持了足够的市场份额</li></ul><hr><h3 id="26E-Graphical-User-Interfaces📝">26E Graphical User Interfaces📝</h3><ul><li>图形界面先驱：道格拉斯·恩格尔巴特</li><li>1970年成立 帕洛阿尔托研究中心</li><li>1973年完成Xerox Alto 计算机</li><li>窗口的隐喻</li><li>一个简单的GUI系统例子<ul><li>创建一个窗口</li><li>事件驱动编程</li></ul></li><li>1981年 施乐之星系统</li><li>复制、剪切、粘贴的隐喻</li><li>所见即所得 WYSIWYG</li><li>乔布斯参观施乐</li><li>1983年推出Apple Lisa</li><li>1984年推出Macintosh，爆卖</li><li>Windows，微软站稳GUI脚跟<ul><li>Micorsoft Bob失败了</li></ul></li><li>现在的GUI界面都是WIMP的变化版，自然选择的结果</li></ul><hr><h3 id="27E-3D-Graphics📝">27E 3D Graphics📝</h3><ul><li><p>3D 投影</p><ul><li>线性渲染</li></ul></li><li><p>正交投影</p></li><li><p>透视投射</p></li><li><p>简单图像直线即可，复杂多边形用三角形（也被称作多边形）</p><ul><li>网格：一堆多边形的集合</li><li>越密越多细节，但是也需要更多计算量<ul><li>需要有个平衡</li></ul></li><li>三角形够简单，能够定义唯一的平面</li></ul></li><li><p>扫描线渲染</p><ul><li>效果比较粗糙</li><li>减轻锯齿的方法：抗锯齿。就像边缘羽化</li></ul></li><li><p>遮挡问题</p><ul><li><p>画家算法，排序算法</p></li><li><p>深度缓冲，速度更快，选择最小值</p></li><li><p>Z Fighting 错误，两个颜色同概率</p></li></ul></li><li><p>背后剔除</p></li><li><p>明暗处理</p><ul><li>表面法线</li><li>平面着色</li><li>其他上色方法</li></ul></li><li><p>纹理映射</p></li><li><p>GPU</p><ul><li>有专用的RAM</li><li>提供并行处理</li></ul></li></ul><hr><h3 id="28E-Computer-Networks📝">28E Computer Networks📝</h3><ul><li>早期的网络<ul><li>早期的计算机和网络并不是绑定的</li><li>球鞋网络</li></ul></li><li>局域网LAN<ul><li>以太网<ul><li>每台计算机需要有唯一的媒体访问控制地址：MAC地址</li></ul></li><li>载波侦听多路访问CSMA：多台电脑共享一个传输媒介<ul><li>C：Carrier载体</li><li>带宽：载体传输数据的速度</li><li>弊端：冲突<ul><li>解决方法：在重新传送之前等待一小段时间（1s+随机时间）（如果再冲突，变成2s，4s，8s）——&gt;指数退避</li><li>减少冲突域，拆分成更小的冲突域。包括互联网也是这样搭建的。</li></ul></li></ul></li></ul></li><li>路由<ul><li>电路交换</li><li>报文交换<ul><li>报文可能很大会堵塞网络</li><li>记录跳数判断是否出问题——跳数限制</li></ul></li><li>分组交换，再拆分，数据包，格式由IP定义<ul><li>IP地址，以点分隔的4组数字，每台联网的电脑需要</li><li>阻塞控制：路由器会平衡与其他路由器之间的负载，确保传输可以快速可靠</li><li>TCP/IP解决数据包到达乱序问题</li></ul></li></ul></li><li>物联网</li></ul><hr><h3 id="29E-The-Internet📝">29E The Internet📝</h3><ul><li>WAN广域网<ul><li>不断地连到更大的区域，到达互联网主干</li><li>Traceroute</li></ul></li><li>IP-互联网协议<ul><li>metadata</li><li>比较低级</li></ul></li><li>UDP-用户数据报协议<ul><li>有header，header里面包括端口号，checksum检测数据是否正确</li><li>如果checksum不一样，数据可能传输中出现了问题，但是UDP不提供数据修复或数据重发的机制</li></ul></li><li>IP负责把数据包送到正确的计算机，UDP负责把数据包送到正确的程序</li><li>TCP-传输控制协议——&gt;TCP/IP<ul><li>保证所有数据必须到达（区别于UDP）</li><li>也有端口和checksum</li><li>有序号</li><li>收到之后需要发一个确认码，表示收到了（ACK）</li><li>确认码的成功率和来回时间可以推测网络的拥堵程度<ul><li>可以调整，也可以解决乱序问题</li></ul></li><li>最大的问题是：确认码数据包把处理的数量翻了一倍</li></ul></li><li>DNS-域名系统<ul><li>把域名和IP地址端口连接起来</li><li>树状结构</li><li>.com,.gov</li></ul></li><li>OSI-开放式系统互联通信参考模型<ul><li>应用程序层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul></li></ul><hr><h3 id="30E-The-World-Wide-Web📝">30E The World Wide Web📝</h3><ul><li><p>万维网是另一层抽象，不同与互联网</p></li><li><p>万维网的基本单位是单个页面</p></li><li><p>超链接</p></li><li><p>为了让网页相互连接，每个网页需要有个专属的地址，叫URL-统一资源定位器</p></li><li><p>HTTP-超文本传输协议</p></li><li><p>HTML-超文本标记语言</p><ul><li>为了区分什么是链接，什么不是链接</li></ul></li><li><p>网页的标记语言</p><ul><li>HTML</li><li>CSS</li><li>JavaScript</li></ul></li><li><p>搜索引擎</p><ul><li>Yahoo</li><li>人工维护的目录不便利</li><li>JumpStation-最早的搜索引擎<ul><li>爬虫</li><li>不断扩张的索引</li><li>查询索引的搜索算法</li></ul></li></ul></li><li><p>网络中立性</p></li></ul><hr><h3 id="31E-Cybersecurity📝">31E Cybersecurity📝</h3><ul><li><p>保密性：只有有权限的人才能读取计算机系统和数据</p></li><li><p>完整性：只有有权限的人才能使用和修改系统和数据</p></li><li><p>可用性：有权限的人应该随时可以访问系统和数据</p></li><li><p>威胁模型分析</p><ul><li>攻击矢量</li></ul></li><li><p>很多安全问题可以总结成两个问题</p><ul><li>who are you？</li><li>what should you have access to？</li></ul></li><li><p>身份认证的三种方式-让计算机知道使用者是谁</p><ul><li>what you know<ul><li>密码<ul><li>暴力攻击</li></ul></li></ul></li><li>what you have<ul><li>基于用户有特定物体</li></ul></li><li>what you are<ul><li>基于你</li><li>生物识别验证器</li></ul></li><li>多因素认证</li></ul></li><li><p>访问控制Access Control</p><ul><li>ACL（List）</li><li>读</li><li>写</li><li>运行</li></ul></li><li><p>Bell LaPadula model 不能向上读取，不能向下写入</p></li><li><p>软硬件必须可信</p><ul><li>我们怎么确定安全程序没有给攻击者留后门？不能确定</li><li>尽管理论是安全，但是仍可能存在bug</li></ul></li><li><p>安全内核Security kernel/可信计算基础：尽可能少的操作，安全性是可以保证的</p><ul><li>最小化代码数量</li><li>验证代码安全性：独立安全检查和质量验证</li></ul></li><li><p>DEF CON安全大会</p></li><li><p>Isolation隔离：当程序被攻破之后尽可能地减少损失</p><ul><li>SandBox</li><li>虚拟机</li></ul></li></ul><hr><h3 id="32E-Hackers-Cyber-Attacks📝">32E Hackers &amp; Cyber Attacks📝</h3><ul><li>社会工程学——通过欺骗他人<ul><li>钓鱼</li><li>假托Pretexting</li><li>木马<ul><li>勒索软件</li></ul></li><li>NAND镜像</li><li>漏洞利用<ul><li>缓冲区溢出：绕过登录，修改内存<ul><li>边界检查：解决缓冲区溢出问题</li></ul></li><li>代码注入：攻击用数据库的网站<ul><li>SQL：sequel，Structured Query Language，一种流行的数据库API</li><li>SQL注入</li><li>有相应的防御措施</li></ul></li><li>零日漏洞</li><li>蠕虫</li><li>僵尸网络</li><li>DDoS</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么开始写博客？</title>
      <link href="/2022/01/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/01/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="为什么开始写博客？">为什么开始写博客？</h2><p>  很简单的一句话回答就是，<strong>我总是试着输出一些什么</strong>。无论是blog、视频、代码都好。因为只是埋头看课只是自我欺骗，听课是最廉价的一种学习手段，打开电脑，就在那放着，你可以什么都不做，好像自己学到了很多，但其实不然。而写blog的一个初心便是给自己一块自留地，让自己尝试输出一些东西。还有一方面是，希望能在这里记录自己的技术成长路线以及留下些或许可以帮助到大家的记录，造福一下后人。有一些朋友听说我在搭博客的时候，一点不意外，说这就是我会做的事情，想来也确实，我就是这样的人，搭博客好像没有什么理由，是理所当然的一件事情。</p><p>  这个寒假的自学打算</p><ul><li>因为学籍异动的原因，我下学期需要补上线性代数Ⅱ（H），正好人工智能基础让我彻底觉得大一的线代上的跟没上没什么区别，寒假就打算看吴志祥老师的智云补补课<a href="https://classroom.zju.edu.cn/livingroom?course_id=30014&amp;sub_id=436725&amp;tenant_code=112&amp;room_id=315&amp;sub_public=1">线性代数Ⅰ（H）2021-09-15第1-2节 (zju.edu.cn)</a></li><li>大二秋冬一直有在看<em>MIT 6.S081: Operating System Engineering</em>,这个寒假有继续看下去的打算，不过会看实际情况调整</li><li>想把《深入理解计算机系统》（CSAPP）这本书好好看一下</li><li>把一直想看的<em>MIT-Missing-Semester</em>追完</li><li>看实际情况调整，可能会看一下<em>CS50: This is CS50x</em>或者<em>CS61A: Structure and Interpretation of Computer Programs</em></li><li>对crypto、NFT、web3.0进行更深入的研究</li></ul><p>  自学的记录我也会在博客同步更新的，就像我说的那样，输出一些什么。</p><hr><p>  我只喜欢一类人，他们生活狂放不羁，说起话来热情洋溢，对生活十分苛刻，希望拥有一切，他们对平凡的事不屑一顾，但他们渴望燃烧，像神话中巨型的黄色罗马蜡烛那样燃烧，渴望爆炸，像行星抨击那样在爆炸声中发出蓝色的光，令人惊叹不已。</p><p>                            ——杰克·凯鲁亚克《在路上》</p>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二秋冬：计算机和解</title>
      <link href="/2022/01/15/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E5%86%AC/"/>
      <url>/2022/01/15/%E5%A4%A7%E4%BA%8C%E7%A7%8B%E5%86%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>前言</h1><p>  写总结这事的起因还得说到这个学期的一门课，翁恺老师的《面向信息技术的沟通技巧》。刚好这个学期想聊的东西还挺多的，就打算督促督促自己，进行一个总结的写。以下的每个课程都会分为课程简介、关于期末（资料汇总点这👉<a href="https://gitee.com/RyanFcr/is_-course-resource/tree/master">RyanFcr/IS_CourseResource - 码云 - 开源中国 (gitee.com)</a>）</p><p>  话不多说，开启正文！</p><p>（以下内容出现在这里纯属二进制 bit 的随意组合，与本人毫无关系咳咳 👀）</p><hr><h1>专业课</h1><h2 id="面向信息技术的沟通技巧">面向信息技术的沟通技巧</h2><h3 id="课程简介">课程简介</h3><ul><li>先修要求：C 程（<strong>划重点</strong>），<s><em>大腿的识别与接近</em></s></li><li>编程语言：C</li><li>课程难度：🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>主要内容分为</p><ul><li>个人观点表达</li><li>团队有效沟通</li><li>文献检索与有效阅读</li><li>技术文档写作</li><li>如何”卷“好一次展示</li></ul><p>  沟通技巧是我上的翁恺老师的第一门课，第一节课上完之后直呼不愧是网红老师（bushi）。不过不仅仅是因为老师，更是因为这门课本身。沟通技巧是我认为每一位计院学子必上的一门课，而且越早上走的弯路越少。对于我来说，真的学到不少东西，尤其是在文献阅读这一块，让我发现我之前的科研简直是 🤮。但是相应的，投入时间也是比较多的，当然投入越多，收获越大。相信对于这门课的评价一定是两极分化的，不喜欢的同学会觉得耗费时间太多，非常痛苦。</p><p>  沟通技巧是一门有小组作业的课，所以你懂得，需要精准掌握大腿的识别与接近技巧（bushi），不过无论如何，提前找好靠谱的朋友一起组队真的会无限倍提高该门课的体验！平时成绩比较重要，会有小测和课上讨论，而且需要当场提交，上课时间战线很长。</p><h3 id="关于期末">关于期末</h3><p>  期末主要分成选择题和主观题，考前可以刷一下历年卷。我们当时主观题的考察内容</p><ul><li>评价毕业设计论文</li><li>根据英文论文写中文概要</li><li>给大一的小朋友写技术文档，我们写的是 gcd（需要 C 的基础）<ul><li>原理</li><li>源码</li><li>代码如何实现等</li></ul></li></ul><p>  主观题有一个很大的问题是机房的电脑，输入法没有搜狗的，和我们平时用的不一样，打字很费力，费时，考试时间没有我们想象的那么充裕。</p><hr><h2 id="概率论-H">概率论 H</h2><h3 id="课程简介-2">课程简介</h3><ul><li>先修要求：数分 Ⅰ，数分 Ⅱ</li><li>编程语言：无</li><li>课程难度：🌟🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟</li></ul><p>  不同与概统，概率论 H 主要开给统计、图灵班和公管英才班的同学，而内容也主要针对<strong>概率论</strong>，但是相较于概统，概率论的内容讲的更深更难，没有数理统计的内容。而图灵班的同学之后并无数理统计的课程，我觉得培养方案的设计还是有待商榷的，尽管概率论的学习内容更深，但是缺少了数理统计的知识导致我们在“人工智能基础”这门课需要重新自学数理统计的知识，扯回来。</p><p>  我当时的老师是庞天晓老师，教学水平和老师的人品都有目共睹。没有点名。唯一的缺点是每次上课刚开始可以短暂的复习一下之前学过的内容，直接进入正题会出现学生跟不上的情况（没错就是我）。</p><p>  一些感悟，学概率论的时候发现自己大一数学的功底打的太差了，总是需要不断地去复习之前学的内容，是自己之前没有用心学导致的（面壁思过）。呜呜呜呜这个学期还是很认真学了概率论，可惜考试寄了，两位老师都比较求是，所以很看重考试，大家考试一定要加油捏。</p><hr><p>  成绩出来没想到概率论竟是这学期最低寄点，也是这么多数学课的最低寄点 ww</p><h3 id="关于期末-2">关于期末</h3><p>  期末是标准的四个单元，每个单元各出两题，更偏计算，证明不多，我们当时计算量直接裂开，<strong>记得带计算器！</strong></p><hr><h2 id="数据结构基础">数据结构基础</h2><h3 id="课程简介-3">课程简介</h3><ul><li>先修要求：C 小程、C 大程（或者程算）</li><li>编程语言：C</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟</li></ul><p>  这门课是计院学生最重要的专业课之一。也是我这个学期收获最多的几门课之一。我是找计院老师补的陈越姥姥的课，真的可以说姥姥 yyds！姥姥是唯一一位全英文授课 DS 的老师，但是课程内容丝毫不含糊，而且简单易懂。如果上课没听懂的同学，也可以选择直接看姥姥的 mooc 或者知乎、CSDN 查一下知识点。</p><p>  值得一提的是姥姥严格的<strong>查重制度</strong>和 DS 的<strong>互评机制</strong>，一旦被发现，直接取消考试资格。这也间接性地督促我自己独立思考，尽管每次码代码和 debug 的过程异常痛苦，但是能够感受到自己在不断变强，也在自己羸弱的代码基础巩固巩固；互评，个人认为是一个很好的学习他人经验的方式，并且让我们在学校就能接触到最严格的审稿制度。</p><p>  平时上课会有三次随机小测，一般老师都会提前说，在开课前十分钟测，所以千万不要迟到，占平时分比重挺大的！小测抄别人是没有用的，因为大家题目不一样，但是原理是一样的，只是变动数据，所以最重要的当然是自己要理解，做错没事，关键是得学会知识。</p><p>  一些感悟，DS 真的是我这学期最波折的一门课，回想上学期末选课的时候，尽管姥姥是所有 ds 里面唯一的全英教学班，尽管陈越姥姥的查老师风评有很大的争议，但还是听了学长学姐的建议之后，毅然决然地直接从何钦铭班润到了陈越班。开学初的 hard 考试直接没去，因为知道自己就算去了，也只能干坐着。开学后的每一节课，尽管理解有难度，但是每节课都在快速成长，ds 也成了我这个学期唯一一门从未缺席任何一节课的课。Project 一波三折，第一次 Project 忘记 ddl，最后一小时才发现，最后交了个代码；第三次 Project 写完，但是互评没有交上去，直接原地裂开。一大半的平时分就无了，但是这也警醒了自己不要总是对自己掌握时间的能力太过自信，尤其是不要拖 ddl。我也因此立下了 flag，好好学 DS，最终功夫不负有心人，取得了意想不到的成绩。</p><h3 id="关于期末-3">关于期末</h3><p>  尽管在期末之前刷了很多的历年卷，但是考试了之后发现，难度完全不是一个量级，主要体现在判断和选择，填空和函数其实还好。</p><p>  DS 的知识点比较散，考之前很建议近几年的历年卷都刷一遍，进行一个面向历年卷的复习，查漏补缺。</p><p>  做历年卷的时候一个意外发现：每个人期末卷子是不完全一样的，一些题目会修改一点点</p><p>比如</p><ul><li>at most 和 at least</li><li>mul 和 add</li></ul><p>  为了公平，会尽量难度相似，所以会在一些可以出两个的地方出题，这也需要我们更细心地看题目</p><p>比如</p><ul><li>kruskal‘s Algorithm</li><li>prim‘s Algorithm</li></ul><p>  当然也可能一个题目，里面的数据不一样，但是原理是一样的，比如 minheap 转 maxheap 等等</p><hr><h2 id="计算机系统-Ⅱ">计算机系统 Ⅱ</h2><h3 id="课程简介-4">课程简介</h3><ul><li>先修要求：计算机系统 Ⅰ</li><li>编程语言：C,risc-v 指令集</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>  先向对不熟悉这门课的同学介绍一下这门课吧，计算机系统 Ⅰ、Ⅱ、Ⅲ 是计院课改之后将原有的数字逻辑设计、计算机组成、计算机体系结构、操作系统四门课合并之后的系列课程。主要小范围面向信安专业的同学开设，从大一春夏开始上系统 Ⅰ，三学期上完计算机系统。</p><p>  系统 Ⅱ 主要是分为两方面，期中之前接着系统 Ⅰ 的单周期 CPU 继续做了多周期的流水线以及冲突，简单拓展了一些其他技术，比如多发射、超标量、超长指令字等。期中之后，就开启了操作系统的学习，主要分为三块，简单了解操作系统、进程和线程的概念以及调度、同步死锁问题。除此之外，在实验中学习并熟悉了包括 wsl、docker、qemu、gdb、Cli 在内的工具，不断强化自己的武器库。</p><p>  这个学期的感受完全和上学期不一样，系统 Ⅰ 是什么都不知道，完全跟着 TA 做实验，不知道原理，不知道我们要做什么，甚至是实验课才把理论学会；这个学期是自己有了一定的理解，在理论课的基础上，进行实验课的设计，自己有目的性的做实验，同时不再只是盲目的尝试试错，而是有自己的理论设计，再由实验结果来反推，debug 的过程也不再像之前那样毫无头绪，减少了很多痛苦。我也慢慢地理解了老师说的计算机设计平衡的意思。</p><blockquote><p>计算机总有一种方法，是最简单和最理想方式的妥协</p></blockquote><p>  整个学期的体验都非常棒，无论是从理论课还是实验课。这个学期的实验课直接用 Mkdocs 生成了静态网站，已经有点国外 MIT 课的味道了，逼格一下子上来了。本学期的任课老师卢老师和申老师水平确实很高，zyTA 和 zbTA 是全世界最好的 TA，期待下学期的系统 Ⅲ。</p><h3 id="关于期末-4">关于期末</h3><p>  期末和上学期一样，可以带一张 cheeting sheet，但其实内容不多，也没什么好抄在上面的。期末题型不变，题目较简单，大多是课上提到的内容拿出来考考，只要这个学期不摆烂，实验认真做了，基本上没什么问题。</p><blockquote><p>申老师经典语录：“我们都很 nice 的。”</p></blockquote><p>  结果班上有同学五十分钟就做完走人了 🤣</p><hr><h2 id="人工智能基础">人工智能基础</h2><h3 id="课程简介-5">课程简介</h3><ul><li>先修要求：无</li><li>编程语言：python</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>  人工智能基础这门课是专门开给图灵班的，课程难度非常大，先修要求虽然无，但是很多理论推导设计到了大量高深的线性代数和数理统计内容，尤其是数理统计我们还没学。课程内容很多，包含了</p><ul><li>逻辑与推理（知识图谱、因果推理）</li><li>搜索（A*启发式搜索、最小最大搜索、Alpha-Beta 剪枝、蒙特卡洛树搜索）</li><li>机器监督学习（回归分析、决策树、Ada Boosting、支持向量机、生成学习）</li><li>无监督学习（聚类算法、主成分分析、特征人脸识别、EM 算法）</li><li>深度学习（前馈神经网络、CNN、RNN 包括 LSTM，GPU、深度生成学习 GAN）</li><li>强化学习（马尔科夫决策、基于价值的强化学习、时序差分、动态规划）</li><li>人工智能博弈</li></ul><p>  课程基本上把人工智能都介绍了一遍，不过个人感觉还挺好的，充分让我们了解了一下现在人工智能的几个大方向，如果有兴趣的同学可以自行进行深入研究。不过平时学的东西，老师讲的很累，我们听得也比较累，主要还是内容太多太难，不过好在老师和我们彼此反馈，不断地在调整。实验课的lab比较多，总共是7+1bonus，虽然多，但大多数的框架都已经给出，实验的目的也是帮助我们理解课程内容，对于实验，个人的收获提升的还是很多的。当然，会有人说“AI一个project几百行代码大部分都是助教帮你写好的，最后垃圾识别分类和机器人走迷宫不就是调调参数，能学到什么？”。此言差矣，作为一个刚刚接触Python、AI的小白来说，这样完善的代码结构既可以让我们快速上手，理解课堂中的核心知识点，又给了我们“才几周就可以做出来这么棒的东西”很大的成就感，尽管更多的是理解Ta写的代码，但是能够阅读别人高质量的代码，又何尝不是一种提升呢？</p><h3 id="关于期末-5">关于期末</h3><p>  虽然学的内容多，不过好在考的范围和难度都比较和善，但是考试比较细节，较基础。我是黄正行老师和况琨老师班上的，黄正行老师我真的哭死，太好了，他真的太懂我们了，最后一节课直接进行了一个大纲的划，这四十分钟救了全班的命。Btw，最后一节课老师还和我们扯了他读书时候因为看演唱会而挂科的故事 🤣，他以前读书都是平时不用功，考试周每天熬夜，他只希望我们在他这门课上能够不熬夜，还说如果考完觉得不对劲，赶紧联系他进行一个分的调。考完还带着隔壁班进行一个调分，调成了均分 89 的正态分布。他太懂我们了，我真的哭死。</p><hr><h1>类专业课</h1><h2 id="普通物理学-Ⅱ（H）">普通物理学 Ⅱ（H）</h2><h3 id="课程简介-6">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>  之前对于普物的评价是，普物浪费了我一年的时间。选择这个专业也有部分原因是工科中最不用学物理的专业就是计算机类，而我自己对物理简直是深恶痛绝。普物 Ⅰ 和 Ⅱ 都是只有一个目标：不挂。</p><p>  但是很幸运的遇到了我普物 Ⅰ 和普物 Ⅱ 的老师，普物 Ⅰ 的老师潘正权的普物就是高中物理的升级版，他的考试不像物理竞赛，不会和你拐弯抹角，考什么很奇怪的点。而是简简单单的考察知识点，而且全是考 PPT 原题，只要你上课真的认真听了，作业是自己做的，不会太差。整个学期我也没有上的很痛苦。普物 Ⅱ 的老师是万歆老师和 llk 老师，普物 Ⅰ 还是中英双语，到了普物 Ⅱ，就真的是全英文，不过我意外的很喜欢万歆老师的风格，他的作业和考试也不会去扯那些怪题难题，讲课很有逻辑，慢慢地带我们去揭开物理现象背后的本质以及联系，包括万歆老师最喜欢的量子力学，我从没想过自己居然会对物理感兴趣，甚至想选万歆老师下学期的量子力学课，最终还是放弃了这个危险的想法。尽管是全英文，但是老师上课讲的都不是很难，你只要上课花时间听讲，作业认真做，完完全全是可以跟上的。</p><p>  普物完全不需要看书（书又臭又长还是全英），只要看 PPT 就行，仅针对潘正权老师的普物 Ⅰ 和万歆老师、llk 老师的普物 Ⅱ。</p><p>  我觉得潘正权老师和万歆老师非常适合初学者，无论你是只想水水过物理还是对物理感兴趣但是基础差。pzq、wx，我的超人！</p><h3 id="关于期末-6">关于期末</h3><p>  万歆老师和 llk 老师班上的期中和期末都是五道探究题，按老师自己的说法是，五个故事，我们根据五个故事来作答，每道题差不多都有几道小题，小题严格遵循先易后难原则，原则上你只要做出最简单的题目，就可以拿到三分之二的分数，考出来的成绩也如老师预期一样自然成正态分布。所以想水水过的同学只需要掌握最基础的即可。</p><p>  同时我的普物 Ⅰ 和普物 Ⅱ（其他班不一定如此，尤其是普物 Ⅱ，三个老师单独出卷），期末考试的范围都不包含期中考试考查的内容，非常适合补天人。</p><p>  万歆老师尤爱量子力学，期末题型三道量子力学两道光学。其他班基本上不考察量子力学。</p><hr><h2 id="普通物理学实验-Ⅱ">普通物理学实验 Ⅱ</h2><ul><li>先修要求：普物实验 Ⅰ</li><li>编程语言：无/有些项目也要求掌握 python、matlab 等</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟🌟</li></ul><p>普物实验 Ⅱ 有三种选择</p><ul><li>做 14 周小实验</li><li>做 7 周小实验+7 周科创实验</li><li>做 14 周科创实验</li></ul><p>  普物实验 Ⅱ 第一步就是要选实验，选实验的好坏直接决定了这个学期的痛苦程度。选实验这个，大家都懂了，纯靠手速，而且物理实验那个网站非常差，经常奔溃。所以大家要有所准备，我当时提前五分钟进入网站，在倒计时 30s 的时候刷新，结果就卡了一分钟，不过还算好，进去之后只有陈水桥老师的科创实验被选光了，我眼疾手快，选择了郑远老师的”真空实验的设计与研究“。说实话，我一开始对普物实验 Ⅱ 的定位就是，这门课对我帮助不大，赶紧进行一个大腿的识别和靠近，水过去就完事了，况且自己这物理水平，实在是不敢恭维。好在老师和队友们都太靠谱了，就让我这门课的体验非常好，在课程结束之后，还跟着郑远老师一起在做“真空实验+深度学习识别”有关的课题，体验非常好。</p><hr><h2 id="军事理论">军事理论</h2><h3 id="课程简介-7">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟🌟</li><li>花费时间：🌟</li></ul><p>  我是预置的吕强老师，吕强老师上课幽默风趣，不过我上课基本上都在干自己的事情，最后也只是水水过了。不过对于军事感兴趣的同学，大可以享受到和老师交流碰撞的乐趣，上课的内容除了中间军事技术的三节课，其他基本上和考试关系不大，更多的是历史、故事，感兴趣的同学也不妨听听。Btw，之后的军理课好像改版了，这里的建议仅供参考。</p><h3 id="关于期末-7">关于期末</h3><ul><li><p>准备资料：</p><p>目录、领导人强军资料、精简版军事技术部分 PPT、书即可。</p></li></ul><p>  个人的建议是首先把题目区分成和领导人有关的和书有关的内容，先把有关领导人强军思想的题目给做完。而对于其他题，对于开卷考，需要考虑的是速度和准确度的平衡。我的方法是先进行定位，然后找目录，对于军事技术部分先参考 PPT，找不到再统一找书。</p><hr><h2 id="马克思主义基本原理概论（H）">马克思主义基本原理概论（H）</h2><h3 id="课程简介-8">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟🌟</li><li>花费时间：🌟🌟</li></ul><p>  我上的是吴旭平老师的马原 H，上这么课之前，阅读过 yay 学长的文章<a href="https://www.cc98.org/topic/5137370">一个计院学生的大二春夏：数学、计算机及其他 - CC98 论坛</a>（需要校网），本来自己在上马原之前对马克思主义完全是不了解的状态，自己也希望通过这门课来构建自己对马克思主义的简单了解以及搭建自己的哲学框架。 我就降低了自己的期待值。一个学期上下来，老师上课很有趣，延伸的内容还挺有意思的，虽然和考试无关，但是我记了近半个学期的笔记，现在拿出来看看，有一些观点还是很有启发的。（别问为什么半个学期，后面半个学期都在补其他课的天）。网课期间，老师也秀了自己的猫猫“康德”，看得出来老师也很喜欢我们班。总体上课体验挺好，唯一有点难受的是老师不允许打开电脑，让我有点难受，本来是电脑记笔记的，被强行改成了手写笔记。</p><h3 id="关于期末-8">关于期末</h3><p>  平时分只有辩论输了还没有发言的同学才不会满（比如我），无正态。吴旭平老师的平时分有很多加分项，只要你想满，卷一卷还是很容易就拿满的。不过马原期末有斩杀线，所以还是有点慌的。考试周一开始就先进行了一个面向历年卷的拟合，不过后来发现很多都是无效训练，在对内容知识不了解的情况下的训练，最终训练出来的我，十道题能错五六道。只得重新认真看书，一边看书，一边做题拟合，选择题都考的比较细，可以先粗粗的过一遍所有知识点，再根据题目进行翻书复习。</p><blockquote><p>出分之前，平时分都没满，摆了摆了，不挂就行</p><p>出分之后，呜呜，老师给分太好了！</p></blockquote><hr><h2 id="新制度经济学">新制度经济学</h2><h3 id="课程简介-9">课程简介</h3><ul><li>先修要求：无严格要求，但修过经济学课程更好</li><li>课程难度：🌟🌟🌟🌟</li><li>花费时间：🌟🌟🌟</li></ul><p>  新制度经济学是我严格意义来说的第一门和经济有关的课，尽管我对经济学很感兴趣，但是在此之前，从未系统的对经济学有过深入详细的了解，只是感兴趣。很感谢新制度经济学这节课给我这个机会去了解经济学，最大的收获是思维上的提升，无论是课上的内容还是讨论课的延伸，很多生活上的问题，我逐渐学会从经济学的角度去思考问题，经济学也并没有我想象的那么功利，那么无聊。</p><p>  个人经过一个学期上下来，感觉内容确实过多，较充实，不过也存在着总是老师讲，比较枯燥无聊的问题，可以考虑适当删减内容，以放缓节奏；同时在理论课不再是单纯的讲解，加入互动，互动回答好的实行奖励政策，如一道苹果计算题等，让同学们更融会贯通。</p><p>  我之前没有上过通核，也没有讨论课。整体来说，这个学期的讨论课可以说是我的一个避难所，上了一天的课比较累，来讨论课聊聊天，一个讨论教室里同学们的观点都很有意思，讨论的话题也比较新颖有趣。</p><p>  这个学期的期末考取消了，改成大论文，听说这门课要课改，期末参考意义不大。</p><hr><h2 id="职业生涯规划-B">职业生涯规划 B</h2><h3 id="课程简介-10">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟</li><li>花费时间：🌟🌟🌟🌟🌟</li></ul><p>  我觉得职规是每位大学同学都必须要上的一门课，而且强烈建议大一大二上。我是因为学籍异动选上的蔡云老师。嘿嘿，蔡云老师就不用说了，职规体验直接拉满了。虽然每节课后的讨论会花相当长的一部分时间，但是我觉得都是对我成长很有帮助的，也在帮我不断认清自己的道路以及成长方向。最后我其实想说职规这门课关键的是他带给了你什么，这些东西已经远超绩点了，包括其实并非只有蔡云老师好，其实很多老师可能给分差或者评分不高，但是都是很优秀的老师，相信他们的职规课一样可以带给你足够的成长。</p><hr><h2 id="农事劳动实践">农事劳动实践</h2><h3 id="课程简介-11">课程简介</h3><ul><li>先修要求：无</li><li>课程难度：🌟🌟</li><li>花费时间：🌟🌟🌟</li></ul><p>  这门课是我秋学期补选上的，同时满足劳育和博雅技艺，可以说是非常抢手的一门课。抛开这些不说，每周的农事劳动实践的内容都很充实，不仅施肥种树种花，还抓虫搞园艺，虽然体力消耗非常大，不过每一周都值得发一条朋友圈！不过这门课很难区分开来，就导致给分比较差，主要评分为理论课上的点名、小测签到和最后的大论文，记得每周都记录一下写一下小日记，这样最后大论文会很方便。</p><hr><h1>最后一点碎碎念</h1><p>  整体对大二秋冬很满意，相较于上个学期学分突然猛增的不适宜，这个学期更多的是从容。（上个学期 39 学分后来退课至 35，本学期 36 学分）有两点特别值得一说。</p><p>  第一点是，我越来越崇尚ROI（投入产出比）、优先级的思维和成长思维来解决问题，对于一件事情，不再是绩点驱动、退院驱动，反而更看重的是这件事情对我自身的成长帮助有多大，他的性价比有多高，优先级是多少，”越做越爽“思维；而对于低优先级的事情，想办法围绕着提升自己做文章，提升优先级，并且多做“顺风车”。这个学期没有比上个学期少事情，但是我主动舍弃了很多ROI低的事情或者对自己无帮助无意义的琐事，当选择在面前时，自然而然地选择性价比更高的，而不是全都要。而当我在做一件性价比很高并且能够给我带来很大成长的事情时，我会获得更大的正反馈，不断地刺激分泌多巴胺让我去做这件事情，直到我对这件事情上瘾，不断地循环，形成正向反馈，越做越爽，越爽越做，进入心流。对于“顺风车”，我举个例子，沟通技巧布置了一个写文献综述的作业，那我就“顺便”研究一下自己感兴趣的领域，这样既完成了作业，又给自己一个机会研究感兴趣的领域；新制度经济学要交论文，我刚好觉得自己感兴趣的Defi（去中心化金融），GameFi很适合这个论文，刚好趁这个机会再深究一下，军理交一篇论文，刚好可以研究一下自己完全未涉猎的阿富汗战争，而不是以前的水一篇论文就完事；做DS的作业的时候在考虑用简单熟练的邻接矩阵表示图好还是用不太熟练的邻接表好，当时想的是，这正是一个很好的机会复习一下不太熟练的邻接表，尽管花了更多的时间，但是比起用邻接矩阵我成长的更多；再比如朋友找我打Kic(毕马威商赛)，当时想的是毕马威是商赛中的创赛，刚好能够再锻炼一下自己的创新思维，而且毕马威很看技术，而且需要用到AI的内容，刚好能把所学的知识运用一下。</p><p>  当你用这样的思维思考的时候，你会发现你在越来越擅长你自己的领域，浅显的说可以从我这个学期绩点体现出来，主修均绩大幅上升，并且这个学期满绩的数量超过了大一总和，与此同时绩点下 4 的数量也是历史新高。很多课比如普物、普物实验、军理、马原等，可能对我未来成长帮助不大，他的优先级就会降低，运用 OS（操作系统）里的概念，这样就会发生 Starvation（饥荒），导致这些虽然对我帮助不大的事情没有被做完，这样的影响也非常大，所以需要进行优先级的升级，就用到顺风车思维或者靠 ddl 提升优先级，这样足以支撑我完成这门课的学习，而且不会花太多的时间做无意义的边际收益很低的事情。</p><p>  第二点是，我越来越爱上我的专业，可以说，我和计算机和解。这个学期和朋友聊起大家为什么选择这个专业的时候，我回想了一下，高中的我甚至都没有摸过计算机，也就选了技术和计算机沾点边。高中其实完全对专业不了解，当时自己也只是对几个专业完全不喜欢，其他专业都差不多，这也是为什么我还去了强基计划，当时觉得读基础学科也无所谓，打心底更看重学校罢了，结果高考分卡在了一个很尴尬的位置，在南大人工智能和浙大工信里毅然决然的选择了工信，因为留在浙江，认识的人多。进入工信之后，第一件大事就是选专业，我当时也是觉得什么专业都好，对信息安全比较感兴趣，虽然我是电脑小白一个，但是好歹也是知道黑客是什么，当时觉得黑客很酷，加上自己擅长数学、英语，最不喜欢物理，就选了信息安全，也顺利通过了面试。大一上读了一年，其实对专业也完全没有清晰的认识，直到大一下。</p><p>  大一下的专业课让我觉得自己对信息安全的认识和他本身有强烈的偏差，学业的压力和同学的 peer pressure 给我造成了很大的打击，让我产生了我是否适合学习计算机的念头。一个学期下来，痛苦。我发现我不喜欢我的课，我没有那么收获，更多时候我只是想应付过去，我开始另寻出路，对区块链感兴趣的我联系了导师想做相关的项目，在导师的帮助下，我们先做了安全加密方面的研究，发现自己对这方面有点感兴趣，密码学也很有意思；对创新创业感兴趣的我开始积极探索，我感受到了成长、收获的快乐，当我无法从 A 获得成就以及成长而能从 B 获得的时候，自然而然，我就慢慢开始抵触 A，一有时间我就会花在 B 上，因为我能够获得的正反馈更多，不断地恶性循环，我开始用其他方面的优势来伪装自己，但其实脆弱不堪，我也知道这不是长久之计。</p><p>  时间回到大一下的暑假，我用了很长的时间和计算机和解。我试着不那么抵触他，我重新看完了本是图灵大一上学习的程算课，我逐渐发现计算机是很有意思的一门学科，不再是之前的死记硬背；同时，我开始学会如何高效的使用电脑，如何用电脑记笔记，一些快捷键如何使用，一些好用的软件、插件，这些都是能够给我带来即时正反馈的事情，并且让我持续不断地获得成长和快乐并且持续做下去。我带着这样的思维开始了大二上的学习，慢慢地，我能理解我们专业正在做什么，这些课正在做什么，同时我对区块链、NFT 感兴趣，而他们也正好是我们专业（信息安全）下面的研究领域，兴趣促使着我去学习，学习获得成长，又反促进兴趣，这样不断正反馈循环，不断进入心流。这个学期给我思维上带来最大改变的两门课是计算机系统 Ⅱ 和人工智能基础，计算机系统这个学期更多的是我们自己去设计一些东西，无论是流水线的设计还是操作系统的设计，设计这件事情给我带来了很大的快乐。我高中受美术老师的影响，就一直很喜欢艺术，很喜欢创造，也因此开始喜欢文学，所以当我把计算机创造这件事和艺术创造联系起来的那一刻，我觉得他们太像了，计算机本来就是人创造出来的，计算机语言为什么也被称作<code>language</code>是有原因的，计算机的代码就和写诗一样，那一刻我真的疯狂的爱上了计算机，我发现我创造出来的东西居然还不赖，我也可以设计出来很有意思的东西，包括现在写的 blog，我也可以通过计算机写一个主页，可以上传我写的东西，这本身就是一件很酷的事情。</p><p>  说说人工智能基础，人工智能基础这门课让我对学习有了更深的认识。重新塑造了我自己的学习观，我慢慢地把自己的大脑当成一种算法，当成机器，无数的 input 输入，将我自己训练成一个合适的模型，成功输出。因此，我在不断改善自己的学习方法，改正学习的坏习惯，以机器学习的视角看待自己的学习，这里我强烈推荐 B 站 up 主<code>YJango</code>的学习观系列视频（<a href="https://space.bilibili.com/344849038?from=search&amp;seid=12975206688607334651&amp;spm_id_from=333.337.0.0">YJango的个人空间_哔哩哔哩_bilibili</a>）。</p><p>  总结一下这个学期，整体来说可以说非常满意了，因为我每一天都在知道，我正在变得更好，我已经在路上。</p>]]></content>
      
      
      <categories>
          
          <category> 2022寒假 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
