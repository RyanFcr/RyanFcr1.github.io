<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>《深入理解计算机系统CSAPP》（二） | Sisyphus's blog</title><meta name="keywords" content="学习笔记"><meta name="author" content="RyanFcr"><meta name="copyright" content="RyanFcr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一直很想看的一本书，寒假开始自学，边学边记一些笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入理解计算机系统CSAPP》（二）">
<meta property="og:url" content="http://example.com/2022/01/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/index.html">
<meta property="og:site_name" content="Sisyphus&#39;s blog">
<meta property="og:description" content="一直很想看的一本书，寒假开始自学，边学边记一些笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/mmexport1612147589760.jpg">
<meta property="article:published_time" content="2022-01-27T16:00:00.000Z">
<meta property="article:modified_time" content="2022-02-26T06:18:27.752Z">
<meta property="article:author" content="RyanFcr">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/mmexport1612147589760.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/01/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: RyanFcr","link":"链接: ","source":"来源: Sisyphus's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《深入理解计算机系统CSAPP》（二）',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-02-26 14:18:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 一些宝藏</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/mmexport1612147589760.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Sisyphus's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 总览</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 一些宝藏</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《深入理解计算机系统CSAPP》（二）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-27T16:00:00.000Z" title="发表于 2022-01-28 00:00:00">2022-01-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-26T06:18:27.752Z" title="更新于 2022-02-26 14:18:27">2022-02-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/2022%E5%AF%92%E5%81%87/">2022寒假</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《深入理解计算机系统CSAPP》（二）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>《深入理解计算机系统CSAPP》（二）</h1>
<p>  在Github上找到这样两个项目，相信对自学CSAPP的同学会有帮助</p>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/EugeneLiu/translationCSAPP">EugeneLiu/translationCSAPP: 为 CSAPP 视频课程提供字幕，翻译 PPT，Lab。 (github.com)</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://github.com/Exely/CSAPP-Labs">Exely/CSAPP-Labs: Solutions and Notes for Labs of Computer Systems: A Programmer’s Perspective 3rd Editon // 《深入理解计算机系统》第三版的实验文件、解答与笔记 (github.com)</a></p>
</li>
</ul>
<p>  B站视频链接👇</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iW411d7hd?p=1">【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频_哔哩哔哩_bilibili</a></p>
<p>  笔记主要由书上章节分类，而非课程视频的分集。</p>
<p>  笔记一部分参考知乎博主<a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1212802114247979008">CSAPP+SICP - 知乎 (zhihu.com)</a>以及搬运书上原话。</p>
<h2 id="Lecture-03-Machine-Level-Programming📝">Lecture 03 Machine Level Programming📝</h2>
<h3 id="3-1-History-of-Intel-Processors-and-architectures">3.1 History of Intel Processors and architectures</h3>
<ul>
<li>使用机器语言可以获得
<ul>
<li>PC</li>
<li>Register</li>
<li>Condition Codes</li>
</ul>
</li>
<li>Intel的处理器系列被称为x86，x86对于英特尔处理器来说是一个口头的称谓，原因是第一个芯片被称为8086，然后他们跳过了81，随后推出了8286、8386等等，共同点都有86，所以人们称它位x86。
<ul>
<li>8086，8086是第一个16位微处理器，它出现在1978年。</li>
<li>i386</li>
<li>……向后兼容</li>
</ul>
</li>
<li>CISC 复杂指令集 vc RISC 精简指令集（ARM，Risc-v）</li>
<li>IA32，x86-64</li>
<li>竞争对手AMD
<ul>
<li>率先突破x86-64</li>
</ul>
</li>
</ul>
<h3 id="3-2-C，assembly，machine-code">3.2 C，assembly，machine code</h3>
<ul>
<li>
<p>ARM：Acorn RISC Machine</p>
<ul>
<li>功耗更低，更简单</li>
</ul>
</li>
<li>
<p>一些定义的明确</p>
<ul>
<li>ISA：指令集架构，机器级程序的格式和行为，定义了处理器状态、指令的格式，以及每条指令对状态的影响。
<ul>
<li>Intel：x86，IA32</li>
<li>ARM：很多手机上的</li>
</ul>
</li>
<li>微架构microarchitecture是ISA这个架构的实现</li>
</ul>
</li>
<li>
<p>对于机器级编译两层抽象很重要</p>
<ul>
<li>ISA</li>
<li>虚拟内存</li>
</ul>
</li>
<li>
<p>将C代码翻译为目标代码的过程：</p>
<ol>
<li><strong>预处理器</strong>会扩展源代码，插入所有用<code>#include</code>指令的文件，扩展所有用<code>#define</code>声明指定的宏。</li>
<li><strong>编译器</strong>基于编程语言的规则、目标机器的指令集和操作系统的惯例，会将源代码转换为汇编代码作为输出，给出程序的每一条指令。</li>
<li><strong>汇编器</strong>将汇编代码转化为二进制目标代码文件，它是机器代码的一种形式，包含了所有指令的二进制表示，但是还没有填入全局值的地址。</li>
<li><strong>链接器</strong>将目标代码文件和实现库函数的代码合并，产生最终可执行代码文件。</li>
</ol>
<ul>
<li>.c——&gt;.s——&gt;.o——&gt;p</li>
<li>编译器——&gt;汇编器——&gt;链接器</li>
<li>-og优化</li>
<li>汇编代码中以“.”开头的行都是指导汇编器和链接器工作的伪代码，可以忽略</li>
<li>变量所有名称在汇编、机器代码级别完全丢失了，变成了寄存器和内存中的某个位置。</li>
</ul>
</li>
<li>
<p><strong>编译器</strong></p>
</li>
</ul>
<p> <code>gcc - Og -S xx.c </code>得到<code>xx.s </code></p>
<ul>
<li><strong>汇编器</strong></li>
</ul>
<p> <code>gcc -Og -c xx.c</code>进行编译和汇编，生成二进制文件<code>xx.o</code>，可以通过反汇编器，<code>objdump -d xx.o</code> ，将可执行文件转换成汇编代码</p>
<p> 发现</p>
<ol>
<li>每个指令需要的字节数不同，有的两个，有的三个……</li>
<li>每个指令有自己对应的编码</li>
<li>反汇编得到的汇编代码和直接生成的有差异</li>
</ol>
<p> 同样可以使用<code>gdb</code>然后输入<code>disassemble</code>来反汇编代码</p>
<ul>
<li><strong>链接器</strong></li>
</ul>
<p> 使用链接器将目标代码文件转化为可执行代码。要求：目标代码文件中必须含有一个<code>main</code>函数，作为程序的入口。按<strong>书上</strong>的指令：<code>gcc -Og -o prog main.c mstore.c</code>，链接了main.c和mstore.c，生成可执行文件prog。</p>
<p> 可以发现和汇编器生成的区别有：</p>
<ol>
<li>链接器将代码移到了新的地址范围内。</li>
<li>链接器补充了调用函数<code>mult2</code>需要使用的地址。</li>
<li>多了两行<code>nop</code>，可以使得函数代码变成16字节，更好放置下一个代码。</li>
</ol>
<ul>
<li>数据格式
<ul>
<li>不区分符号和无符号的存储方式</li>
<li>指针也是以数字的形式存储的</li>
<li>b 字节 8</li>
<li>w 字 16</li>
<li>l 双字 32</li>
<li>q 四字 64</li>
<li>浮点数是4字节、8字节、10字节
<ul>
<li>浮点数以和整型数据完全不同的方式进行处理，并且使用完全不同的寄存器组。</li>
</ul>
</li>
<li>数据结构这些是编译器实现的</li>
</ul>
</li>
<li>每条指令能做的事情比较有限</li>
</ul>
<h3 id="3-3-Assembly-Basics：Registers，operands，move">3.3 Assembly Basics：Registers，operands，move</h3>
<ul>
<li>一个x86-64的CPU中包含16个存储64位值的通用目的寄存器，可以用来存储整数数据和指针。有些寄存器有<strong>特殊用途</strong>，是约定俗成的
<ul>
<li>sp 栈指针</li>
<li>ecx count</li>
<li>e<strong>b</strong>c —— base等等 但是其实我们已经不需要知道了</li>
<li>%r 64位</li>
<li>%e 低32位</li>
<li>可以对1、2、4、8字节进行操作</li>
</ul>
</li>
</ul>
<h4 id="3-3-1-操作数指示符">3.3.1 操作数指示符</h4>
<p> 大多数指令由一个或多个操作数（Operand），指示出一个操作中要使用的元数据值，以及放置结果的目的位置。</p>
<p> 操作数包含三种类型：</p>
<ul>
<li>**立即数（Immediate）：**用来表示常数值，书写格式是在<code>$</code>后面跟一个标准C表示法表示的整数，比如<code>$-577</code></li>
<li>**寄存器（Register）：**表示某个寄存器的内容。</li>
<li>**内存引用：**它会根据计算出来的地址访问某个内存位置。有不同的寻址模式，最常用的是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo stretchy="false">(</mo><msub><mi>r</mi><mi>b</mi></msub><mo separator="true">,</mo><msub><mi>r</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>M</mi><mi>e</mi><mi>m</mi><mo stretchy="false">[</mo><mi>R</mi><mi>e</mi><mi>g</mi><mo stretchy="false">[</mo><mi>R</mi><mi>b</mi><mo stretchy="false">]</mo><mo>+</mo><mi>S</mi><mo>∗</mo><mi>R</mi><mi>e</mi><mi>g</mi><mo stretchy="false">[</mo><mi>R</mi><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>D</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Imm(r_b,r_i,s) = Mem[Reg[Rb]+S*Reg[Ri]+D]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">b</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">]</span></span></span></span> ，其中，<strong>要求寄存器大小都是64位的</strong>，才能完整索引整个虚拟内存空间，并且不能使用<code>%rsp</code>。常用括号来简化。</li>
</ul>
<p> 源操作数是一个立即数，可以直接是一个立即数或者保存在寄存器或内存里，目标操作数是一个位置，可以是寄存器或内存</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203153547387.png" alt="image-20220203153547387"></p>
<h4 id="3-3-2-Mov">3.3.2 Mov</h4>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203153700360.png" alt="image-20220203153700360"></p>
<p> <strong>注意</strong>：</p>
<ul>
<li>
<p>两个操作数不能同时为<strong>内存</strong>地址。如果要在两个内存位置传输数据，必须用一个寄存器进行中转。</p>
</li>
<li>
<p>使用到的寄存器大小一定要和指令最后一个字符指定的大小匹配。</p>
</li>
<li>
<p><code>movl</code>以寄存器为目的时，会将寄存器的高位4字节置0。</p>
<ul>
<li>x86-64的惯例：任何为寄存器生成32位值的指令都会把该寄存器的高位部分置0</li>
</ul>
</li>
<li>
<p>如果用<code>movq</code>来传输立即数时，该立即数只能表示为32位补码，然后扩展到64位的值。而<code>movabsq</code>能够以任意64位立即数作为源操作数，并且只能以寄存器作为目的。</p>
</li>
<li>
<p>一共五种组合</p>
<p>a. I - R</p>
<p>b. I - M</p>
<p>c. R - R</p>
<p>d. R - M</p>
<p>e. M - R</p>
</li>
</ul>
<p>寄存器可以作为临时存储的工具</p>
<h5 id="源寄存器小于目的寄存器">源寄存器小于目的寄存器</h5>
<p> 在将较小的源值复制到较大的目的时，提供两个类<code>MOVZ</code>和<code>MOVS</code>。<code>MOVZ</code>是将目的中剩余的字节填充0，<code>MOVS</code>是将目的剩余的字节填充符号位的值。它们每条指令后面都有两个字符，分别表示源大小和目的大小。</p>
<ul>
<li>不存在<code>movzlq</code>，可以直接使用<code>movl</code>。因为当使用<code>movl</code>传输数据到32位目的寄存器中时， 会自动将目的寄存器的高位4字节置零。</li>
<li><code>cltq</code>没有操作数，总是以<code>%eax</code>作为源寄存器，以<code>%rax</code>作为目的寄存器，等价于<code>movslq %eax,%rax</code>。</li>
</ul>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203153833268.png" alt="image-20220203153833268"></p>
<h5 id="源寄存器大于目的寄存器">源寄存器大于目的寄存器</h5>
<ul>
<li>强制类型转换</li>
<li>先保存到寄存器中，再保存到内存</li>
</ul>
<p>综上：</p>
<ol>
<li>两个指针之间进行传输，由于是直接对内存进行操作的，所以需要先经过一个寄存器。</li>
<li>小的数据类型转换到大的数据类型，是根据前面的数据类型决定是<code>MOVZ</code>还是<code>MOVS</code>。</li>
<li>大的数据类型转换到小的数据类型时，先将其保存得到寄存器中，再将部分保存到内存中。</li>
</ol>
<h4 id="3-3-3-压入和弹出栈数据">3.3.3 压入和弹出栈数据</h4>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203154627151.png" alt="image-20220203154627151"></p>
<blockquote>
<ol>
<li>栈指针%rsp保存这栈顶元素的地址</li>
<li>我们的栈是倒过来画的，因而栈“顶”在底部</li>
<li>先进行算术操作再压或者读</li>
<li>当pop的时候，并没有抹去那个元素，只是栈指针变动，栈顶元素仍然保留在内存中</li>
</ol>
</blockquote>
<h3 id="3-4-Arithmetic-logical-operations">3.4 Arithmetic &amp; logical operations</h3>
<p> 以下列出了x86-64中的一些算数和逻辑操作，除了<code>leaq</code>以外，其他都有对不同大小数据的指令。</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220124230420590.png" alt="image-20220124230420590"></p>
<ul>
<li>
<p><code>leaq S D</code>是将S计算出的地址付给寄存器D。通常会被用来执行<strong>加法和有限形式的乘法</strong>。比如对于比例变址寻址$Imm(r_b,r_i,s) $  ，得到的地址会是  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>m</mi><mi>m</mi><mo>+</mo><msub><mi>r</mi><mi>b</mi></msub><mo>+</mo><msub><mi>r</mi><mi>i</mi></msub><mo>∗</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">Imm+r_b+r_i*s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">m</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span></p>
<blockquote>
<p>目的操作数只能是寄存器。</p>
</blockquote>
</li>
<li>
<p>一元操作符中，操作数可以是寄存器也可以是内存地址。既是源又是目的。</p>
</li>
<li>
<p>二元操作符中，第一个操作数可以是立即数、寄存器或内存地址；第二个操作数可以是寄存器或内存地址。</p>
</li>
<li>
<p>移位操作中，第一个操作数可以是立即数或放在单字节寄存器<code>%cl</code>(rcx的low八位)中，第二个操作数可以是寄存器或内存位置。</p>
<blockquote>
<p>如果我们对w位的数据进行移位，则只考虑<code>%cl</code>中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>w</mi></mrow><annotation encoding="application/x-tex">log_{2}{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></span>位，保证不会将数据移出边界。 比如<code>salb</code>只会考虑寄存器低3位的值（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>8</mn></mrow><annotation encoding="application/x-tex">log_{2}{8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">8</span></span></span></span></span>），<code>salw</code>只会考虑寄存器低4位的值（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mn>16</mn></mrow><annotation encoding="application/x-tex">log_{2}{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">1</span><span class="mord">6</span></span></span></span></span>），以此类推。</p>
</blockquote>
</li>
<li>
<p>128位乘法<img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203160519869.png" alt="image-20220203160519869"></p>
<ul>
<li>将占用<code>%rax</code>的数据<code>mov</code>到别的寄存器中</li>
<li>将其中一个乘数<code>mov</code>到<code>%rax</code>中</li>
<li>如果是有符号乘法，就使用<code>imul</code>，如果是无符号乘法，就是用<code>mul</code></li>
<li>对结果进行保存，比如保存在<code>(%rdi)</code>中：如果是在小端机器中，则为<code>movq %rax, (%rdi)</code>，<code>movq %rdx, 8(%rdi)</code>；如果是大端机器中，则为<code>movq %rax, 8(%rdi)</code>，<code>movq %rdx, (%rdi)</code>。</li>
</ul>
</li>
<li>
<p>除法</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203160906931.png" alt="image-20220203160906931"></p>
<blockquote>
<p>书上的图有一些错误，应该为rax存储商，rdx存储余数</p>
</blockquote>
<p>其中<code>R[%rdx]:R[%rax]</code>表示将两个寄存器的值拼接起来作为一个数，其中寄存器<code>%rdx</code>是高八字节，<code>%rax</code>是低八字节。它这里只有一个操作数表示除数，而被除数保存在<code>%rax</code>和<code>%rdx</code>中。</p>
<p><strong>有符号数除法：</strong></p>
<ol>
<li>将占用<code>%rax</code>和<code>%rdx</code>的数据<code>mov</code>到别的寄存器中</li>
<li>将被除数中的64位<code>mov</code>到<code>%rax</code>中</li>
<li>如果被除数是64位的，则要用<code>cqto</code>根据<code>%rax</code>中的最高有效位对<code>%rdx</code>进行符号扩展；如果被除数是128位的，就将剩下的64位<code>mov</code>到<code>%rdx</code>中</li>
<li>使用<code>idiv</code>进行计算。</li>
</ol>
<p><strong>无符号数除法：</strong></p>
<ol>
<li>将占用<code>%rax</code>和<code>%rdx</code>的数据<code>mov</code>到别的寄存器中</li>
<li>将被除数中的64位<code>mov</code>到<code>%rax</code>中</li>
<li>如果被除数是64位的，则使用<code>xorq %rdx, %rdx</code>将高64位置零；如果被除数是128位的，就将剩下的64位<code>mov</code>到<code>%rdx</code>中</li>
<li>使用<code>div</code>进行计算。</li>
</ol>
</li>
</ul>
<blockquote>
<ol>
<li>以上操作除了右移以外，在无符号数和补码间都是通用的，也体现了补码的优势。</li>
<li>可以使用<code>xorl %edx, %edx</code>来对寄存器<code>%rdx</code>置零。</li>
</ol>
</blockquote>
<h3 id="3-5-Control">3.5 Control</h3>
<h4 id="3-5-1-Condition-codes条件码">3.5.1 Condition codes条件码</h4>
<p>除了寄存器，CPU还维护一些条件码寄存器</p>
<ul>
<li>CF（Carry），用于检查无符号数的溢出</li>
<li>ZF（Zero），判断最近的操作结果是否是0</li>
<li>SF（Sign），判断符号</li>
<li>OF（Overflow），判断有符号的溢出</li>
</ul>
<blockquote>
<ol>
<li>
<p>Lea不会改变任何条件码</p>
</li>
<li>
<p>逻辑操作的CF和OF会设置成0</p>
</li>
<li>
<p>移位操作CF会被设置为最后一根被移出的位，OF = 0</p>
</li>
<li>
<p>INC和DEC会设置OF和ZF，不会改变CF</p>
</li>
</ol>
</blockquote>
<p>x86-64提供了另外两类指令，<strong>只会设置条件码而不会改变目的寄存器</strong>：</p>
<ul>
<li>
<p><code>CMP S1, S2</code>：用来比较<code>S1</code>和<code>S2</code>，根据<code>S2-S1</code>的结果来设置条件码。主要用来比较两个数的大小。</p>
<blockquote>
<p>注意顺序</p>
</blockquote>
</li>
<li>
<p><code>TEST S1, S2</code>：用来测试<code>S1</code>和<code>S2</code>，根据<code>S1 &amp; S2</code>的结果来设置条件码。可以将一个操作数作为掩码，用来指示哪些位用来测试。比如<code>testq %rax, %rax</code>就可以检查<code>%rax</code>是正数、负数还是0。</p>
<blockquote>
<p>test主要是用一个操作数</p>
</blockquote>
</li>
</ul>
<p>除此之外还有一些set指令，可以改变寄存器的值</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203170737152.png" alt="image-20220203170737152"></p>
<p>这里的目的操作数是<strong>低位单字节寄存器</strong>，或者一个字节的内存位置。如果要得到32位或64位结果，我们可以使用<code>MOVZ</code>对其进行传输。</p>
<p>**注意：**这里无符号数和补码的条件码组合不同，所以需要使用不同的<code>SET</code>指令，所以可以通过<code>SET</code>指令来判断所操作的数是无符号的还是补码的。</p>
<p>所以常见的<strong>使用顺序</strong>为：</p>
<ol>
<li>使用<code>CMP</code>进行比较或<code>TEST</code>进行测试，来设置条件码。</li>
<li>根据条件码组合或者<code>SET</code>将结果保存在单字节寄存器中。</li>
<li>使用<code>movbl</code>将结果保存在32位寄存器中，并且会自动设置高4字节为0。</li>
</ol>
<h4 id="3-5-2-Conditional-branches">3.5.2 Conditional branches</h4>
<p>跳转指令根据跳转条件主要分为两种</p>
<ul>
<li>无条件跳转</li>
<li>条件跳转：和条件码有关</li>
</ul>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203211633965.png" alt="image-20220203211633965"></p>
<p>根据跳转目标的方式分成</p>
<ul>
<li>直接跳转：用标号</li>
<li>间接跳转：用寄存器或者内存，需要加个<code>*</code>，比如<code>jmp *%rax</code>就是跳转到寄存器<code>%rax</code>中保存的地址；<code>jmp *(%rax)</code>就是跳转到内存地址<code>(%rax)</code>中保存的地址。</li>
</ul>
<blockquote>
<p>条件跳转只能是直接跳转。</p>
</blockquote>
<p>对于直接跳转的跳转目标的编码，有<strong>两种编码方式：</strong></p>
<ul>
<li>**PC相对的（PC-relative）：**跳转目标地址减去跳转指令下一条指令的地址的差。编码长度可以为1、2或4字节。</li>
<li>**绝对地址：**用4字节直接给定目标地址。</li>
</ul>
<h5 id="conditional-jump">conditional jump</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">  proc1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  proc2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="conditional-move">conditional move</h5>
<p>条件控制可能很低效。</p>
<p>现代处理器运用<strong>流水线</strong>，在处理<strong>条件冒险</strong>的时候采用<strong>分支预测</strong>，当用条件控制的话，存在预测错误导致的性能下滑。（运用了一些流水线的专有名词，详细可看p146）</p>
<blockquote>
<p>分支预测处罚计算：预测错误概率为p，预测正确时代码执行时间为TOK，而预测错误的处罚为TMP。则执行代码的平均时间为TAVG§=(13-p)TOK+p(TOK+TMP)=TOK+pTMP，所以TMP=(TAVG§-TOK)/p。</p>
</blockquote>
<p>而用<strong>条件传送</strong>来实现条件分支，不会先判断跳转，而是先将两个分支的结果进行计算，将结果分别保存在两个寄存器中，然后再通过**条件传送指令<code>CMOV</code>**将正确结果传送到输出的寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">absdiff:</span><br><span class="line">  movq %rsi, %rax</span><br><span class="line">  subq %rdi, %rax  //y-x</span><br><span class="line">  movq %rdi, %rdx</span><br><span class="line">  subq %rsi, %rdx  //x-y</span><br><span class="line">  cmpq %rsi, %rdi</span><br><span class="line">  cmovge %rdx, %rax</span><br><span class="line">  ret </span><br></pre></td></tr></table></figure>
<p>这里会直接将两个分支的计算结果<code>x-y</code>和<code>y-x</code>分别保存在寄存器<code>%rdx</code>和<code>%rax</code>中，然后最后通过<code>cmovge</code>判断如果<code>x&gt;y</code>就将<code>x-y</code>的结果保存在<code>%rax</code>。</p>
<p>x86-64上提供了一些<strong>条件传送指令<code>CMOV</code></strong>，只有在满足条件时，才会将源数据传送到目的中，如下图所示，其中源值可以从寄存器也可以从内存地址获取，而目的只能是寄存器。并且这里<strong>不支持单字节</strong>。</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203214911679.png" alt="image-20220203214911679"></p>
<p>条件传送有局限性：</p>
<ol>
<li>
<p>某个分支可能会报错。比如对于指针<code>xp</code>，有个条件分支为<code>xp? *xp:0</code>，如果使用条件传送来实现，就会先运行<code>*xp</code>，如果该指针不存在，就会报错。</p>
</li>
<li>
<p>分支需要大量计算</p>
</li>
<li>
<p>分支会改变其他的值</p>
</li>
</ol>
<blockquote>
<p>只有当两个执行语句很简单时，才会使用条件传送来实现条件分支。而且当两个语句很简单时，gcc会自动优化选择条件传送。</p>
</blockquote>
<h4 id="3-5-3-Loops">3.5.3 Loops</h4>
<h5 id="do-while">do-while</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    body-<span class="function">statement</span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(test-expr)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一次不测试</p>
</blockquote>
<p>汇编一个jmp就可以搞定</p>
<h5 id="while">while</h5>
<p>while有两种实现</p>
<p>对于以下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fact_while</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    result *= n;</span><br><span class="line">    n = n<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Jump-to-middle">Jump-to-middle</h6>
<p>类似于do-while的汇编代码，只是需要在开始就跳转到后面的判断语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fact_while:</span><br><span class="line">  movl $1, %eax</span><br><span class="line">  jmp .JUDGE</span><br><span class="line">.L1:</span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq $1, %rdi</span><br><span class="line">.JUDGE:</span><br><span class="line">  cmpq $1, %rdi</span><br><span class="line">  jg .L1</span><br><span class="line">  rep; ret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一开始就有一个无条件跳转指令。</p>
</blockquote>
<h6 id="guarded-do">guarded-do</h6>
<p>当使用<strong>较高</strong>优化等级时，比如<code>-O1</code>时，GCC会使用这种策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fact_while:</span><br><span class="line">  cmpq $1, %rdi</span><br><span class="line">  jle .L1</span><br><span class="line">  movl $1, %eax</span><br><span class="line">.L2:</span><br><span class="line">  imulq %rdi, %rax</span><br><span class="line">  subq $1, %rdi</span><br><span class="line">  cmpq $1, %rdi</span><br><span class="line">  jne .L2</span><br><span class="line">  rep; ret</span><br><span class="line">.L1:</span><br><span class="line">  movl $1, %eax</span><br><span class="line">  ret </span><br></pre></td></tr></table></figure>
<blockquote>
<p>相当于do-while的外面加一个判断</p>
</blockquote>
<p>这里是直接进行判断。这个之所以更加高效，是因为一开始进入循环时，通常不会不满足循环条件，即一开始不会跳转到后面，所以会直接顺序一直执行循环体。</p>
<h5 id="for">for</h5>
<p>for循环可以转换为while循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init-<span class="function">expr</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(test-expr)</span> </span>&#123;</span><br><span class="line">    body-statement;</span><br><span class="line">    update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据优化等级，GCC会为其产生的代码是while循环的两种方法之一。</p>
<h4 id="3-5-4-Switch-Statements">3.5.4 Switch Statements</h4>
<p><code>switch</code>语句可以根据一个整数索引数值进行多重分支。通常使用<strong>跳转表（Jump Table）<strong>数据结构使得实现更加高效，它是一个数组，每个元素是对应的代码块起始地址，根据整数索引得到对应的代码地址后，就可以直接跳转到对应的代码块。相比很长的<code>if-else</code>语句的</strong>优势在于</strong>：执行<code>switch</code>语句的时间与分支数目无关。比如有很长的分支语句，如果用<code>if-else</code>实现，则可能需要经过若干个<code>if-else</code>才能跳转到目的代码块，而使用<code>switch</code>能根据跳转表直接获得代码块地址。</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203223013944.png" alt="image-20220203223013944"></p>
<p>如下代码：</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203223308458.png" alt="image-20220203223308458"></p>
<p>里面有一个跳转表数组<code>jt</code>，GCC提供了一个新的运算<code>&amp;&amp;</code>，能够创建一个指向代码位置的指针。首先在第9行中，计算输入值<code>x</code>和<code>switch</code>的最小值的差，并将其保存到无符号数中。然后将其作为跳转表的索引，直接在第16行中跳转到索引的代码位置。</p>
<blockquote>
<p>这里使用无符号数的原因在于，即使你输入比<code>switch</code>中最小值还小的值，则相减会得到负数，由于无符号数会将负数溢出到很大的正数，所以还是会跳转到<code>default</code>。所以汇编代码会使用<code>ja</code>对其使用无符号数的判断，判断是小于0还是大于最大值。</p>
</blockquote>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203223634800.png" alt="image-20220203223634800"></p>
<blockquote>
<p>通过第2行可以知道<code>switch</code>的最小值，第3行可以知道<code>switch</code>的最大值，第4行可以知道<code>default</code>的标号。</p>
<p>用ja而不是jg就是使用无符号数</p>
</blockquote>
<p>这里首先将计算结果保存在<code>%rsi</code>中，然后在第4行中<code>jmp *.L4(, %rsi, 8)</code>利用了跳转表，跳转表的内容由编译器自动生成填写，其声明如下所示</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203224113494.png" alt="image-20220203224113494"></p>
<p><code>.rodata</code>表示这是只读数据（Read-Only Data），<code>.align 8</code>表示将元素地址与8对齐，<code>.L4</code>就定义了一个跳转表，其枚举了从最小值到最大值的跳转目标。对于<code>*.L4(, %rsi, 8)</code>，首先根据<code>.L4</code>可以获得该跳转表的初始位置，然后因为该跳转表每个元素占8个字节，所以计算<code>(, %rsi, 8)</code>，即<code>8*%rsi</code>，就能得到对应的跳转目标。</p>
<p>ps：可以着重看一下老师讲case 2,3，处理fall through case</p>
<blockquote>
<p>如果有负值情况，会做偏置处理，让第一个为0</p>
<p>如果只有两个值，中间是空的，很稀疏，会选择优化成if-else，而不是跳转表</p>
<p>switch的时间复杂度是O(1)</p>
</blockquote>
<blockquote>
<p>你理解了条件，就理解了程序在干什么</p>
</blockquote>
<p><strong>小点：</strong></p>
<ul>
<li>大多数情况下，机器对有符号数和无符号数都使用一样的指令，因为大多数算数运算对无符号数和补码都是相同的位级行为。但是在右移、除法和乘法指令以及条件码组合中，需要区分无符号数和补码。</li>
<li>保存在64位寄存器中的数据类型，除了<code>long</code>和<code>unsigned long</code>以外，还可以是指针（对于64位操作系统而言）。</li>
<li>条件跳转只能是直接跳转。</li>
<li>当<code>switch</code>的分支跨度很大，并且很稀疏时，会保存很大的跳转表，可能影响性能，编译器可能会将其构建成树的结构。此时建议使用<code>if-else</code>语句。</li>
</ul>
<h3 id="3-6-Procedures">3.6 Procedures</h3>
<blockquote>
<p>ABI:Appliction binary interface</p>
<p>机器程序级别的接口</p>
<p>%rax：返回值</p>
<p>%rdi，%rsi，%rdx，%rcx，%r8，%r9是传参的</p>
<p>%r10，%r11是caller-saved temporaries</p>
<p>%rbx，%r12，%r13，%r14是callee-saved，要保存</p>
<p>%rbp是callee-saved，是frame pointer</p>
<p>%rsp是callee-saved</p>
</blockquote>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220204155259884.png" alt="image-20220204155259884"></p>
<p>过程是软件中一种重要的抽象，提供一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。</p>
<p>要提供对函数的机器级支持，必须处理许多不同的属性。我们假设函数P调用函数Q，Q执行后返回P。这个过程包括以下一个或多个机制：</p>
<ul>
<li>传递控制：在进入函数Q的时候，程序计数器要设置为Q的代码的起始位置。从函数Q返回时，要把程序计数器设置为P中调用Q后面那条指令的地址，即从P中的断点处继续执行。</li>
<li>传递数据：函数P必须能够向函数Q传递一个或多个参数，而函数Q必须能够向函数P返回一个值。</li>
<li>分配和释放内存：开始时，函数Q可能需要为局部变量分配空间，而在返回前，又要释放这些存储空间。</li>
</ul>
<h4 id="3-6-1-Stack-Structure">3.6.1 Stack Structure</h4>
<p>栈的特性符合过程调用和返回这整个想法的实质。</p>
<p>%rsp指向栈顶，每当分配额外空间，递减栈指针。上面是高地址，栈往下长。</p>
<ul>
<li>push</li>
<li>pop</li>
</ul>
<blockquote>
<p>详见3.3.3</p>
</blockquote>
<p><strong>栈帧：<strong>当函数需要的存储空间超出寄存器能够存放的大小，或者调用别的函数需要保存额外数据时，就会在栈上分配一个空间，这个空间称为函数的</strong>栈帧（Stack Frame）</strong>。相对的，当某个函数的所有局部变量都能保存在寄存器中，并且不会调用任何的函数时，就无需开辟该函数的栈帧了。当给一个函数创建栈帧时，编译器会给函数分配<strong>所需</strong>的<strong>定长</strong>的栈帧，在函数开始时就分配好后就不会改变了，所以栈顶指针<code>%rsp</code>就知道当函数返回时，需要释放多少空间。而有些函数需要变长的栈帧，这部分内容可参考书3.10.5</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220203232254404.png" alt="image-20220203232254404"></p>
<blockquote>
<p>因为未返回的函数都会在内存中保存自己的栈帧，而栈的空间是有限的，所以当调用过多时，会造成栈的溢出。</p>
</blockquote>
<blockquote>
<p>FP：Frame Pointer</p>
<p>帧的位置由一个或两个指针指示，%rbp和%rsp</p>
</blockquote>
<ul>
<li>
<p><strong>当函数P调用函数Q运行时：</strong></p>
</li>
<li>
<ul>
<li>由于x86-64只提供6个寄存器来传递函数输入值，所以当函数P传递给函数Q的参数多于6个时，需要函数P在自己的<strong>栈帧</strong>中存储好这些输入参数。</li>
<li>会先将返回地址压入栈中，表明当函数Q返回时，要从函数P中的哪个位置继续执行，这个作为P的栈帧的一部分。</li>
</ul>
</li>
<li>
<p>**函数Q运行时：**函数Q会扩展当前栈的边界，分配函数Q的栈帧所需的空间，可以用来保存寄存器的值、分配局部变量空间，为函数Q调用其他函数设置参数。</p>
</li>
<li>
<p>**函数Q返回时：**释放分配给函数Q的栈帧，并且让程序计数器调用返回地址，继续从函数P的断点处继续执行。</p>
</li>
</ul>
<h4 id="3-6-2-栈帧的组成部分">3.6.2 栈帧的组成部分</h4>
<h5 id="saved-register">saved register</h5>
<p>寄存器是所有函数共享的资源，当函数P调用Q时，如果函数Q改变了函数P保存在寄存器的值，则当函数Q返回时，函数P就无法完全从断点继续执行，因为寄存器中的值已经被函数Q改变了。（Q在运行的时候P不在运行）</p>
<p>我们对除了栈指针<code>%rsp</code>外的所有寄存器分成两类（按责任分，保存寄存器的责任在x那，就是x-saved）：</p>
<ul>
<li>callee saved：<code>%rbx</code>、<code>%rbp</code>和<code>%r12</code>~<code>%r15</code>。这部分寄存是由被调用者，即Q保存的。如果Q改变了这部分寄存器的值，就需要将其保存在Q自己栈帧中的**“被保存的寄存器”**中。当Q返回时，再将这部分寄存器的值根据内存复原。所以函数P可以假设“被调用者保存寄存器”的值是始终不变的。
<ul>
<li>被调用者在用之前保存</li>
<li>回到caller的时候复原寄存器的值</li>
<li>callee函数需要caller保存callee寄存器</li>
</ul>
</li>
<li>caller saved：除了上面的寄存器外，都属于被调用者保存寄存器。 任何函数都能修改这些寄存器的值，并且不会保存在“被保存的寄存器”中，所以P要自己将这部分寄存的内容保存起来。所以函数P可以假设“调用者保存寄存器”的值是变化的，需要自己保存，可以用这部分寄存器保存临时值。
<ul>
<li>调用者在调用之前保存</li>
</ul>
</li>
</ul>
<blockquote>
<p>当函数P调用函数Q时，“被调用者保存寄存器”就会保存在函数Q的栈帧中，所以当函数Q返回时，这部分寄存器会被重置为函数P使用时的状态。而<strong>其他寄存器的值是需要函数P自己保存的，所以函数P需要自己开辟局部变量区域来保存其他寄存器的值</strong>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//1.函数一进来，就需要通过push指令将自己要使用的“被调用者保存寄存器”保存在自己的栈帧中</span><br><span class="line">//比如使用了%rbx和%rbp</span><br><span class="line">  pushq %rbx    //保存%rbx到栈帧中</span><br><span class="line">  pushq %rbp    //保存%rbp到栈帧中</span><br><span class="line">... //可以使用“被调用者保存寄存器”来保存值</span><br><span class="line">//2.当“被调用者保存寄存器”不够保存当前函数的值时，需要开辟局部变量空间保存其他值</span><br><span class="line">//比如保存8字节值</span><br><span class="line">  subq $8, %rsp //将栈指针下移8个字节</span><br><span class="line">  movq %rdi, (%rsp)  //将需要保存的值保存到栈上</span><br><span class="line">//3.调用别的函数</span><br><span class="line">  call func //调用函数func，则“被调用者保存寄存器”会保存在函数func的栈帧中</span><br><span class="line">... //可以继续使用“被调用者保存寄存器”，因为函数func返回时会重置这些寄存器到原始值</span><br><span class="line">//4.释放局部变量空间</span><br><span class="line">  addq $8, %rsp</span><br><span class="line">//5.重置“被调用者保存寄存器”的值，注意顺序要相反</span><br><span class="line">  popq %rbp</span><br><span class="line">  popq %rbx</span><br></pre></td></tr></table></figure>
<ol>
<li>将要使用的“callee saved register”<code>push</code>到栈中。（存储调用当前函数的函数的值）</li>
<li>将除了“callee saved register”的其他寄存器保存在空闲的“callee saved register”中，如果保存不下，就将其保存在内存的“局部变量”区域</li>
<li>调用其他函数</li>
<li>释放 “局部变量”区域</li>
<li>将“被调用者保存寄存器”的值通过<code>pop</code>从栈中恢复。注意：顺序要和<code>push</code>时相反</li>
</ol>
<blockquote>
<p>如果“被调用者保存寄存器”还没有使用完毕时，可以在调用别的函数之前将其他寄存器的值保存到“被调用者保存寄存器”中。</p>
</blockquote>
<h5 id="Local-Variable-局部变量">Local Variable 局部变量</h5>
<p>当函数需要保存的数据不多时，就会将数据保存在“被调用者保存寄存器”中。但是以下情况必须<strong>保存在内存中</strong>，该部分称为该函数的<strong>局部变量：</strong></p>
<ul>
<li>“被调用者保存寄存器”不足以保存所有的本地数据</li>
<li>当一个局部变量使用取地址符&amp;时，指的是返回该变量在内存中的地址，就必须将其保存在内存中</li>
<li>当局部变量是数组或结构时</li>
</ul>
<p>总结为以下几步：</p>
<ol>
<li>申请局部空间，通过对栈顶指针<code>%rsp</code>减掉一个值</li>
<li>根据数据大小，通过<code>%rsp</code>索引将数据保存在内存空间中</li>
<li>根据传入参数顺序，将其保存到内存和寄存器中。**注意：**参数大小要为8字节的倍数。</li>
<li>释放局部空间，通过对栈顶指针<code>%rsp</code> 加上<code>1.</code>中的值</li>
</ol>
<h5 id="参数构造区">参数构造区</h5>
<p>函数P必须能够向函数Q传递一个或多个参数，而函数Q必须能够向函数P返回一个值。</p>
<p>在函数间传递数据，主要<strong>通过寄存器</strong>进行，x86-64提供了6个用于传递<strong>参数</strong>的寄存器，根据参数的顺序，需要放入特定的寄存器中。x86-64将寄存器<code>%rax</code>作为函数<strong>返回值</strong>的寄存器。</p>
<blockquote>
<p>这些寄存器只能用来保存整数或指针类型。</p>
<p>为什么现在优先使用寄存器传参？因为寄存器更快</p>
</blockquote>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220204140327244.png" alt="image-20220204140327244"></p>
<p>如果某个函数要传递超过6个参数的话，就需要将第7个到第n个参数保存在<strong>栈</strong>中，然后通过<strong>栈顶指针<code>%rsp</code><strong>进行索引其中第7个参数在栈顶位置。所有数据大小都向8字节的倍数对齐。这部分区域称为</strong>参数构造区</strong>。</p>
<blockquote>
<p>由于栈顶还要保存一个8字节的返回地址，所以第7个参数的地址为<code>8(%rsp)</code>，如果第7个元素大小不超过8字节，则第8个元素的地址为<code>16(%rsp)</code>，以此类推。</p>
</blockquote>
<h5 id="返回地址">返回地址</h5>
<ul>
<li>
<p><code>call</code>：可以直接将函数名作为跳转目标，其编码的计算方式和<code>jmp</code>相同。相当于<code>push</code>和设置<code>%rip</code>的组合。</p>
</li>
<li>
<ul>
<li>将栈指针减8，留出保存返回地址的空间</li>
<li>将紧跟<code>call</code>指令后面那条指令的地址作为返回地址，保存到栈中。</li>
<li>将程序计数器设置为调用函数的地址。</li>
</ul>
</li>
<li>
<p><code>ret</code>：从当前函数返回，不需要操作数。相当于设置<code>%rip</code>和<code>pop</code>的组合。</p>
</li>
<li>
<ul>
<li>将程序计数器设置为栈顶元素。</li>
<li>将栈指针加8。</li>
</ul>
</li>
</ul>
<h5 id="综上所述：">综上所述：</h5>
<ol>
<li>（被保存的寄存器）函数P将要使用的“被调用者保存寄存器”通过<code>push</code>保存在函数的栈帧中。</li>
<li>（局部变量）如果函数P使用了“调用者保存寄存器”，就需要将其保存在栈中，才能调用函数Q。并且函数P根据需要申请空间来保存其他局部变量。</li>
<li>（参数构造区）函数P将参数保存在寄存器中，如果超过6个参数，就申请空间保存到内存中。</li>
<li>（返回地址）函数P使用<code>call</code>指令调用函数Q，会将<code>call</code>的下一行指令的地址压入栈中，并将程序计数器指向函数Q的第一条指令的地址。</li>
<li>当函数Q运行时会随着使用动态申请和释放局部变量，当函数Q运行完时，首先使用栈“被调用者保存寄存器”的值，然后使用<code>ret</code>指令返回将程序计数器设置为栈顶的返回地址，最后将栈顶的返回地址弹出。</li>
</ol>
<p>无论是“被保存的寄存器”还是“局部变量”以及“参数构造区”，一开始如何申请这些区域，后面使用完后还会逆向地通过<code>%rsp</code>将这些区域释放掉，这是动态的过程，使得一个函数运行完时，<code>%rsp</code>指向的就是返回地址，就能直接通过<code>ret</code>返回到调用者的断点处。</p>
<h4 id="3-6-3-Calling-Conventions">3.6.3 Calling Conventions</h4>
<h5 id="Passing-control">Passing control</h5>
<blockquote>
<p>也是压栈的机制</p>
</blockquote>
<ul>
<li>call</li>
<li>ret</li>
</ul>
<h5 id="Passing-data">Passing data</h5>
<p>见3.6.2的参数构造区</p>
<h5 id="Managing-local-data">Managing local data</h5>
<p>见3.6.2</p>
<h4 id="3-6-4-Illustration-of-Recursion">3.6.4 Illustration of Recursion</h4>
<ul>
<li>每个过程调用在栈中有自己的私有空间</li>
<li>多个未完成调用的局部空间不会相互影响</li>
<li>有时候存在相互调用，同理</li>
</ul>
<p><strong>小点：</strong></p>
<ul>
<li>不会显示地操作程序计数器寄存器<code>%rip</code>，没有指令可以对其操作，只能通过类似<code>call</code>或<code>ret</code>间接对其操作。</li>
<li>栈顶指针<code>%rsp</code>是随着函数运行不断变化的。</li>
<li>某个函数要永久使用的值，要么保存在“被调用者保存寄存器”中，要么保存在内存中。</li>
<li>当函数需要使用“被调用者保存寄存器”时，就直接将其<code>push</code>到栈中，使用过后再<code>pop</code>重置。</li>
</ul>
<h3 id="3-7-Array">3.7 Array</h3>
<blockquote>
<p>数组和结构是聚合数据的两种形式，但是汇编不会直接提供这样的数据结构</p>
</blockquote>
<h4 id="One-dimensional">One-dimensional</h4>
<p>对于数据类型<code>T</code>和整形常量<code>N</code>，声明一个数组变量<code>A</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T A[N];</span><br></pre></td></tr></table></figure>
<p>主要经历<strong>两个步骤：</strong></p>
<ol>
<li>根据数据类型<code>T</code>的大小<code>L</code>字节，先在内存空间中分配一个大小为<code>L*N</code>的连续空间；</li>
<li>将<code>A</code>作为这个连续内存空间的起始指针，即A的值<code>xA</code>就是该内存空间的起始地址。</li>
</ol>
<blockquote>
<p>当你声明了一个数组，你既为它分配了空间，并且创建了一个允许进行指针运算的数组名称。而当你声明一个指针时，你所分配的只有指针本身的空间，所以如果没有初始化指针，直接对其进行解引用可能会出现错误。</p>
</blockquote>
<p>如果是int的话，当数组作为指针加1时，地址加了sizeof(int)，所以当数组内为负数或者很大超过上界的数其实也是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">4</span>]    <span class="number">3</span></span><br><span class="line">A       x</span><br><span class="line">A + <span class="number">1</span>   x + <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针只能相减，不能相加</p>
</blockquote>
<p><strong>数组和指针的区别：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int A1[3];</span><br><span class="line">int *A2;</span><br><span class="line">int *A3[3];</span><br><span class="line">int (*A4)[3];</span><br><span class="line">int (*A5[3]);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sizeof(A1)</code>为12，返回的是数组内保存的全部元素大小； <code>sizeof(*A1)</code>为4，返回的是第一个元素的大小，即<code>int</code>的大小。而<code>sizeof(A2)</code>为8，返回的只是指针的大小；<code>sizeof(*A2)</code>为4，返回的也是<code>int</code>的大小。</li>
<li>如果没有对<code>A2</code>进行初始化，直接调用<code>*A2</code>可能会报错，因为它没有指向合理的对象。而<code>*A1</code>不可能出错，因为创建数组时，已经为他分配好了空间。</li>
<li><code>A3</code>声明了大小为3的数组，每个元素的类型为<code>int *</code>，所以<code>sizeof(A3)</code>为24，因为数组内有3个元素，每个元素都是指针，大小为8。而<code>sizeof(*A3)</code>为8，因为<code>A3</code>的第一个元素是一个指针，大小就为8。而<code>sizeof(**A3)</code>为4，它表示的是数组中第一个指针指向的<code>int</code>，所以是4。因为<code>A3</code>首先声明的是一个数组，所以它会自动分配好数组的空间，所以<code>*A3</code>不会是空指针，但是它里面保存的是指针，所以<code>**A3</code>可能会是空指针。</li>
<li><code>A4</code>定义了一个指向大小为3的<code>int</code>数组的指针。所以<code>sizeof(A4)</code>为8，只是一个单纯的指针的大小；<code>sizeof(*A4)</code>为12，它表示<code>A4</code>指向的数组的大小。而<code>sizeof(**A4)</code>为4，它表示<code>A4</code>指向的数组的第一个元素。 因为这里只是单纯声明了一个指针，所以<code>*A4</code>和<code>**A4</code>都可能是空指针。</li>
<li>A5和A3一样</li>
</ul>
<blockquote>
<p>当使用空括号声明的时候就像指针，当给出了数字，就真的分配了内存</p>
</blockquote>
<h4 id="Multi-dimensional（nested）">Multi-dimensional（nested）</h4>
<p>在内存中，这种二维数组是按照“行优先”的形式保存在内存中的</p>
<p><code>D[i][j]</code>的地址为<code>x+L(Ci+j)</code></p>
<p>e.g.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZLEN 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zip_dig[ZLEN];</span><br><span class="line">zip_dig pgh[PCOUNT] = </span><br><span class="line">  &#123;&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span> &#125;,</span><br><span class="line">   &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span> &#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>获得某个索引的值的C代码为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pgh_digit</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> dig)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pgh[index][dig];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># index in %rdi, dig in %rsi</span><br><span class="line">get_pgh_digit:</span><br><span class="line">  leaq (%rdi, %rdi, 4), %rax    #5*index，每个都有五个</span><br><span class="line">  addl %rax, %rsi               #5*index+dig</span><br><span class="line">  movl pgh(,%rsi, 4), %eax      #Mem[pgh+20*index+4*digit]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>如果是特殊的矩阵，数组保存了指向数组的指针，那需要引用内存两次。尽管c代码是一样的，但是底层的引用逻辑不一样</p>
<p>对应的汇编代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#index in %rdi, digit in %rsi</span><br><span class="line">get_univ_digit:</span><br><span class="line">  salq $3, %rsi  #8*index</span><br><span class="line">  movq univ(%rsi), %rax #获得指针</span><br><span class="line">  movl (%rax, %rsi, 4), %eax  #Mem[Mem[univ+8*index]+4*digit]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>这里有两次内存引用过程。</p>
<h4 id="Fixed-dimensions">Fixed dimensions</h4>
<p>当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过<code>#define</code>声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。当优化等级设置为<code>-O1</code>时，GCC会采用很多聪明的优化，避免了索引<code>A[i][j]</code>要计算乘法<code>A+L(Ci+j)</code>的巨大损耗。</p>
<h4 id="Variable-dimensions">Variable dimensions</h4>
<p>过去C要求数组的大小要在编译时就确定，才能生成对应的汇编代码。如果需要变长数组，就需要程序员自己对数组分配存储空间。ISO-C99允许数组的维度为表达式，在数组被分配时才计算出来，例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[exp1][exp2];</span><br></pre></td></tr></table></figure>
<p>只要求<code>exp1</code>和<code>exp2</code>定义在上面那个声明之前。</p>
<p>我们接下来对比下定长数组和变长数组在索引时汇编代码的区别</p>
<ul>
<li>定长数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fix_matrix[<span class="number">5</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fix_ele</span><span class="params">(fix_matrix A, <span class="keyword">long</span> i, <span class="keyword">long</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fix_ele:</span><br><span class="line">  leaq (%rsi, %rsi, 2), %rax    #compute 3i</span><br><span class="line">  leaq (%rdi, %rax, 4), %rax    #compute A+12i</span><br><span class="line">  movl (%rax, %rdx, 4), %eax    #read fomr M[A+12i+4j]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<ul>
<li>变长数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">var_ele</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> A[n][n], <span class="keyword">long</span> i, <span class="keyword">long</span> j)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var_ele:</span><br><span class="line">  imulq %rdx, %rdi             #compute ni</span><br><span class="line">  leaq  (%rsi, %rdi, 4), %rax  #compute A+4ni</span><br><span class="line">  movl  (%rax, %rcx, 4), %eax  #read from M[A+4ni+4j]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>看汇编代码可以发现以下区别：</p>
<ul>
<li>增加了参数n，使得寄存器的使用改变了，</li>
<li>用了乘法指令来计算<code>ni</code>，而不是用<code>leaq</code>来计算<code>3i</code>，乘法会导致无法避免的性能损失</li>
</ul>
<p>使用优化，GCC能够识别出步长，然后生成的代码会避免直接乘法，从而可以提高性能。</p>
<h3 id="3-8-Structures">3.8 Structures</h3>
<h4 id="Allocation-Access">Allocation/Access</h4>
<p>C语言中，可以用<code>struct</code>声明创建一个<strong>数据类型</strong>，具有以下特点：</p>
<ul>
<li>定义：可以将不同类型的对象聚合到一个对象中，并使用名字来引用结构中的各个组成部分。</li>
<li>存储：结构的所有组成部分都存放在内存中一段<strong>连续的</strong>区域内，指向结构的<strong>指针</strong>是结构第一字节的地址。</li>
<li>获得元素：编译器会维护关于每个结构类型的信息，了解每个字段的偏移量，由此作为内存引用指令的唯一，来对结构元素进行引用。</li>
</ul>
<h4 id="Alignment">Alignment</h4>
<p>数据对齐，提高效率。在x86-64上，即使数据不对齐，也不会影响任何功能，但是有些机器如果访问未对其的数据，可能会造成内存错误。（硬件问题）</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212173034219.png" alt="image-20220212173034219"></p>
<p><strong>对齐原则</strong>是任何K字节的基本对象的地址必须是K的倍数</p>
<p>为此，在<code>struct</code>中两个连续的对象，编译器可能中间会插入间隙，来满足各自对内存地址的要求。并且还有<strong>两个额外的要求：</strong></p>
<ul>
<li>要求结构的初始地址一定是结构体中最大对象大小的倍数，使得偏移量加上初始地址才是真的满足倍数关系的。</li>
<li>在结构体末尾填充，使其是结构体中<strong>最大对象</strong>大小的倍数，使得结构数组中下一个元素的地址也是成倍数关系的。</li>
</ul>
<blockquote>
<p>Tip：平时我们写结构的时候，最好按照从大到小的形式进行声明，可以减少填充的字节数目，节省该结构的空间大小</p>
</blockquote>
<h3 id="3-9-Union">3.9 Union</h3>
<p>C语言中，可以用<code>union</code>声明创建一个<strong>数据类型</strong>，具有以下特点：</p>
<ul>
<li>定义：允许以多种类型来引用一个对象。</li>
<li>存储：保存在<strong>公共的</strong>一块内存中，通过不同对象的类型来赋予这块内存不同的含义。内存大小为最大字段的大小。</li>
<li>语法和结构一样</li>
</ul>
<p>主要具有以下应用情况：</p>
<ul>
<li>如果我们事先知道两个不同字段是互斥的，就能将其定义在一个union中，就能节省内存空间。
<ul>
<li>比如二叉树</li>
</ul>
</li>
<li>访问相同位模式下不同数据类型的值。-</li>
</ul>
<p>比如我们对一个<code>double</code>类型的对象<code>d</code>使用强制类型转换到<code>long</code>，则除了0的情况，他们的位模式会发生很大变化。如果我们想要保持位模式不变，则可以使用union</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">double2long</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">  &#125; temp;</span><br><span class="line">  temp.d = d;</span><br><span class="line">  <span class="keyword">return</span> temp.l;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>此时返回的就能保持位模式不发生变化了，因为是直接调用相同的内存空间。</p>
<p><strong><code>struct</code>和<code>union</code>的区别：</strong><code>struct</code>为每个对象分配了单独的内存空间，而<code>union</code>分配了共用的内存空间。</p>
<p>**什么时候用<code>union</code>什么时候用<code>struct</code>：**当你要信息同时存在时，就需要分配到不同的内存中，就要用<code>struct</code>，否则用<code>union</code>。</p>
<p><strong>计算struct和union嵌套的数据类型的内存分布：</strong></p>
<ul>
<li>如果是包裹在struct内的，就按顺序按照对象大小依次排列下来</li>
<li>如果是包裹在union内的，就看最大的对象大小，直接分配一块内存就行</li>
</ul>
<h3 id="3-10-Floating-Point-跳过也可">3.10 Floating Point(跳过也可)</h3>
<h4 id="历史">历史</h4>
<p>在很久之前，8086处理器上有一块8087芯片，能够提供实现完整IEEE浮点数所需的所有硬件，事实上，它是与IEEE浮点标准本身共同开发的，但是它的编程模型非常难用。</p>
<p>SIMD——&gt;SSE——&gt;AVX</p>
<p>SSE和AVX都提供了支持SIMD的指令集，使得可以在物理层面上实现同时对多个整型和浮点数进行并行运算，SSE有独立的16个128位XMM寄存器，AVX进一步扩展得到16个256位YMM寄存器，每个XMM寄存器都是对应的YMM寄存器的低128位。</p>
<h4 id="浮点代码">浮点代码</h4>
<p>处理器的浮点体系结构包含多个方面，会影响对浮点数据操作的程序如何映射到机器上，包括：</p>
<ul>
<li>如何存储和访问浮点数值</li>
<li>对浮点数据操作的指令</li>
<li>向函数传递浮点数参数和从函数返回浮点数结果的规则</li>
<li>函数调用过程中保存寄存器的规则</li>
</ul>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212191044922.png" alt="image-20220212191044922"></p>
<p>浮点数只有caller-saved</p>
<h5 id="浮点传送">浮点传送</h5>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212191920932.png" alt="image-20220212191920932"></p>
<p>其中，引用内存的都是标量指令，而在两个XMM寄存器之间传送数据的是SIMD指令。其中<code>a</code>表示aligned，当读写内存时，要求满足16字节对齐（因为XMM是16字节的），否则会报错，而这里直接在两个XMM寄存器之间传输，绝不会出现错误对齐的情况。 建议32位内存数据满足4字节对齐，64位数据满足8字节对齐。</p>
<p><strong>例子：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">float_mov</span><span class="params">(<span class="keyword">float</span> v1, <span class="keyword">float</span> *src, <span class="keyword">float</span> *dst)</span></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> v2 = *src;</span><br><span class="line">  *dst = v1;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#v1 in %xmm0, src in %rdi, dst in %rsi</span><br><span class="line">float_mov:</span><br><span class="line">  vmovaps %xmm1, %xmm1  #v2是返回值，要使用%xmm0，而当前v1占用了%xmm0，所以先挪一下</span><br><span class="line">  vmovss (%rdi), %xmm0</span><br><span class="line">  vmovss %xmm1, (%rsi)</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>
<p>**注意：**传入参数，如果是浮点数，就保存在XMM寄存器中，如果是指针或整型，就保存在常规寄存器中。而返回值也是如此。</p>
<h5 id="浮点转换操作">浮点转换操作</h5>
<h6 id="浮点数–-整型">浮点数–&gt;整型</h6>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192207796.png" alt="image-20220212192207796"></p>
<h6 id="整型–-浮点数">整型–&gt;浮点数</h6>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192231286.png" alt="image-20220212192231286"></p>
<p>在整型转换成浮点数时，提供了三操作数指令，这里通常可以忽略第二个操作数，因为它的值只会影响高位字节，通常使用目的寄存器。常见的使用方式为<code>vcvtsi2sdq %rax, %xmm1, %xmm1</code> 。</p>
<h6 id="浮点数相互转换">浮点数相互转换</h6>
<p>浮点数相互转换的命令比较特殊，不是提供单一指令进行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Conversion from single to double precision</span><br><span class="line">vunpcklps %xmm0, %xmm0, %xmm0  #replicate first vector element</span><br><span class="line">vcvtps2pd %xmm0, %xmm0         #convert two vector elements to double</span><br><span class="line"></span><br><span class="line"># Conversion from double to single precision</span><br><span class="line">vmovddup %xmm0, %xmm0     #replicate first vector element</span><br><span class="line">vcvtpd2psx %xmm0, %xmm0   #convert two vector elements to single</span><br></pre></td></tr></table></figure>
<h5 id="过程中的浮点代码">过程中的浮点代码</h5>
<ul>
<li>函数传入的浮点数，或者函数使用浮点数进行计算时，都需要使用上述寄存器。也可以使用栈来传递额外的浮点参数。</li>
<li>%xmm0既是函数第一个参数的寄存器，也是函数返回值的寄存器</li>
<li>所有寄存器都是“调用者保存寄存器”，所以函数要先将这些值保存在内存中，才去调用别的函数。</li>
</ul>
<blockquote>
<p>参数到寄存器的映射取决于参数的顺序和类型。如果是整型或指针，就使用通用寄存器，如果是浮点数，就使用XMM寄存器。</p>
</blockquote>
<h5 id="浮点运算操作">浮点运算操作</h5>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192452876.png" alt="image-20220212192452876"></p>
<p>每条指令可以有一个源操作数或两个源操作数，以及一个目的操作数。其中，第一个源操作数可以是XMM寄存器或内存位置，而第二个操作数和目的操作数只能是XMM寄存器。</p>
<blockquote>
<p>当计算中出现整型、float和double混合时，需要将整型和float都转换成double再计算。</p>
</blockquote>
<h5 id="定义和使用浮点常数">定义和使用浮点常数</h5>
<p>和整数运算操作不同，AVX浮点操作不能用立即数作为常数。编译器会为浮点常数分配和初始化存储空间，然后代码再从内存中读取这些值。比如以下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cel2fahr</span><span class="params">(<span class="keyword">double</span> temp)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.8</span>*temp+<span class="number">32.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>1.8</code>和<code>32.0</code>是浮点常数，编译器会将其保存在内存中，而不是作为立即数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.LC2:</span><br><span class="line">  .long 3435973837</span><br><span class="line">  .long 1073532108</span><br><span class="line">.LC3:</span><br><span class="line">  .long 0</span><br><span class="line">  .long 1077936128</span><br></pre></td></tr></table></figure>
<p>这里分别用标号<code>.LC2</code>和<code>.LC3</code>表示<code>1.8</code>和<code>3.6</code>。这里使用两个<code>.long</code>声明和十进制表示的值来表示一个<code>double</code>常量的。我们可以推算一下这个值：首先这里使用的是小端法，数值的最低有效位保存在了较小的地址中，所以<code>3435973837</code>表示低4字节的值，而<code>1073532108</code>表示高4字节的值。而表示为十进制时，我们可以直接将其转换成十六进制的值，就能获得正确排列的字节序列（因为小端法只是表示机器怎么存储数据的，而整数值是真实字节对应的数值）。 <code>3435973837</code>的十六进制数为<code>0xcccccccd</code>，<code> 1073532108</code>的十六进制数为<code>0x3ffccccc</code>，则按顺序排列就能得到浮点数的编码<code>0x3ffccccccccccccd</code>。我们知道<code>double</code>类型的第一位为符号位，然后接下来的11位为阶码位，最后的52位为尾数位。前3个十六进制数为<code>0x3ff</code>转化为二进制数为<code>001111111111</code>，则阶码为<code>01111111111</code>，对应的无符号数为1023，偏移量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>11</mn><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>1023</mn></mrow><annotation encoding="application/x-tex">2^{11-1}-1=1023</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">3</span></span></span></span> ，则 E = 0；而尾数部分的十六进制数为<code>0xccccccccccccd</code>，它表示的是二进制分数，则转化为十进制数为0.8，再加上1为1.8，所以最后的值为1.8。</p>
<p>则该段C代码对应的汇编代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cel2fahr:</span><br><span class="line">  vmulsd .LC2(%rip), %xmm0, %xmm0</span><br><span class="line">  vaddsd .LC3(%rip), %xmm0, %xmm0</span><br><span class="line">  ret </span><br></pre></td></tr></table></figure>
<h5 id="浮点代码中的位级操作">浮点代码中的位级操作</h5>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192831935.png" alt="image-20220212192831935"></p>
<h5 id="浮点比较操作">浮点比较操作</h5>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192849339.png" alt="image-20220212192849339"></p>
<p>其中第二个操作数必须在XMM寄存器中，第二个操作数可以在XMM寄存器，也可以在内存中。类似于CMP指令，会设置三个条件码：零标志为ZF、进位标志位CF和奇偶标志位PF。当进行浮点比较时，如果有任何一个是NaN，则会设置PF，并且比较失败。</p>
<p>条件码的设置条件如下，只要有任何一个操作数为NaN，就会出现无序的情况。</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220212192925385.png" alt="image-20220212192925385"></p>
<p>当出现无序的结果，可以使用指令<code>jp</code>（jump on parity）来进行跳转，而其他结果和无符号数的比较相同。</p>
<h3 id="3-11-Memory-Layout">3.11 Memory Layout</h3>
<p>真实物理内存通过操作系统将其映射<strong>虚拟内存</strong>，从程序员的角度，内存就被抽象为一个很大的字节数组，每个元素是一个字节。在86-64机器上，64位二进制数为该数组地址进行编码，意味着64位操作系统最大能容纳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 字节的内存大小，目前市面上该大小的内存还不是很普及。现在64位机器会限制只使用47位的地址，这也能支持 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>47</mn></msup></mrow><annotation encoding="application/x-tex">2^{47}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>字节，即128T的内存大小。只使用47位编码时，最小地址为<code>0x0</code>，而最大的地址为<code>0x00007FFFFFFFFFFF</code>。</p>
<p>虚拟内存存储数据也是分不同区域的，如下图所示（不是按比例绘制的），地址从下到上依次递增。</p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220214111257016.png" alt="image-20220214111257016"></p>
<ul>
<li><strong>Stack：<strong>在Linux中，将栈放置在整个地址空间的最顶部，用于函数调用，及</strong>局部变量</strong>的存储，这样随着函数的运行，栈顶就能向<strong>低地址</strong>不断扩展。常用系统中栈的大小是8MB，可通过命令<code>limit</code>查看，如果用栈指针访问超过8MB范围的地址，就会出现<strong>段错误（Segmentation Fault）</strong>。 相同程序的栈的分配是固定的。</li>
<li><strong>Shared Libraries：<strong>类似于<code>printf</code>和<code>malloc</code>的这类</strong>库函数</strong>平时是被存储在磁盘上的，当我们程序需要使用库函数时，就会在程序开始执行时，将它们加载到你的程序中，这称为<strong>动态加载（Dynamic Linking</strong>）。</li>
<li>**Heap：<strong>用来存放通过</strong><code>malloc</code>、<code>callc</code>或<code>new</code>**等申请的变量，这些变量在程序运行时会动态变化。当你不断通过<code>malloc</code>申请空间又没释放时，堆顶的指针就不会断向高地址增加，使得占用的内存不断变多。堆在分配时是具有随机性的。</li>
<li><strong>Data：<strong>该数据区用来存放程序开始时分配的数据，你声明的</strong>全局变量、静态变量或字符常量等</strong>都在这个数据段中。</li>
<li><strong>Text：<strong>根据可执行目标文件的内容进行初始化，是放置</strong>可执行程序</strong>的位置。放置函数。这部分区域是只读的。</li>
</ul>
<h3 id="3-12-理解指针">3.12 理解指针</h3>
<p>指针类型不是机器代码的一部分，而是C语言提供的关于内存地址的抽象，指针的值存储的是对象的地址，可以直接通过指针来间接对内存进行访问，避免程序员寻址错误。特殊的<code>NULL(0)</code>表示该指针不指向任何值。如果指针通过<code>&amp;</code>创建，表示取某个对象的地址，在机器代码中对应于<code>leaq</code>。如果指针通过<code>*</code>进行访问，表示访问该指针指向的对象的值，在机器代码中对应于内存引用。</p>
<p>我们同样可以声明<strong>函数指针</strong>，表示指向函数在机器代码中的第一条指令的内存地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T (*fp)(arg1T, arg2T,...);</span><br></pre></td></tr></table></figure>
<p>其中，<code>T</code>为函数的返回值类型，<code>arg1T</code>表示第一个参数的类型，以此类推。然后将函数名赋值给该函数指针，就能直接通过该函数指针调用函数了。</p>
<h3 id="3-13-Buffer-Overflow">3.13 Buffer Overflow</h3>
<p>数据栈中保存着函数的返回地址、“被调用者保存寄存器”以及局部变量等其他信息。C语言声明的数组也保存在<strong>栈</strong>的局部变量区，并且C语言不会对数组的引用进行任何<strong>边界检查</strong>，使得我们可以超出数组的边界对栈中的其他数据进行修改，比如对<strong>函数返回地址</strong>进行修改，此时程序就会出现很严重的问题，甚至有时候修改了地址，不会crash程序，错误的代码会一直运行下去，跳到不知名的地方。</p>
<p>这种破坏方法称为<strong>缓冲区溢出（Buffer Overflow）</strong>，通常在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。</p>
<p>库函数<code>gets</code>、<code>strcpy</code>、<code>strcat</code>、<code>sprintf</code>都是很危险的函数。他没有办法确地是否为保存整个字符串分配了足够的空间。</p>
<p>一个代码攻击方式，就是找到存储跳转地址的地方，把原本需要跳转的地址改成我注入攻击代码的地址，执行注入的代码。</p>
<p>Buffer overflows的历史</p>
<ul>
<li>莫里斯蠕虫</li>
<li>finger，远程联系，使用gets</li>
<li>IM War，即时通讯
<ul>
<li>利用自身bug来监测</li>
</ul>
</li>
</ul>
<p>蠕虫和病毒的区别</p>
<ul>
<li>蠕虫可以自己运行，并繁衍</li>
<li>病毒，不能自己存活，他攻击一个程序并且改变他</li>
</ul>
<h4 id="避免缓冲区攻击的手段">避免缓冲区攻击的手段</h4>
<ul>
<li>
<p>不使用具有缓冲溢出的函数，比如使用<code>fgets</code>代替<code>gets</code>，因为<code>fgets</code>有一个用来指定程序最多可以读取多少字节的参数， 如果输入的字节超过这个数字，就会对其进行截断。同样可以使用<code>strncpy</code>代替<code>strcpy</code>。要注意不要直接使用<code>scanf</code>的<code>%s</code>来读取字符串，要么使用<code>fgets</code>代替，要么使用<code>%ns</code>来指定最多可以输入多长的字符串。</p>
</li>
<li>
<p>地址空间布局随机化ASLR。为了在系统中插入攻击代码，攻击者不仅要插入攻击代码，还要插入指向这段攻击代码的指针，所以需要知道代码放置的位置。对此，可以使用<strong>地址空间布局随机化（Address-Space Layout Randomization，ASLR）<strong>技术，ASLR中有一种</strong>栈随机化</strong>技术，每次程序运行时，在栈中分配一段0~n字节的随机大小空间，就能使得栈的位置在程序每次运行时都有变化。每次运行程序时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据都会加载到内存的不同区域，使得代码位置不是很好获得。对应的破解方法是使用<strong>空操作雪橇（Nop Sled）</strong>，通过在攻击代码前插入一段很长的<code>nop</code>指令，当运行到<code>nop</code>指令时，就会“滑到”最终的攻击代码位置，通过枚举不同的起始地址，然后执行这段攻击代码，就能成功，只是效率可能会有点低。</p>
</li>
<li>
<p>限制可执行代码区域（标记法）。注入代码的形式，使得要执行的代码跑到了栈上去，但是可执行代码应该位于Text区域。在原始的x86上，每个内存区域都有一个标记位，来表示该区域属于哪种类型，包括：<strong>可写、可读</strong>（等价于可执行）。在过去的10年左右，首先是AMD，然后是Intel，添加了第三种标志：<strong>可执行</strong>。所以我们可以简单地标记栈是不可执行的，就能防止通过修改返回地址，返回到栈上执行注入代码。</p>
</li>
<li>
<p>Canary（金丝雀，哨兵）栈破坏检测</p>
<p>缓冲区溢出攻击通常在缓冲区溢出时发生，所以当我们能够检测到什么时候发生缓冲区溢出，就能终止该程序。</p>
<p>GCC首先会尝试确定一个函数是否容易受到栈溢出攻击，比如函数中有局部char类型缓冲区时，就会使用一种<strong>栈保护者（Stack Protector）机制</strong>，通过在该函数栈帧中的局部变量区与栈状态（返回地址和寄存器保存区）之间存入一个随机的<strong>金丝雀值（Canary）</strong>，然后在恢复寄存器状态和返回返回地址之前，会检测该值是否发生变化，如果发生变化，则程序异常终止。</p>
<p>**技巧：**将缓冲区放在靠近金丝雀值的位置，防止其他局部变量被修改。</p>
</li>
</ul>
<h4 id="ROP攻击">ROP攻击</h4>
<p>针对上述的3个系统提供的防御措施：栈随机化、限制可执行代码区域以及插入金丝雀值，我们可以使用新的攻击方法**ROP攻击（Return-Oriented Programming Attacks）**来破解前两种防御措施。</p>
<p>ROP的<strong>策略</strong>是：即使我们不知道栈的位置在哪，但我们知道代码存在哪里，因为栈随机化并没有修改全局变量和代码本身的位置，我们就可以使用现有的可执行代码片段来拼凑出我们想要的整体代码。</p>
<blockquote>
<p>该方法无法克服金丝雀值，即只能输入缓冲区限制的字节数目。</p>
</blockquote>
<p><strong>利用x86返回语句的特殊形式</strong></p>
<ul>
<li>在现有的代码中找到我们需要的所有字节片段，并且要求以<code>ret</code>结尾（后面会说为什么） 。比如</li>
</ul>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220214214742152.png" alt="image-20220214214742152"></p>
<p>通过这段代码我们就能得到<code>%rdi</code>和<code>%rdx</code>的值，这段代码的地址为<code>0x4004d4</code></p>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220214214816343.png" alt="image-20220214214816343"></p>
<p>通过这段代码，我们可以将<code>%rax</code>的值赋给<code>%rdi</code>，就能作为函数的参数。这段代码的地址为<code>0x400dc</code>。</p>
<p>我们可以通过类似上述的方法获得一系列我们需要的代码片段，来组成我们想要运行的最终程序。</p>
<ul>
<li>将上述获得的所有代码片段地址，依次输入到栈中</li>
</ul>
<p><img src="C:%5CUsers%5CFcr%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220214214946451.png" alt="image-20220214214946451"></p>
<ul>
<li>我们可以修改<code>%rbp</code>的值，使得释放栈帧时栈顶指针<code>%rsp</code>还是只想当前的栈顶，这样程序执行自己的ret指令就能开始攻击了。</li>
</ul>
<blockquote>
<p>利用ret的机制，不断获得下一个代码片段的地址，一次类推，最终完成所有攻击代码</p>
</blockquote>
<h3 id="3-14支持变长指针">3.14支持变长指针</h3>
<p>对于一些栈大小是变化的函数，就需要支持变长栈帧。</p>
<p>为了管理变长栈帧，x86-64代码使用<code>%rbp</code>作为<strong>帧指针（Frame Pointer）</strong>。进入函数时，先将其存入到“保存寄存器区”，然后将当前的栈指针<code>%rsp</code>的值赋予<code>%rbp</code>，则函数最后可直接通过将<code>%rbp</code>的值赋予<code>%rsp</code>就能释放变长的栈帧，并且通过“保存寄存器区”来重置<code>%rbp</code>的值。</p>
<p>变长栈帧的申请，会自动进行对齐操作，并且使用<code>%rbp</code>作为初始地址，在函数返回时释放存储空间。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://ryanfcr.github.io/">RyanFcr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://ryanfcr.github.io/2022/01/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/">https://ryanfcr.github.io/2022/01/28/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归RyanFcr所有，如有转载，请注明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post_share"><div class="social-share" data-image="/./img/mmexport1612147589760.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/26/NFT%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"><img class="prev-cover" src="/./img/nft.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">NFT：从入门到精通</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/10/%E6%88%91%E5%9C%A8%E4%BF%A1%E5%AE%89%E7%9A%84%E8%BF%99%E4%B8%A4%E5%B9%B4/"><img class="next-cover" src="/./img/%E9%87%91%E5%B1%B1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我在信安的这两年</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/26/NFT%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/" title="NFT：从入门到精通"><img class="cover" src="/./img/nft.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-26</div><div class="title">NFT：从入门到精通</div></div></a></div><div><a href="/2022/01/18/Crash%20Course%20Computer%20Science/" title="Crash Course Computer Science"><img class="cover" src="/./img/267379862.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-18</div><div class="title">Crash Course Computer Science</div></div></a></div><div><a href="/2022/01/23/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCSAPP%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/" title="《深入理解计算机系统CSAPP》（一）"><img class="cover" src="/./img/mmexport1604462635742.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-23</div><div class="title">《深入理解计算机系统CSAPP》（一）</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTIyNS8zMTY5Mg"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">《深入理解计算机系统CSAPP》（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lecture-03-Machine-Level-Programming%F0%9F%93%9D"><span class="toc-text">Lecture 03 Machine Level Programming📝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-History-of-Intel-Processors-and-architectures"><span class="toc-text">3.1 History of Intel Processors and architectures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-C%EF%BC%8Cassembly%EF%BC%8Cmachine-code"><span class="toc-text">3.2 C，assembly，machine code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Assembly-Basics%EF%BC%9ARegisters%EF%BC%8Coperands%EF%BC%8Cmove"><span class="toc-text">3.3 Assembly Basics：Registers，operands，move</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="toc-text">3.3.1 操作数指示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-Mov"><span class="toc-text">3.3.2 Mov</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E5%AF%84%E5%AD%98%E5%99%A8%E5%B0%8F%E4%BA%8E%E7%9B%AE%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">源寄存器小于目的寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E5%AF%84%E5%AD%98%E5%99%A8%E5%A4%A7%E4%BA%8E%E7%9B%AE%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">源寄存器大于目的寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="toc-text">3.3.3 压入和弹出栈数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Arithmetic-logical-operations"><span class="toc-text">3.4 Arithmetic &amp; logical operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-Control"><span class="toc-text">3.5 Control</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-Condition-codes%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="toc-text">3.5.1 Condition codes条件码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-Conditional-branches"><span class="toc-text">3.5.2 Conditional branches</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#conditional-jump"><span class="toc-text">conditional jump</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#conditional-move"><span class="toc-text">conditional move</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-Loops"><span class="toc-text">3.5.3 Loops</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#do-while"><span class="toc-text">do-while</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#while"><span class="toc-text">while</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Jump-to-middle"><span class="toc-text">Jump-to-middle</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#guarded-do"><span class="toc-text">guarded-do</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for"><span class="toc-text">for</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-Switch-Statements"><span class="toc-text">3.5.4 Switch Statements</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Procedures"><span class="toc-text">3.6 Procedures</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-Stack-Structure"><span class="toc-text">3.6.1 Stack Structure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E6%A0%88%E5%B8%A7%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">3.6.2 栈帧的组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#saved-register"><span class="toc-text">saved register</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Local-Variable-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">Local Variable 局部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%8C%BA"><span class="toc-text">参数构造区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-text">返回地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%BC%E4%B8%8A%E6%89%80%E8%BF%B0%EF%BC%9A"><span class="toc-text">综上所述：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-Calling-Conventions"><span class="toc-text">3.6.3 Calling Conventions</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Passing-control"><span class="toc-text">Passing control</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Passing-data"><span class="toc-text">Passing data</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Managing-local-data"><span class="toc-text">Managing local data</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-4-Illustration-of-Recursion"><span class="toc-text">3.6.4 Illustration of Recursion</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-Array"><span class="toc-text">3.7 Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#One-dimensional"><span class="toc-text">One-dimensional</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multi-dimensional%EF%BC%88nested%EF%BC%89"><span class="toc-text">Multi-dimensional（nested）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fixed-dimensions"><span class="toc-text">Fixed dimensions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Variable-dimensions"><span class="toc-text">Variable dimensions</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-Structures"><span class="toc-text">3.8 Structures</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Allocation-Access"><span class="toc-text">Allocation&#x2F;Access</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Alignment"><span class="toc-text">Alignment</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-Union"><span class="toc-text">3.9 Union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-Floating-Point-%E8%B7%B3%E8%BF%87%E4%B9%9F%E5%8F%AF"><span class="toc-text">3.10 Floating Point(跳过也可)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-text">历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="toc-text">浮点代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E4%BC%A0%E9%80%81"><span class="toc-text">浮点传送</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">浮点转换操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E2%80%93-%E6%95%B4%E5%9E%8B"><span class="toc-text">浮点数–&gt;整型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E2%80%93-%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">整型–&gt;浮点数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">浮点数相互转换</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81"><span class="toc-text">过程中的浮点代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="toc-text">浮点运算操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B5%AE%E7%82%B9%E5%B8%B8%E6%95%B0"><span class="toc-text">定义和使用浮点常数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">浮点代码中的位级操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="toc-text">浮点比较操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-Memory-Layout"><span class="toc-text">3.11 Memory Layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88"><span class="toc-text">3.12 理解指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-Buffer-Overflow"><span class="toc-text">3.13 Buffer Overflow</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%94%BB%E5%87%BB%E7%9A%84%E6%89%8B%E6%AE%B5"><span class="toc-text">避免缓冲区攻击的手段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ROP%E6%94%BB%E5%87%BB"><span class="toc-text">ROP攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14%E6%94%AF%E6%8C%81%E5%8F%98%E9%95%BF%E6%8C%87%E9%92%88"><span class="toc-text">3.14支持变长指针</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/./img/mmexport1612147589760.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By RyanFcr</div><div class="footer_custom_text">✨很高兴认识你🦄</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: '[object Object]',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (true) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>